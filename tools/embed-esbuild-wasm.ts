#!/usr/bin/env -S deno run --allow-read --allow-write --allow-net
/**
 * Embeds esbuild WASM binary into TypeScript as base64
 *
 * This script reads esbuild.wasm and generates src/esbuild-wasm-embedded.ts
 * containing it as a base64 string literal.
 *
 * The embedded WASM allows the compiled HQL binary to use esbuild without
 * needing the WASM file on the filesystem.
 *
 * Usage: deno task embed-esbuild-wasm
 */

import {
  writeTextFile as platformWriteTextFile,
} from "../src/platform/platform.ts";

const ESBUILD_WASM_VERSION = "0.17.19";
const OUTPUT_FILE = "src/esbuild-wasm-embedded.ts";

// Try multiple locations to find esbuild.wasm
async function findEsbuildWasm(): Promise<Uint8Array> {
  // Location 1: Deno cache on macOS
  const macOSCachePath = `${Deno.env.get("HOME")}/Library/Caches/deno/npm/registry.npmjs.org/esbuild-wasm/${ESBUILD_WASM_VERSION}/esbuild.wasm`;

  // Location 2: Deno cache on Linux/Windows
  const linuxCachePath = `${Deno.env.get("HOME")}/.cache/deno/npm/registry.npmjs.org/esbuild-wasm/${ESBUILD_WASM_VERSION}/esbuild.wasm`;

  // Location 3: DENO_DIR environment variable
  const denoDir = Deno.env.get("DENO_DIR");
  const denoDirPath = denoDir ? `${denoDir}/npm/registry.npmjs.org/esbuild-wasm/${ESBUILD_WASM_VERSION}/esbuild.wasm` : null;

  const paths = [macOSCachePath, linuxCachePath, denoDirPath].filter(Boolean) as string[];

  for (const path of paths) {
    try {
      console.log(`üîç Trying: ${path}`);
      const data = await Deno.readFile(path);
      console.log(`‚úÖ Found esbuild.wasm at: ${path}`);
      return data;
    } catch {
      // Continue to next path
    }
  }

  // If not found locally, download it
  console.log("üì• WASM not found in cache, downloading from npm...");
  const url = `https://unpkg.com/esbuild-wasm@${ESBUILD_WASM_VERSION}/esbuild.wasm`;

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to download esbuild.wasm: ${response.status} ${response.statusText}`);
  }

  const data = new Uint8Array(await response.arrayBuffer());
  console.log(`‚úÖ Downloaded esbuild.wasm (${(data.length / 1024 / 1024).toFixed(2)} MB)`);
  return data;
}

function uint8ArrayToBase64(bytes: Uint8Array): string {
  // Process in chunks to avoid call stack issues with large arrays
  const CHUNK_SIZE = 32768;
  let binary = "";

  for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {
    const chunk = bytes.slice(i, i + CHUNK_SIZE);
    binary += String.fromCharCode(...chunk);
  }

  return btoa(binary);
}

async function compress(bytes: Uint8Array): Promise<Uint8Array> {
  const stream = new Blob([bytes]).stream().pipeThrough(new CompressionStream("gzip"));
  return new Uint8Array(await new Response(stream).arrayBuffer());
}

function generateOutput(base64: string): string {
  return `// Auto-generated by tools/embed-esbuild-wasm.ts
// DO NOT EDIT - Run: deno task embed-esbuild-wasm
//
// This file contains esbuild.wasm (v${ESBUILD_WASM_VERSION}) as GZIP compressed base64.
// Used by bundler.ts to initialize esbuild in compiled binaries.

export const ESBUILD_WASM_VERSION = "${ESBUILD_WASM_VERSION}";

// Gzipped WASM binary encoded as Base64
const ESBUILD_WASM_GZIP_BASE64 = "${base64}";

let cachedModule: WebAssembly.Module | null = null;

/**
 * Decode embedded WASM and compile to WebAssembly module.
 * Caches the compiled module for subsequent calls.
 */
export async function getEsbuildWasmModule(): Promise<WebAssembly.Module> {
  if (cachedModule) {
    return cachedModule;
  }

  // Decode base64 to binary (still compressed)
  const binaryString = atob(ESBUILD_WASM_GZIP_BASE64);
  const compressedBytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    compressedBytes[i] = binaryString.charCodeAt(i);
  }

  // Decompress using DecompressionStream
  const stream = new Blob([compressedBytes]).stream().pipeThrough(new DecompressionStream("gzip"));
  const decompressedResponse = new Response(stream);
  const bytes = new Uint8Array(await decompressedResponse.arrayBuffer());

  // Compile to WebAssembly module
  cachedModule = await WebAssembly.compile(bytes);
  return cachedModule;
}
`;
}

async function main() {
  console.log("üöÄ Embedding esbuild WASM...");
  console.log(`   Version: ${ESBUILD_WASM_VERSION}`);

  // Find or download the WASM file
  const wasmBytes = await findEsbuildWasm();
  console.log(`üìä Original WASM size: ${(wasmBytes.length / 1024 / 1024).toFixed(2)} MB`);

  // Compress
  console.log("üóúÔ∏è  Compressing (gzip)...");
  const compressedBytes = await compress(wasmBytes);
  console.log(`üìä Compressed size: ${(compressedBytes.length / 1024 / 1024).toFixed(2)} MB`);
  console.log(`üìâ Reduction: ${(100 - (compressedBytes.length / wasmBytes.length * 100)).toFixed(1)}%`);

  // Convert to base64
  console.log("üîÑ Converting to base64...");
  const base64 = uint8ArrayToBase64(compressedBytes);
  console.log(`üìä Base64 size: ${(base64.length / 1024 / 1024).toFixed(2)} MB`);

  // Generate output file
  console.log("‚ú® Generating esbuild-wasm-embedded.ts...");
  const output = generateOutput(base64);

  await platformWriteTextFile(OUTPUT_FILE, output);

  console.log(`‚úÖ Successfully generated ${OUTPUT_FILE}`);
  console.log(`   Total file size: ${(output.length / 1024 / 1024).toFixed(2)} MB`);
}

if (import.meta.main) {
  main();
}
