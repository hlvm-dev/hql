#!/usr/bin/env -S deno run --allow-read --allow-write
/**
 * Embeds HQL macro source files into TypeScript
 *
 * This script reads .hql macro files from core/lib/macro/ and generates
 * core/src/lib/embedded-macros.ts containing them as string literals.
 *
 * Usage: deno task embed-macros
 */

import { walk } from "https://deno.land/std@0.208.0/fs/walk.ts";
import {
  readTextFile as platformReadTextFile,
  writeTextFile as platformWriteTextFile,
} from "../src/platform/platform.ts";

const MACRO_DIR = "src/lib/macro";
const OUTPUT_FILE = "src/lib/embedded-macros.ts";

interface MacroFile {
  path: string;
  content: string;
}

async function collectMacroFiles(): Promise<MacroFile[]> {
  const files: MacroFile[] = [];

  for await (const entry of walk(MACRO_DIR, { exts: [".hql"] })) {
    if (!entry.isFile) continue;

    const content = await platformReadTextFile(entry.path);
    // Use full path from current directory (core/lib/macro/...)
    const relativePath = entry.path;

    files.push({ path: relativePath, content });
  }

  // Sort for consistent output
  files.sort((a, b) => a.path.localeCompare(b.path));

  return files;
}

function escapeForTemplate(content: string): string {
  // Escape backticks and backslashes for template literal
  return content
    .replace(/\\/g, "\\\\") // Escape backslashes first
    .replace(/`/g, "\\`") // Escape backticks
    .replace(/\$/g, "\\$"); // Escape dollar signs
}

function generateOutput(files: MacroFile[]): string {
  const header = `// Auto-generated. Do not edit by hand.
// Embedded macro sources for core system macros.
//
// IMPORTANT: This file is GENERATED from .hql source files.
// To modify macros:
//   1. Edit the .hql files in core/lib/macro/
//   2. Run: deno task embed-macros
//   3. DO NOT edit this file directly!

export const EMBEDDED_MACROS = {`;

  const entries = files.map(({ path, content }) => {
    const escaped = escapeForTemplate(content);
    return `  "${path}": \`${escaped}\`,`;
  }).join("\n");

  const footer = `} as const;

function normalize(p: string): string { return p.replace(/\\\\/g, "/"); }

export function isEmbeddedFile(p: string): boolean {
  const np = normalize(p);
  for (const k of Object.keys(EMBEDDED_MACROS)) {
    if (np.endsWith(k)) return true;
  }
  return false;
}

export function getEmbeddedContent(p: string): string | undefined {
  const np = normalize(p);
  for (const k of Object.keys(EMBEDDED_MACROS)) {
    if (np.endsWith(k)) return EMBEDDED_MACROS[k as keyof typeof EMBEDDED_MACROS];
  }
  return undefined;
}
`;

  return header + "\n" + entries + "\n" + footer;
}

async function main() {
  console.log("üîç Collecting macro files from", MACRO_DIR);
  const files = await collectMacroFiles();

  console.log(`üì¶ Found ${files.length} macro file(s):`);
  for (const file of files) {
    console.log(`   - ${file.path}`);
  }

  console.log("‚ú® Generating embedded-macros.ts");
  const output = generateOutput(files);

  await platformWriteTextFile(OUTPUT_FILE, output);

  console.log(`‚úÖ Successfully generated ${OUTPUT_FILE}`);
  console.log(`   Total size: ${output.length} bytes`);
}

if (import.meta.main) {
  main();
}
