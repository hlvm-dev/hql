#!/usr/bin/env deno run -A

/**
 * HQL REPL - Interactive Read-Eval-Print Loop
 * Maintains state across expressions like Python/Node REPL
 */

import { transpile } from "../../mod.ts";
import { initializeRuntime } from "../src/common/runtime-initializer.ts";
import {
  getArgs as platformGetArgs,
  exit as platformExit,
  writeTextFile,
  readTextFile,
} from "../src/platform/platform.ts";
import { join } from "https://deno.land/std@0.220.0/path/mod.ts";
import { parse } from "../src/transpiler/pipeline/parser.ts";
import { isList, isSymbol, sexpToString } from "../src/s-exp/types.ts";
import type { SExp, SList } from "../src/s-exp/types.ts";
import * as readline from "node:readline";
import { stdin as input, stdout as output } from "node:process";

const VERSION = "0.1.0";

/**
 * Print welcome message
 */
function printWelcome() {
  console.log(`HQL REPL v${VERSION}`);
  console.log(`Type expressions to evaluate, or .help for commands`);
  console.log(``);
}

/**
 * Print help message
 */
function printHelp() {
  console.log(`
REPL Commands:
  .help              Show this help
  .exit              Exit REPL
  .clear             Clear screen
  .reset             Reset REPL state
  .version           Show version

Examples:
  (+ 1 2)                    → 3
  (print "Hello")            → Hello
  (fn add [x y] (+ x y))     → <function>
  (add 10 20)                → 30
  (let x 10)                 → 10
  x                          → 10
`);
}

/**
 * Create persistent REPL module
 */
async function createReplModule(modulePath: string) {
  const initialCode = `// HQL REPL persistent module
// Auto-generated - do not edit

// Export all definitions for inspection
export const __repl_exports = {};
`;
  await writeTextFile(modulePath, initialCode);
}

/**
 * Main REPL loop
 */
async function startRepl() {
  printWelcome();

  // Initialize runtime once
  console.log("Initializing runtime...");
  const startTime = Date.now();
  await initializeRuntime();
  const initTime = Date.now() - startTime;
  console.log(`Ready! (initialized in ${initTime}ms)\n`);

  // Create persistent module file
  const replDir = await Deno.makeTempDir({ prefix: "hql-repl-" });
  const modulePath = join(replDir, "repl-module.mjs");
  await createReplModule(modulePath);

  // Track line number for source maps
  let lineNumber = 3; // Start after initial comment

  // Create readline interface with history support
  const rl = readline.createInterface({
    input,
    output,
    prompt: "hql> ",
    history: [], // Enable history
  });

  // Setup readline event handlers
  rl.prompt();

  rl.on("line", async (inputLine: string) => {
    const input = inputLine.trim();

    if (!input) {
      rl.prompt();
      return;
    }

    // Handle REPL commands
    if (input.startsWith(".")) {
      const command = input.trim();

      if (command === ".exit" || command === ".quit") {
        console.log("Goodbye!");
        // Cleanup
        try {
          await Deno.remove(replDir, { recursive: true });
        } catch {
          // Ignore cleanup errors
        }
        platformExit(0);
      }

      if (command === ".help" || command === ".h") {
        printHelp();
        rl.prompt(); return;
      }

      if (command === ".version" || command === ".v") {
        console.log(`HQL REPL v${VERSION}`);
        rl.prompt(); return;
      }

      if (command === ".clear" || command === ".c") {
        console.clear();
        rl.prompt(); return;
      }

      if (command === ".reset" || command === ".r") {
        // Reset module
        await createReplModule(modulePath);
        lineNumber = 3;
        console.log("REPL state reset");
        rl.prompt(); return;
      }

      console.error(`Unknown command: ${command}. Type .help for help.`);
      rl.prompt(); return;
    }

    // Evaluate HQL expression
    try {
      // Helper: Clean transpiled JavaScript (remove 'use strict', trailing semicolons)
      const cleanJs = (js: string, removeTrailingSemicolon = false): string => {
        let cleaned = js.replace(/^'use strict';\s*/gm, "").trim();
        if (removeTrailingSemicolon) {
          cleaned = cleaned.replace(/;$/, "");
        }
        return cleaned;
      };

      // Helper: Transpile HQL source
      const transpileHql = async (source: string): Promise<string> => {
        return await transpile(source, {
          baseDir: replDir,
          currentFile: `<repl>:${lineNumber}`,
        });
      };

      // Helper: Format comment for generated code
      const formatComment = (): string =>
        `\n// Line ${lineNumber}: ${input.slice(0, 60)}${input.length > 60 ? "..." : ""}\n`;

      // Parse HQL to determine expression type
      const ast = parse(input, "<repl>");
      if (ast.length === 0) continue;

      const expr = ast[0];
      let isDeclaration = false;
      let isBinding = false;
      let bindingName = "";

      // Detect special forms (declarations and bindings)
      if (isList(expr) && expr.elements.length > 0 && isSymbol(expr.elements[0])) {
        const op = expr.elements[0].name;

        if (op === "fn" || op === "function" || op === "defn" || op === "class") {
          isDeclaration = true;
        } else if ((op === "let" || op === "var") && expr.elements.length >= 3) {
          isBinding = true;
          if (isSymbol(expr.elements[1])) {
            bindingName = expr.elements[1].name;
          }
        }
      }

      // Read current module
      let currentModule = await readTextFile(modulePath);

      let codeToAppend: string;
      let exportName: string | null = null;

      if (isBinding && bindingName) {
        // For bindings: extract value from AST and create module-level const
        const valueExpr = (expr as SList).elements[2];
        const valueSource = sexpToString(valueExpr);
        const jsValue = await transpileHql(valueSource);
        codeToAppend = `${formatComment()}const ${bindingName} = ${cleanJs(jsValue, true)};\n`;
      } else if (isDeclaration) {
        // For declarations: add to module scope
        codeToAppend = `${formatComment()}${cleanJs(await transpileHql(input))}\n`;
      } else {
        // For expressions: export result
        exportName = `__repl_line_${lineNumber}`;
        codeToAppend = `${formatComment()}export const ${exportName} = ${cleanJs(await transpileHql(input), true)};\n`;
      }

      // Update module file
      currentModule += codeToAppend;
      await writeTextFile(modulePath, currentModule);

      // Import module with cache busting and display result
      const module = await import(`file://${modulePath}?t=${Date.now()}`);

      if (exportName) {
        const result = module[exportName];
        if (typeof result === "function") {
          console.log("=> <function>");
        } else if (result !== undefined) {
          console.log("=>", result);
        }
      }

      lineNumber++;
    } catch (error) {
      console.error(`Error: ${error instanceof Error ? error.message : error}`);
    }
  }
}

/**
 * Entry point
 */
export async function main(args: string[] = platformGetArgs()): Promise<number> {
  // Check for help flag
  if (args.includes("--help") || args.includes("-h")) {
    console.log(`
HQL REPL - Interactive Read-Eval-Print Loop

USAGE:
  hql repl [options]

OPTIONS:
  --help, -h        Show this help
  --version         Show version

EXAMPLES:
  hql repl          Start interactive REPL
`);
    return 0;
  }

  // Check for version flag
  if (args.includes("--version")) {
    console.log(`HQL REPL v${VERSION}`);
    return 0;
  }

  await startRepl();
  return 0;
}

if (import.meta.main) {
  const exitCode = await main();
  platformExit(exitCode);
}
