// Auto-generated. Do not edit by hand.
// Embedded macro sources for core system macros.
//
// IMPORTANT: This file is GENERATED from .hql source files.
// To modify macros:
//   1. Edit the .hql files in core/lib/macro/
//   2. Run: deno task embed-macros
//   3. DO NOT edit this file directly!

export const EMBEDDED_MACROS = {
  "core/lib/macro/core.hql":
    `;; ====================================================
;; HQL Core Macros Library
;; ====================================================
;;
;; IMPORTANT: This is the SOURCE FILE for core macros.
;; After editing this file, run: deno task embed-macros
;; to regenerate core/src/lib/embedded-macros.ts
;; ====================================================

(macro not (value)
  \`(if ~value false true))

;; Note: list?, symbol?, and name are built-in functions defined in environment.ts

;; Macro versions for user code (generate efficient inline code)
(macro length (coll)
  \`(if (= ~coll null)
       0
       (js-get ~coll "length")))

(macro first (coll)
  \`(get ~coll 0))

(macro rest (coll)
  \`(js-call ~coll "slice" 1))

(macro next (coll)
  \`(if (< (js-get ~coll "length") 2)
       null
       (js-call ~coll "slice" 1)))

(macro list (& items)
  \`[~@items])

(macro nil? (x)
  \`(= ~x null))

(macro empty? (coll)
  \`(if (nil? ~coll)
       true
       (= (length ~coll) 0)))

(macro or (& args)
  (cond
    ((%empty? args) false)
    ((= (%length args) 1) (%first args))
    (true
      \`((fn (value)
          (if value
              value
              (or ~@(%rest args))))
        ~(%first args)))))

(macro and (& args)
  (cond
    ((%empty? args) true)
    ((= (%length args) 1) (%first args))
    (true
      \`((fn (value)
          (if value
              (and ~@(%rest args))
              value))
        ~(%first args)))))

(macro when (test & body)
  \`(if ~test
       (do ~@body)
       nil))

(macro when-let (binding & body)
  (let (var-name (%first binding)
        var-value (%nth binding 1))
    \`((fn (~var-name)
         (when ~var-name
             ~@body))
       ~var-value)))

(macro unless (test & body)
  \`(if ~test
       nil
       (do ~@body)))

(macro inc (x)
  \`(+ ~x 1))

(macro dec (x)
  \`(- ~x 1))

(macro print (& args)
  \`(console.log ~@args))

(macro cons (item lst)
  \`(concat (list ~item) ~lst))

(fn concat (arr1 arr2)
  (js-call arr1 "concat" arr2))

(macro set (target value)
  \`(set! ~target ~value))

(macro str (& args)
  (cond
    ((%empty? args) \`"")
    ((= (%length args) 1) \`(+ "" ~(%first args)))
    (true \`(+ ~@args))))

(macro contains? (coll key)
  \`(js-call ~coll "has" ~key))

(macro nth (coll index)
  \`(get ~coll ~index))

(macro if-let (binding then-expr else-expr)
  (let (var-name (%first binding)
        var-value (%nth binding 1))
    \`((fn (~var-name)
         (if ~var-name
             ~then-expr
             ~else-expr))
       ~var-value)))

(macro second (coll)
  \`(if (and (not (nil? ~coll)) (> (length ~coll) 1))
      (nth ~coll 1)
      nil))

(macro rest? (coll)
  \`(> (length ~coll) 0))

(macro empty-list? (coll)
  \`(= (length ~coll) 0))

(macro rest-list (coll)
  \`(js-call ~coll "slice" 1))

(macro seq (coll)
  \`(if (= (js-get ~coll "length") 0)
       null
       ~coll))

(macro empty-array ()
  \`(vector))

;; NOTE: \`throw\` is a kernel primitive, not a macro
;; It needs to create ThrowStatement IR node for exception handling

;; method-call is syntactic sugar over js-call
(macro method-call (obj method & args)
  \`(js-call ~obj ~method ~@args))

(macro hash-map (& items)
  \`(__hql_hash_map ~@items))

(macro empty-map ()
  \`(hash-map))

(macro empty-set ()
  \`(hash-set))

;; ----------------------------------------
;; Core control flow
;; ----------------------------------------

(macro cond (& clauses)
  (if (%empty? clauses)
      nil
      (let (first-clause (%first clauses)
            rest-clauses (%rest clauses)
            first-el (%first first-clause))
        ;; Check if first clause is a list (e.g., (else expr))
        ;; If we can extract a first element, it's a list
        (if (not (= first-el nil))
            ;; List clause syntax: ((test) result)
            (let (test first-el
                  result (%first (%rest first-clause)))
              ;; Check if test is the symbol 'else' - if so, return result directly
              (if (symbol? test)
                  (if (= (name test) "else")
                      result
                      ;; Otherwise generate if expression
                      (if (%empty? rest-clauses)
                          \`(if ~test ~result nil)
                          \`(if ~test ~result (cond ~@rest-clauses))))
                  ;; test is not a symbol, generate if expression
                  (if (%empty? rest-clauses)
                      \`(if ~test ~result nil)
                      \`(if ~test ~result (cond ~@rest-clauses)))))
            ;; Flat syntax: test result test result...
            (if (%empty? rest-clauses)
                (throw "cond requires result expression for test")
                (let (test first-clause
                      result (%first rest-clauses)
                      remaining (%rest rest-clauses))
                  (if (%empty? remaining)
                      \`(if ~test ~result nil)
                      \`(if ~test ~result (cond ~@remaining)))))))))

;; NOTE: \`do\` is a kernel primitive, not a macro
;; It needs to create an IIFE with BlockStatement to handle both statements and expressions
;; A macro version using nested \`let\` can only handle expressions, fails with \`var\`/statements
`,
  "core/lib/macro/loop.hql":
    `;; ====================================================
;; HQL Loop Constructs Library - Enhanced Version
;; This library implements a series of looping constructs
;; built on the fundamental loop/recur mechanism
;; ====================================================
;;
;; IMPORTANT: This is the SOURCE FILE for loop macros.
;; After editing this file, run: deno task embed-macros
;; to regenerate core/src/lib/embedded-macros.ts
;; ====================================================

;; ====================
;; 1. While Loop
;; ====================

;; Simple while loop - repeats body as long as condition is true
(macro while (condition & body)
  \`(loop ()
     (if ~condition
       (do
         ~@body
         (recur))
       nil)))

;; ====================
;; 2. Repeat Loop
;; ====================

;; Simple repeat loop - repeats body a specific number of times
;; Example usage:
;; (repeat 3 (print "hello"))
(macro repeat (count & body)
  \`(loop (i 0)
     (if (< i ~count)
       (do
         ~@body
         (recur (+ i 1)))
       nil)))

;; ====================
;; 3. Enhanced For Loop
;; ====================

;; for loop - enhanced iteration with multiple syntaxes
(macro for (binding & body)
  (let (var (%first binding)
        spec (%rest binding)
        spec-count (%length spec)
        first-elem (%first spec))
    (cond
      ;; Error: empty spec
      ((= spec-count 0)
       \`(throw (str "Invalid 'for' loop binding: " '~binding)))

      ;; Collection iteration: (for (x coll) ...)
      ((= spec-count 1)
       \`(__hql_for_each (__hql_toSequence ~first-elem)
          (fn (~var)
            (do
              ~@body))))

      ;; spec-count is 2 - could be positional OR named "to:"
      ((= spec-count 2)
       ;; Check if first element is the SYMBOL "to:"
       (if (symbol? first-elem)
           (if (= (name first-elem) "to:")
               ;; Named form: (for (i to: end) ...)
               (let (end (%nth spec 1))
                 \`(__hql_for_each (__hql_toSequence (__hql_range 0 ~end))
                    (fn (~var)
                      (do
                        ~@body))))
               ;; Positional form: (for (i start end) ...)
               (let (start first-elem
                     end (%nth spec 1))
                 \`(__hql_for_each (__hql_toSequence (__hql_range ~start ~end))
                    (fn (~var)
                      (do
                        ~@body)))))
           ;; Positional form: (for (i start end) ...)
           (let (start first-elem
                 end (%nth spec 1))
             \`(__hql_for_each (__hql_toSequence (__hql_range ~start ~end))
                (fn (~var)
                  (do
                    ~@body))))))

      ;; spec-count is 3 - could be positional OR named with step
      ((= spec-count 3)
       ;; Positional form: (for (i start end step) ...)
       (let (start first-elem
             end (%nth spec 1)
             step (%nth spec 2))
         \`(__hql_for_each (__hql_toSequence (__hql_range ~start ~end ~step))
            (fn (~var)
              (do
                ~@body)))))

      ;; spec-count is 4 - must be named "to: end by: step" OR "from: start to: end"
      ((= spec-count 4)
       (if (symbol? first-elem)
           (if (= (name first-elem) "to:")
               ;; Named form: (for (i to: end by: step) ...)
               (if (symbol? (%nth spec 2))
                   (if (= (name (%nth spec 2)) "by:")
                       (let (end (%nth spec 1)
                             step (%nth spec 3))
                         \`(__hql_for_each (__hql_toSequence (__hql_range 0 ~end ~step))
                            (fn (~var)
                              (do
                                ~@body))))
                       \`(throw (str "Invalid 'for' loop binding: " '~binding)))
                   \`(throw (str "Invalid 'for' loop binding: " '~binding)))
               (if (= (name first-elem) "from:")
                   ;; Named form: (for (i from: start to: end) ...)
                   (if (symbol? (%nth spec 2))
                       (if (= (name (%nth spec 2)) "to:")
                           (let (start (%nth spec 1)
                                 end (%nth spec 3))
                             \`(__hql_for_each (__hql_toSequence (__hql_range ~start ~end))
                                (fn (~var)
                                  (do
                                    ~@body))))
                           \`(throw (str "Invalid 'for' loop binding: " '~binding)))
                       \`(throw (str "Invalid 'for' loop binding: " '~binding)))
                   \`(throw (str "Invalid 'for' loop binding: " '~binding))))
           \`(throw (str "Invalid 'for' loop binding: " '~binding))))

      ;; spec-count is 6 - must be named "from: start to: end by: step"
      ((= spec-count 6)
       (if (symbol? first-elem)
           (if (= (name first-elem) "from:")
               (if (symbol? (%nth spec 2))
                   (if (= (name (%nth spec 2)) "to:")
                       (if (symbol? (%nth spec 4))
                           (if (= (name (%nth spec 4)) "by:")
                               (let (start (%nth spec 1)
                                     end (%nth spec 3)
                                     step (%nth spec 5))
                                 \`(__hql_for_each (__hql_toSequence (__hql_range ~start ~end ~step))
                                    (fn (~var)
                                      (do
                                        ~@body))))
                               \`(throw (str "Invalid 'for' loop binding: " '~binding)))
                           \`(throw (str "Invalid 'for' loop binding: " '~binding)))
                       \`(throw (str "Invalid 'for' loop binding: " '~binding)))
                   \`(throw (str "Invalid 'for' loop binding: " '~binding)))
               \`(throw (str "Invalid 'for' loop binding: " '~binding)))
           \`(throw (str "Invalid 'for' loop binding: " '~binding))))

      (true \`(throw (str "Invalid 'for' loop binding: " '~binding)))))
  )
`,
} as const;

function normalize(p: string): string {
  return p.replace(/\\/g, "/");
}

export function isEmbeddedFile(p: string): boolean {
  const np = normalize(p);
  for (const k of Object.keys(EMBEDDED_MACROS)) {
    if (np.endsWith(k)) return true;
  }
  return false;
}

export function getEmbeddedContent(p: string): string | undefined {
  const np = normalize(p);
  for (const k of Object.keys(EMBEDDED_MACROS)) {
    if (np.endsWith(k)) {
      return EMBEDDED_MACROS[k as keyof typeof EMBEDDED_MACROS];
    }
  }
  return undefined;
}
