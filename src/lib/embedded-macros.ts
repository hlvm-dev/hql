// Auto-generated. Do not edit by hand.
// Embedded macro sources for core system macros.
//
// IMPORTANT: This file is GENERATED from .hql source files.
// To modify macros:
//   1. Edit the .hql files in core/lib/macro/
//   2. Run: deno run -A scripts/embed-packages.ts
//   3. DO NOT edit this file directly!

import { normalizePath } from "../common/utils.ts";

export const EMBEDDED_MACROS = {
  "src/lib/macro/core.hql": ";; ====================================================\n;; HQL Core Macros Library\n;; ====================================================\n;;\n;; IMPORTANT: This is the SOURCE FILE for core macros.\n;; After editing this file, run: deno task embed-macros\n;; to regenerate core/src/lib/embedded-macros.ts\n;; ====================================================\n\n(macro not [value]\n  `(if ~value false true))\n\n;; Note: list?, symbol?, and name are built-in functions defined in environment.ts\n\n;; Macro versions for user code (generate efficient inline code)\n;; NOTE: first, rest, cons, nth, second, seq are in STDLIB (core.js)\n;; They handle LazySeq properly - DO NOT shadow them with macros!\n\n(macro length [coll]\n  `(if (=== ~coll null)\n       0\n       (js-get ~coll \"length\")))\n\n(macro list [& items]\n  `[~@items])\n\n;; REMOVED: nil? - use isNil instead (camelCase convention)\n;; REMOVED: empty? - use isEmpty from stdlib instead (camelCase convention)\n\n;; ----------------------------------------\n;; JavaScript-Style Type Predicates\n;; ----------------------------------------\n;; These compile to OPTIMAL inline JS - no IIFEs, no function calls.\n;; Uses JS loose equality (==) for nullish checks: x == null is true for both null AND undefined.\n\n;; Null/Undefined checks - use JS loose equality for efficiency\n(macro isNull [x]\n  `(=== ~x null))\n\n(macro isUndefined [x]\n  `(=== ~x undefined))\n\n(macro isNil [x]\n  `(== ~x null))              ;; JS: x == null catches both null and undefined\n\n(macro isDefined [x]\n  `(!== ~x undefined))        ;; Direct !== check\n\n(macro notNil [x]\n  `(!= ~x null))              ;; JS: x != null is true when x is neither null nor undefined\n\n;; Type checks - compile to inline typeof checks\n(macro isString [x]\n  `(=== (typeof ~x) \"string\"))\n\n(macro isNumber [x]\n  `(=== (typeof ~x) \"number\"))\n\n(macro isBoolean [x]\n  `(=== (typeof ~x) \"boolean\"))\n\n(macro isFunction [x]\n  `(=== (typeof ~x) \"function\"))\n\n(macro isSymbol [x]\n  `(=== (typeof ~x) \"symbol\"))\n\n;; Object/Array checks - use && for direct JS output\n(macro isArray [x]\n  `(Array.isArray ~x))\n\n(macro isObject [x]\n  `(&& (&& (=== (typeof ~x) \"object\")\n           (!== ~x null))\n       (! (Array.isArray ~x))))\n\n;; Numeric predicates: isEven, isOdd, isZero, isPositive, isNegative\n;; These are FUNCTIONS in stdlib (core.js), not macros.\n;; Functions can be passed to higher-order functions like filter/map.\n\n;; ----------------------------------------\n;; camelCase Aliases for Lisp-Style Macros\n;; ----------------------------------------\n;; Pure aliases - expand to the kebab-case versions.\n\n(macro ifLet [binding then-expr else-expr]\n  `(if-let ~binding ~then-expr ~else-expr))\n\n(macro whenLet [binding & body]\n  `(when-let ~binding ~@body))\n\n(macro or [& args]\n  (cond\n    ((%empty? args) false)\n    ((=== (%length args) 1) (%first args))\n    (true `(|| ~(%first args) (or ~@(%rest args))))))\n\n(macro and [& args]\n  (cond\n    ((%empty? args) true)\n    ((=== (%length args) 1) (%first args))\n    (true `(&& ~(%first args) (and ~@(%rest args))))))\n\n(macro when [test & body]\n  `(if ~test\n       (do ~@body)\n       nil))\n\n;; Handle [] syntax: (when-let [x val]) is parsed as (when-let (vector x val))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n(macro when-let [binding & body]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var-name (%first normalized-binding)\n          var-value (%nth normalized-binding 1))\n      `((fn [~var-name]\n           (when ~var-name\n               ~@body))\n         ~var-value))))\n\n(macro unless [test & body]\n  `(if ~test\n       nil\n       (do ~@body)))\n\n(macro inc [x]\n  `(+ ~x 1))\n\n(macro dec [x]\n  `(- ~x 1))\n\n(macro print [& args]\n  `(console.log ~@args))\n\n;; NOTE: cons is in STDLIB - handles LazySeq properly\n\n(macro set [target value]\n  `(= ~target ~value))\n\n(macro str [& args]\n  (cond\n    ((%empty? args) `\"\")\n    ((=== (%length args) 1) `(+ \"\" ~(%first args)))\n    (true `(+ ~@args))))\n\n(macro contains [coll key]\n  `(js-call ~coll \"has\" ~key))\n\n;; NOTE: nth is in STDLIB - handles LazySeq properly\n\n;; Handle [] syntax: (if-let [x val]) is parsed as (if-let (vector x val))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n(macro if-let [binding then-expr else-expr]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var-name (%first normalized-binding)\n          var-value (%nth normalized-binding 1))\n      `((fn [~var-name]\n           (if ~var-name\n               ~then-expr\n               ~else-expr))\n         ~var-value))))\n\n;; NOTE: second is in STDLIB - handles LazySeq properly\n\n(macro hasElements [coll]\n  `(> (length ~coll) 0))\n\n(macro isEmptyList [coll]\n  `(=== (length ~coll) 0))\n\n;; NOTE: seq is in STDLIB - handles LazySeq properly\n\n(macro empty-array []\n  `(vector))\n\n;; NOTE: `throw` is a kernel primitive, not a macro\n;; It needs to create ThrowStatement IR node for exception handling\n\n;; method-call is syntactic sugar over js-call\n(macro method-call [obj method & args]\n  `(js-call ~obj ~method ~@args))\n\n(macro hash-map [& items]\n  `(__hql_hash_map ~@items))\n\n(macro empty-map []\n  `(hash-map))\n\n(macro empty-set []\n  `(hash-set))\n\n;; ----------------------------------------\n;; Core control flow\n;; ----------------------------------------\n\n;; cond - Supports BOTH syntaxes:\n;; Grouped syntax: (cond ((< x 0) \"neg\") ((> x 0) \"pos\") (true \"zero\"))\n;; Flat syntax:    (cond (< x 0) \"neg\" (> x 0) \"pos\" :else \"zero\")\n;; Detection: If first clause is a list with exactly 2 elements, use grouped syntax.\n;; NOTE: Uses nested if instead of && to avoid circular dependency (and macro uses cond)\n(macro cond [& clauses]\n  (if (%empty? clauses)\n      nil\n      ;; Detect syntax based on first clause\n      (let (first-clause (%first clauses))\n        ;; Grouped syntax: first clause is a list with 2 elements like ((< x 0) \"result\")\n        ;; Use nested if instead of && to avoid circular dependency\n        (if (list? first-clause)\n            (if (=== (%length first-clause) 2)\n                ;; Grouped syntax: each clause is (test result)\n                (let (test (%first first-clause)\n                      result (%first (%rest first-clause))\n                      remaining (%rest clauses))\n                  (if (symbol? test)\n                      (if (=== (name test) \"else\")\n                          result\n                          (if (%empty? remaining)\n                              `(if ~test ~result nil)\n                              `(if ~test ~result (cond ~@remaining))))\n                      (if (%empty? remaining)\n                          `(if ~test ~result nil)\n                          `(if ~test ~result (cond ~@remaining)))))\n                ;; List but not 2 elements - treat as flat syntax\n                (if (%empty? (%rest clauses))\n                    first-clause\n                    (let (test first-clause\n                          result (%first (%rest clauses))\n                          remaining (%rest (%rest clauses)))\n                      (if (symbol? test)\n                          (if (=== (name test) \"else\")\n                              result\n                              (if (%empty? remaining)\n                                  `(if ~test ~result nil)\n                                  `(if ~test ~result (cond ~@remaining))))\n                          (if (%empty? remaining)\n                              `(if ~test ~result nil)\n                              `(if ~test ~result (cond ~@remaining)))))))\n            ;; Not a list - flat syntax: test1 result1 test2 result2 ...\n            (if (%empty? (%rest clauses))\n                ;; Single element - just return it (handles :else or true at end)\n                first-clause\n                (let (test first-clause\n                      result (%first (%rest clauses))\n                      remaining (%rest (%rest clauses)))\n                  (if (symbol? test)\n                      (if (=== (name test) \"else\")\n                          result\n                          (if (%empty? remaining)\n                              `(if ~test ~result nil)\n                              `(if ~test ~result (cond ~@remaining))))\n                      (if (%empty? remaining)\n                          `(if ~test ~result nil)\n                          `(if ~test ~result (cond ~@remaining))))))))))\n\n;; NOTE: `do` is a kernel primitive, not a macro\n;; It needs to create an IIFE with BlockStatement to handle both statements and expressions\n;; A macro version using nested `let` can only handle expressions, fails with `var`/statements\n\n;; ----------------------------------------\n;; Threading Macros (Clojure-compatible)\n;; ----------------------------------------\n;; These are compile-time transformations with ZERO runtime overhead.\n;; They transform nested function calls into readable linear pipelines.\n\n;; Thread-first: inserts x as FIRST argument of each form\n;; (-> x (f a) (g b)) => (g (f x a) b)\n;; (-> x f g) => (g (f x))\n(macro -> [x & forms]\n  (if (%empty? forms)\n    x\n    (let (form (%first forms)\n          rest-forms (%rest forms)\n          threaded (if (list? form)\n                     ;; Form is a list like (f a b), insert x as first arg: (f x a b)\n                     `(~(%first form) ~x ~@(%rest form))\n                     ;; Form is a symbol like f, make it (f x)\n                     `(~form ~x)))\n      `(-> ~threaded ~@rest-forms))))\n\n;; Thread-last: inserts x as LAST argument of each form\n;; (->> x (f a) (g b)) => (g b (f a x))\n;; (->> x f g) => (g (f x))\n(macro ->> [x & forms]\n  (if (%empty? forms)\n    x\n    (let (form (%first forms)\n          rest-forms (%rest forms)\n          threaded (if (list? form)\n                     ;; Form is a list like (f a b), insert x as last arg: (f a b x)\n                     `(~@form ~x)\n                     ;; Form is a symbol like f, make it (f x)\n                     `(~form ~x)))\n      `(->> ~threaded ~@rest-forms))))\n\n;; Thread-as: binds x to a symbol for arbitrary placement\n;; (as-> 2 x (+ x 1) (* x 3)) => ((fn [x] (* x 3)) ((fn [x] (+ x 1)) 2))\n;; Each form is wrapped in a function that binds the name, avoiding rebinding issues\n(macro as-> [expr name & forms]\n  (if (%empty? forms)\n    expr\n    (let (first-form (%first forms)\n          rest-forms (%rest forms))\n      `((fn [~name] (as-> ~first-form ~name ~@rest-forms))\n        ~expr))))\n\n;; ----------------------------------------\n;; Pattern Matching (Swift/Scala-style syntax)\n;; ----------------------------------------\n;; Syntax:\n;;   (match value\n;;     (case pattern result)\n;;     (case pattern (if guard) result)\n;;     (default result))\n;;\n;; Supported patterns:\n;;   - Literals: 42, \"hello\", true, null\n;;   - Wildcard: _ (matches anything, no binding)\n;;   - Symbol: x (matches anything, binds to x)\n;;   - Array: [a, b], [], [h, & t] (rest pattern)\n;;   - Object: {name, age}, {name: n, age: a}\n;;\n;; Guards: (if condition) checked AFTER pattern binding\n;;\n;; Implementation: Uses IIFE with JS destructuring for object/array patterns.\n;; This avoids macro-time let evaluation issues.\n;; Time complexity: O(n) where n = number of clauses (optimal for sequential matching)\n\n\n;; Main match macro - binds value once, dispatches to implementation\n;; Uses auto-gensym (val#) for hygiene - Clojure-style syntax\n(macro match [value & clauses]\n  `(let (val# ~value)\n     (__match_impl__ val# ~@clauses)))\n\n;; Implementation macro - processes clauses recursively\n(macro __match_impl__ [val-sym & clauses]\n  (if (%empty? clauses)\n      `((fn [] (throw (new Error \"No matching pattern\"))))\n      (let (clause (%first clauses)\n            rest-clauses (%rest clauses)\n            clause-kind (if (list? clause)\n                            (if (symbol? (%first clause))\n                                (name (%first clause))\n                                \"unknown\")\n                            \"unknown\"))\n        (cond\n          ((=== clause-kind \"default\")\n           (%nth clause 1))\n\n          ((=== clause-kind \"case\")\n           (let (pattern (%nth clause 1)\n                 ;; Guard detection\n                 has-guard (if (>= (%length clause) 4)\n                               (if (list? (%nth clause 2))\n                                   (if (symbol? (%first (%nth clause 2)))\n                                       (=== (name (%first (%nth clause 2))) \"if\")\n                                       false)\n                                   false)\n                               false)\n                 guard-expr (if has-guard (%nth (%nth clause 2) 1) nil)\n                 result-expr (if has-guard (%nth clause 3) (%nth clause 2))\n                 ;; Pattern classification - single symbol? check, reuse result\n                 pat-name (if (symbol? pattern) (name pattern) nil)\n                 is-wildcard (=== pat-name \"_\")\n                 is-null-pat (=== pat-name \"null\")\n                 is-binding (if pat-name (if is-wildcard false (if is-null-pat false true)) false)\n                 ;; List pattern detection\n                 is-list (if pat-name false (list? pattern))\n                 head-name (if is-list (if (symbol? (%first pattern)) (name (%first pattern)) nil) nil)\n                 is-object (if head-name (if (=== head-name \"hash-map\") true (=== head-name \"__hql_hash_map\")) false)\n                 is-array (if is-list (if is-object false true) false)\n                 ;; Array rest pattern detection\n                 arr-len (if is-array (%length pattern) 0)\n                 has-rest (if (>= arr-len 2)\n                              (if (symbol? (%nth pattern (- arr-len 2)))\n                                  (=== (name (%nth pattern (- arr-len 2))) \"&\")\n                                  false)\n                              false)\n                 check-len (if has-rest (- arr-len 2) arr-len)\n                 ;; Generate condition using runtime helper __hql_match_obj\n                 ;; For object patterns, pass the entire pattern - runtime extracts keys dynamically\n                 ;; No hardcoding of key count - works for ANY number of keys\n                 condition (cond\n                             (is-wildcard true)\n                             (is-binding true)\n                             (is-null-pat `(=== ~val-sym null))\n                             ;; Object pattern: pass pattern to runtime helper\n                             ;; __hql_match_obj(val, pattern) extracts keys from pattern at indices 1,3,5,...\n                             (is-object `(__hql_match_obj ~val-sym (quote ~pattern)))\n                             (is-array (if has-rest\n                                           `(and (Array.isArray ~val-sym)\n                                                 (>= (js-get ~val-sym \"length\") ~check-len))\n                                           `(and (Array.isArray ~val-sym)\n                                                 (=== (js-get ~val-sym \"length\") ~check-len))))\n                             (else `(=== ~val-sym ~pattern)))\n                 ;; Fallback for next clause\n                 fallback `(__match_impl__ ~val-sym ~@rest-clauses)\n                 ;; Generate body - uses IIFE with destructuring param for object/array\n                 ;; This bypasses macro-time let evaluation which doesn't support destructuring\n                 body (cond\n                        ;; Simple symbol binding\n                        (is-binding\n                         (if has-guard\n                             `(let (~pattern ~val-sym) (if ~guard-expr ~result-expr ~fallback))\n                             `(let (~pattern ~val-sym) ~result-expr)))\n                        ;; Destructuring via IIFE - fn param supports destructuring!\n                        (is-object\n                         (if has-guard\n                             `((fn [~pattern] (if ~guard-expr ~result-expr ~fallback)) ~val-sym)\n                             `((fn [~pattern] ~result-expr) ~val-sym)))\n                        (is-array\n                         (if has-guard\n                             `((fn [~pattern] (if ~guard-expr ~result-expr ~fallback)) ~val-sym)\n                             `((fn [~pattern] ~result-expr) ~val-sym)))\n                        ;; No binding (wildcard, null, literal)\n                        (else\n                         (if has-guard `(if ~guard-expr ~result-expr ~fallback) result-expr))))\n             ;; Optimization: skip (if true ...) when condition is always true\n             (if (=== condition true)\n                 body\n                 `(if ~condition ~body ~fallback))))\n\n          (else\n           `((fn [] (throw (new Error \"Invalid match clause\")))))))))\n",
  "src/lib/macro/utils.hql": ";; ====================================================\n;; HQL Utility Macros\n;; Common Lisp-style utilities\n;; ====================================================\n\n;; doto: Executes forms with x as first argument, returns x\n;; (doto (new HashMap) (.set \"a\" 1) (.set \"b\" 2))\n(macro doto [x & forms]\n  (let (gx (gensym \"doto\"))\n    `(let (~gx ~x)\n       ~@(map (fn [f]\n                (if (list? f)\n                  (let (head (%first f))\n                    (if (symbol? head)\n                        (let (hname (name head))\n                          (if (=== (js-call hname \"charAt\" 0) \".\")\n                              `(js-call ~gx ~(js-call hname \"substring\" 1) ~@(%rest f))\n                              `(~head ~gx ~@(%rest f))))\n                        `(~head ~gx ~@(%rest f))))\n                  `(~f ~gx)))\n              forms)\n       ~gx)))\n\n;; if-not: Inverse of if\n(macro if-not [test then else]\n  `(if ~test ~else ~then))\n\n;; when-not: Inverse of when\n(macro when-not [test & body]\n  `(if ~test nil (do ~@body)))\n\n;; xor: Logical XOR\n(macro xor [a b]\n  (let (ga (gensym \"xor_a\")\n        gb (gensym \"xor_b\"))\n    `(let (~ga ~a\n           ~gb ~b)\n       (if ~ga (not ~gb) ~gb))))\n\n;; min/max macros expanding to Math functions\n(macro min [& args]\n  `(Math.min ~@args))\n\n(macro max [& args]\n  `(Math.max ~@args))\n\n;; with-gensyms: Hygiene helper for macro writers\n;; Binds each name to a unique gensym for safe macro expansion.\n;;\n;; Usage:\n;;   (macro my-swap [a b]\n;;     (with-gensyms [tmp]\n;;       `(let (~tmp ~a)\n;;          (= ~a ~b)\n;;          (= ~b ~tmp))))\n;;\n;; Each name in the vector gets bound to (gensym \"name\"), making the\n;; macro hygienic by avoiding variable capture.\n(macro with-gensyms [names & body]\n  `(let ~(apply vector\n           (apply concat\n             (map (fn [n]\n                    [n `(gensym ~(if (symbol? n) (name n) \"g\"))])\n                  names)))\n     ~@body))\n",
  "src/lib/macro/loop.hql": ";; ====================================================\n;; HQL Loop Constructs Library - Enhanced Version\n;; This library implements a series of looping constructs\n;; built on the fundamental loop/recur mechanism\n;; ====================================================\n;;\n;; IMPORTANT: This is the SOURCE FILE for loop macros.\n;; After editing this file, run: deno task embed-macros\n;; to regenerate core/src/lib/embedded-macros.ts\n;; ====================================================\n\n;; ====================\n;; 1. While Loop\n;; ====================\n\n;; Simple while loop - repeats body as long as condition is true\n(macro while [condition & body]\n  `(loop []\n     (if ~condition\n       (do\n         ~@body\n         (recur))\n       nil)))\n\n;; ====================\n;; 2. Dotimes Loop (Clojure-style fixed iteration)\n;; ====================\n\n;; Simple dotimes loop - executes body a specific number of times\n;; Named after Clojure's dotimes to avoid conflicts with user code\n;; Example usage:\n;; (dotimes 3 (print \"hello\"))\n(macro dotimes [count & body]\n  `(loop [i 0]\n     (if (< i ~count)\n       (do\n         ~@body\n         (recur (+ i 1)))\n       nil)))\n\n;; ====================\n;; 2b. Repeat Loop (alias for dotimes)\n;; ====================\n\n;; repeat loop - executes body a specific number of times\n;; Same as dotimes but with a different name\n;; Example usage:\n;; (repeat 3 (print \"hello\"))\n(macro repeat [count & body]\n  `(loop [__repeat_i 0]\n     (if (< __repeat_i ~count)\n       (do\n         ~@body\n         (recur (+ __repeat_i 1)))\n       nil)))\n\n;; ====================\n;; 3. Enhanced For Loop\n;; ====================\n\n;; for loop - enhanced iteration with multiple syntaxes\n;; Handle [] syntax: (for [x coll]) is parsed as (for (vector x coll))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n;;\n;; IMPORTANT: Uses for-of internally (not __hql_for_each with callback)\n;; so that return/break/continue work correctly from the enclosing function.\n(macro for [binding & body]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var (%first normalized-binding)\n          spec (%rest normalized-binding)\n          spec-count (%length spec)\n          first-elem (%first spec))\n    (cond\n      ;; Error: empty spec\n      ((=== spec-count 0)\n       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n\n      ;; Collection/count iteration: (for (x coll) ...) or (for (i n) ...)\n      ;; Uses for-of with __hql_toIterable to handle both collections and numbers\n      ;; Numbers are converted to range(0, n) at runtime\n      ((=== spec-count 1)\n       `(for-of [~var (__hql_toIterable ~first-elem)]\n          ~@body))\n\n      ;; spec-count is 2 - could be positional OR named \"to:\"\n      ((=== spec-count 2)\n       ;; Check if first element is the SYMBOL \"to:\"\n       (if (symbol? first-elem)\n           (if (=== (name first-elem) \"to:\")\n               ;; Named form: (for (i to: end) ...)\n               (let (end (%nth spec 1))\n                 `(for-of [~var (__hql_range 0 ~end)]\n                    ~@body))\n               ;; Positional form: (for (i start end) ...)\n               (let (start first-elem\n                     end (%nth spec 1))\n                 `(for-of [~var (__hql_range ~start ~end)]\n                    ~@body)))\n           ;; Positional form: (for (i start end) ...)\n           (let (start first-elem\n                 end (%nth spec 1))\n             `(for-of [~var (__hql_range ~start ~end)]\n                ~@body))))\n\n      ;; spec-count is 3 - could be positional OR named with step\n      ((=== spec-count 3)\n       ;; Positional form: (for (i start end step) ...)\n       (let (start first-elem\n             end (%nth spec 1)\n             step (%nth spec 2))\n         `(for-of [~var (__hql_range ~start ~end ~step)]\n            ~@body)))\n\n      ;; spec-count is 4 - must be named \"to: end by: step\" OR \"from: start to: end\"\n      ((=== spec-count 4)\n       (if (symbol? first-elem)\n           (if (=== (name first-elem) \"to:\")\n               ;; Named form: (for (i to: end by: step) ...)\n               (if (symbol? (%nth spec 2))\n                   (if (=== (name (%nth spec 2)) \"by:\")\n                       (let (end (%nth spec 1)\n                             step (%nth spec 3))\n                         `(for-of [~var (__hql_range 0 ~end ~step)]\n                            ~@body))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n               (if (=== (name first-elem) \"from:\")\n                   ;; Named form: (for (i from: start to: end) ...)\n                   (if (symbol? (%nth spec 2))\n                       (if (=== (name (%nth spec 2)) \"to:\")\n                           (let (start (%nth spec 1)\n                                 end (%nth spec 3))\n                             `(for-of [~var (__hql_range ~start ~end)]\n                                ~@body))\n                           `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n           `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n\n      ;; spec-count is 6 - must be named \"from: start to: end by: step\"\n      ((=== spec-count 6)\n       (if (symbol? first-elem)\n           (if (=== (name first-elem) \"from:\")\n               (if (symbol? (%nth spec 2))\n                   (if (=== (name (%nth spec 2)) \"to:\")\n                       (if (symbol? (%nth spec 4))\n                           (if (=== (name (%nth spec 4)) \"by:\")\n                               (let (start (%nth spec 1)\n                                     end (%nth spec 3)\n                                     step (%nth spec 5))\n                                 `(for-of [~var (__hql_range ~start ~end ~step)]\n                                    ~@body))\n                               `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                           `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n               `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n           `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n\n      (true `(throw (str \"Invalid 'for' loop binding: \" '~binding))))))\n  )\n"
};

export function isEmbeddedFile(p: string): boolean {
  const np = normalizePath(p);
  for (const k of Object.keys(EMBEDDED_MACROS)) {
    if (np.endsWith(k)) return true;
  }
  return false;
}

export function getEmbeddedContent(p: string): string | undefined {
  const np = normalizePath(p);
  for (const k of Object.keys(EMBEDDED_MACROS)) {
    if (np.endsWith(k)) return EMBEDDED_MACROS[k as keyof typeof EMBEDDED_MACROS];
  }
  return undefined;
}
