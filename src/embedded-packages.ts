// Auto-generated file with embedded HQL packages
// This file is generated by scripts/embed-packages.ts
// DO NOT EDIT MANUALLY

export const EMBEDDED_PACKAGES: Record<string, string> = {
  "@hql/lib/macro/core.hql": ";; ====================================================\n;; HQL Core Macros Library\n;; ====================================================\n;;\n;; IMPORTANT: This is the SOURCE FILE for core macros.\n;; After editing this file, run: deno task embed-macros\n;; to regenerate core/src/lib/embedded-macros.ts\n;; ====================================================\n\n(macro not [value]\n  `(if ~value false true))\n\n;; Note: list?, symbol?, and name are built-in functions defined in environment.ts\n\n;; Macro versions for user code (generate efficient inline code)\n;; NOTE: first, rest, cons, nth, second, seq are in STDLIB (core.js)\n;; They handle LazySeq properly - DO NOT shadow them with macros!\n\n(macro length [coll]\n  `(if (=== ~coll null)\n       0\n       (js-get ~coll \"length\")))\n\n(macro list [& items]\n  `[~@items])\n\n;; REMOVED: nil? - use isNil instead (camelCase convention)\n;; REMOVED: empty? - use isEmpty from stdlib instead (camelCase convention)\n\n;; ----------------------------------------\n;; JavaScript-Style Type Predicates\n;; ----------------------------------------\n;; These compile to OPTIMAL inline JS - no IIFEs, no function calls.\n;; Uses JS loose equality (==) for nullish checks: x == null is true for both null AND undefined.\n\n;; Null/Undefined checks - use JS loose equality for efficiency\n(macro isNull [x]\n  `(=== ~x null))\n\n(macro isUndefined [x]\n  `(=== ~x undefined))\n\n(macro isNil [x]\n  `(== ~x null))              ;; JS: x == null catches both null and undefined\n\n(macro isDefined [x]\n  `(!== ~x undefined))        ;; Direct !== check\n\n(macro notNil [x]\n  `(!= ~x null))              ;; JS: x != null is true when x is neither null nor undefined\n\n;; Type checks - compile to inline typeof checks\n(macro isString [x]\n  `(=== (typeof ~x) \"string\"))\n\n(macro isNumber [x]\n  `(=== (typeof ~x) \"number\"))\n\n(macro isBoolean [x]\n  `(=== (typeof ~x) \"boolean\"))\n\n(macro isFunction [x]\n  `(=== (typeof ~x) \"function\"))\n\n(macro isSymbol [x]\n  `(=== (typeof ~x) \"symbol\"))\n\n;; Object/Array checks - use && for direct JS output\n(macro isArray [x]\n  `(Array.isArray ~x))\n\n(macro isObject [x]\n  `(&& (&& (=== (typeof ~x) \"object\")\n           (!== ~x null))\n       (! (Array.isArray ~x))))\n\n;; Numeric predicates: isEven, isOdd, isZero, isPositive, isNegative\n;; These are FUNCTIONS in stdlib (core.js), not macros.\n;; Functions can be passed to higher-order functions like filter/map.\n\n;; ----------------------------------------\n;; camelCase Aliases for Lisp-Style Macros\n;; ----------------------------------------\n;; Pure aliases - expand to the kebab-case versions.\n\n(macro ifLet [binding then-expr else-expr]\n  `(if-let ~binding ~then-expr ~else-expr))\n\n(macro whenLet [binding & body]\n  `(when-let ~binding ~@body))\n\n(macro or [& args]\n  (cond\n    ((%empty? args) false)\n    ((=== (%length args) 1) (%first args))\n    (true\n      `((fn [value]\n          (if value\n              value\n              (or ~@(%rest args))))\n        ~(%first args)))))\n\n(macro and [& args]\n  (cond\n    ((%empty? args) true)\n    ((=== (%length args) 1) (%first args))\n    (true\n      `((fn [value]\n          (if value\n              (and ~@(%rest args))\n              value))\n        ~(%first args)))))\n\n(macro when [test & body]\n  `(if ~test\n       (do ~@body)\n       nil))\n\n;; Handle [] syntax: (when-let [x val]) is parsed as (when-let (vector x val))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n(macro when-let [binding & body]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var-name (%first normalized-binding)\n          var-value (%nth normalized-binding 1))\n      `((fn [~var-name]\n           (when ~var-name\n               ~@body))\n         ~var-value))))\n\n(macro unless [test & body]\n  `(if ~test\n       nil\n       (do ~@body)))\n\n(macro inc [x]\n  `(+ ~x 1))\n\n(macro dec [x]\n  `(- ~x 1))\n\n(macro print [& args]\n  `(console.log ~@args))\n\n;; NOTE: cons is in STDLIB - handles LazySeq properly\n\n(macro set [target value]\n  `(= ~target ~value))\n\n(macro str [& args]\n  (cond\n    ((%empty? args) `\"\")\n    ((=== (%length args) 1) `(+ \"\" ~(%first args)))\n    (true `(+ ~@args))))\n\n(macro contains [coll key]\n  `(js-call ~coll \"has\" ~key))\n\n;; NOTE: nth is in STDLIB - handles LazySeq properly\n\n;; Handle [] syntax: (if-let [x val]) is parsed as (if-let (vector x val))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n(macro if-let [binding then-expr else-expr]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var-name (%first normalized-binding)\n          var-value (%nth normalized-binding 1))\n      `((fn [~var-name]\n           (if ~var-name\n               ~then-expr\n               ~else-expr))\n         ~var-value))))\n\n;; NOTE: second is in STDLIB - handles LazySeq properly\n\n(macro hasElements [coll]\n  `(> (length ~coll) 0))\n\n(macro isEmptyList [coll]\n  `(=== (length ~coll) 0))\n\n;; NOTE: seq is in STDLIB - handles LazySeq properly\n\n(macro empty-array []\n  `(vector))\n\n;; NOTE: `throw` is a kernel primitive, not a macro\n;; It needs to create ThrowStatement IR node for exception handling\n\n;; method-call is syntactic sugar over js-call\n(macro method-call [obj method & args]\n  `(js-call ~obj ~method ~@args))\n\n(macro hash-map [& items]\n  `(__hql_hash_map ~@items))\n\n(macro empty-map []\n  `(hash-map))\n\n(macro empty-set []\n  `(hash-set))\n\n;; ----------------------------------------\n;; Core control flow\n;; ----------------------------------------\n\n(macro cond [& clauses]\n  (if (%empty? clauses)\n      nil\n      (let (first-clause (%first clauses)\n            rest-clauses (%rest clauses)\n            first-el (%first first-clause))\n        ;; Check if first clause is a list (e.g., (else expr))\n        ;; If we can extract a first element, it's a list\n        (if (not (=== first-el nil))\n            ;; List clause syntax: ((test) result)\n            (let (test first-el\n                  result (%first (%rest first-clause)))\n              ;; Check if test is the symbol 'else' - if so, return result directly\n              (if (symbol? test)\n                  (if (=== (name test) \"else\")\n                      result\n                      ;; Otherwise generate if expression\n                      (if (%empty? rest-clauses)\n                          `(if ~test ~result nil)\n                          `(if ~test ~result (cond ~@rest-clauses))))\n                  ;; test is not a symbol, generate if expression\n                  (if (%empty? rest-clauses)\n                      `(if ~test ~result nil)\n                      `(if ~test ~result (cond ~@rest-clauses)))))\n            ;; Flat syntax: test result test result...\n            (if (%empty? rest-clauses)\n                (throw \"cond requires result expression for test\")\n                (let (test first-clause\n                      result (%first rest-clauses)\n                      remaining (%rest rest-clauses))\n                  (if (%empty? remaining)\n                      `(if ~test ~result nil)\n                      `(if ~test ~result (cond ~@remaining)))))))))\n\n;; NOTE: `do` is a kernel primitive, not a macro\n;; It needs to create an IIFE with BlockStatement to handle both statements and expressions\n;; A macro version using nested `let` can only handle expressions, fails with `var`/statements\n\n;; ----------------------------------------\n;; Threading Macros (Clojure-compatible)\n;; ----------------------------------------\n;; These are compile-time transformations with ZERO runtime overhead.\n;; They transform nested function calls into readable linear pipelines.\n\n;; Thread-first: inserts x as FIRST argument of each form\n;; (-> x (f a) (g b)) => (g (f x a) b)\n;; (-> x f g) => (g (f x))\n(macro -> [x & forms]\n  (if (%empty? forms)\n    x\n    (let (form (%first forms)\n          rest-forms (%rest forms)\n          threaded (if (list? form)\n                     ;; Form is a list like (f a b), insert x as first arg: (f x a b)\n                     `(~(%first form) ~x ~@(%rest form))\n                     ;; Form is a symbol like f, make it (f x)\n                     `(~form ~x)))\n      `(-> ~threaded ~@rest-forms))))\n\n;; Thread-last: inserts x as LAST argument of each form\n;; (->> x (f a) (g b)) => (g b (f a x))\n;; (->> x f g) => (g (f x))\n(macro ->> [x & forms]\n  (if (%empty? forms)\n    x\n    (let (form (%first forms)\n          rest-forms (%rest forms)\n          threaded (if (list? form)\n                     ;; Form is a list like (f a b), insert x as last arg: (f a b x)\n                     `(~@form ~x)\n                     ;; Form is a symbol like f, make it (f x)\n                     `(~form ~x)))\n      `(->> ~threaded ~@rest-forms))))\n\n;; Thread-as: binds x to a symbol for arbitrary placement\n;; (as-> 2 x (+ x 1) (* x 3)) => ((fn [x] (* x 3)) ((fn [x] (+ x 1)) 2))\n;; Each form is wrapped in a function that binds the name, avoiding rebinding issues\n(macro as-> [expr name & forms]\n  (if (%empty? forms)\n    expr\n    (let (first-form (%first forms)\n          rest-forms (%rest forms))\n      `((fn [~name] (as-> ~first-form ~name ~@rest-forms))\n        ~expr))))\n\n;; ----------------------------------------\n;; Pattern Matching (Swift/Scala-style syntax)\n;; ----------------------------------------\n;; Syntax:\n;;   (match value\n;;     (case pattern result)\n;;     (case pattern (if guard) result)\n;;     (default result))\n;;\n;; Supported patterns:\n;;   - Literals: 42, \"hello\", true, null\n;;   - Wildcard: _ (matches anything, no binding)\n;;   - Symbol: x (matches anything, binds to x)\n;;   - Array: [a, b], [], [h, & t] (rest pattern)\n;;   - Object: {name, age}, {name: n, age: a}\n;;\n;; Guards: (if condition) checked AFTER pattern binding\n;;\n;; Implementation: Uses IIFE with JS destructuring for object/array patterns.\n;; This avoids macro-time let evaluation issues.\n;; Time complexity: O(n) where n = number of clauses (optimal for sequential matching)\n\n\n;; Main match macro - binds value once, dispatches to implementation\n;; Uses auto-gensym (val#) for hygiene - Clojure-style syntax\n(macro match [value & clauses]\n  `(let (val# ~value)\n     (__match_impl__ val# ~@clauses)))\n\n;; Implementation macro - processes clauses recursively\n(macro __match_impl__ [val-sym & clauses]\n  (if (%empty? clauses)\n      `((fn [] (throw (new Error \"No matching pattern\"))))\n      (let (clause (%first clauses)\n            rest-clauses (%rest clauses)\n            clause-kind (if (list? clause)\n                            (if (symbol? (%first clause))\n                                (name (%first clause))\n                                \"unknown\")\n                            \"unknown\"))\n        (cond\n          ((=== clause-kind \"default\")\n           (%nth clause 1))\n\n          ((=== clause-kind \"case\")\n           (let (pattern (%nth clause 1)\n                 ;; Guard detection\n                 has-guard (if (>= (%length clause) 4)\n                               (if (list? (%nth clause 2))\n                                   (if (symbol? (%first (%nth clause 2)))\n                                       (=== (name (%first (%nth clause 2))) \"if\")\n                                       false)\n                                   false)\n                               false)\n                 guard-expr (if has-guard (%nth (%nth clause 2) 1) nil)\n                 result-expr (if has-guard (%nth clause 3) (%nth clause 2))\n                 ;; Pattern classification - single symbol? check, reuse result\n                 pat-name (if (symbol? pattern) (name pattern) nil)\n                 is-wildcard (=== pat-name \"_\")\n                 is-null-pat (=== pat-name \"null\")\n                 is-binding (if pat-name (if is-wildcard false (if is-null-pat false true)) false)\n                 ;; List pattern detection\n                 is-list (if pat-name false (list? pattern))\n                 head-name (if is-list (if (symbol? (%first pattern)) (name (%first pattern)) nil) nil)\n                 is-object (if head-name (if (=== head-name \"hash-map\") true (=== head-name \"__hql_hash_map\")) false)\n                 is-array (if is-list (if is-object false true) false)\n                 ;; Array rest pattern detection\n                 arr-len (if is-array (%length pattern) 0)\n                 has-rest (if (>= arr-len 2)\n                              (if (symbol? (%nth pattern (- arr-len 2)))\n                                  (=== (name (%nth pattern (- arr-len 2))) \"&\")\n                                  false)\n                              false)\n                 check-len (if has-rest (- arr-len 2) arr-len)\n                 ;; Generate condition using runtime helper __hql_match_obj\n                 ;; For object patterns, pass the entire pattern - runtime extracts keys dynamically\n                 ;; No hardcoding of key count - works for ANY number of keys\n                 condition (cond\n                             (is-wildcard true)\n                             (is-binding true)\n                             (is-null-pat `(=== ~val-sym null))\n                             ;; Object pattern: pass pattern to runtime helper\n                             ;; __hql_match_obj(val, pattern) extracts keys from pattern at indices 1,3,5,...\n                             (is-object `(__hql_match_obj ~val-sym (quote ~pattern)))\n                             (is-array (if has-rest\n                                           `(and (Array.isArray ~val-sym)\n                                                 (>= (js-get ~val-sym \"length\") ~check-len))\n                                           `(and (Array.isArray ~val-sym)\n                                                 (=== (js-get ~val-sym \"length\") ~check-len))))\n                             (else `(=== ~val-sym ~pattern)))\n                 ;; Fallback for next clause\n                 fallback `(__match_impl__ ~val-sym ~@rest-clauses)\n                 ;; Generate body - uses IIFE with destructuring param for object/array\n                 ;; This bypasses macro-time let evaluation which doesn't support destructuring\n                 body (cond\n                        ;; Simple symbol binding\n                        (is-binding\n                         (if has-guard\n                             `(let (~pattern ~val-sym) (if ~guard-expr ~result-expr ~fallback))\n                             `(let (~pattern ~val-sym) ~result-expr)))\n                        ;; Destructuring via IIFE - fn param supports destructuring!\n                        (is-object\n                         (if has-guard\n                             `((fn [~pattern] (if ~guard-expr ~result-expr ~fallback)) ~val-sym)\n                             `((fn [~pattern] ~result-expr) ~val-sym)))\n                        (is-array\n                         (if has-guard\n                             `((fn [~pattern] (if ~guard-expr ~result-expr ~fallback)) ~val-sym)\n                             `((fn [~pattern] ~result-expr) ~val-sym)))\n                        ;; No binding (wildcard, null, literal)\n                        (else\n                         (if has-guard `(if ~guard-expr ~result-expr ~fallback) result-expr))))\n             ;; Optimization: skip (if true ...) when condition is always true\n             (if (=== condition true)\n                 body\n                 `(if ~condition ~body ~fallback))))\n\n          (else\n           `((fn [] (throw (new Error \"Invalid match clause\")))))))))\n",
  "@hql/lib/macro/utils.hql": ";; ====================================================\n;; HQL Utility Macros\n;; Common Lisp-style utilities\n;; ====================================================\n\n;; doto: Executes forms with x as first argument, returns x\n;; (doto (new HashMap) (.set \"a\" 1) (.set \"b\" 2))\n(macro doto [x & forms]\n  (let (gx (gensym \"doto\"))\n    `(let (~gx ~x)\n       ~@(map (fn [f]\n                (if (list? f)\n                  (let (head (%first f))\n                    (if (symbol? head)\n                        (let (hname (name head))\n                          (if (=== (js-call hname \"charAt\" 0) \".\")\n                              `(js-call ~gx ~(js-call hname \"substring\" 1) ~@(%rest f))\n                              `(~head ~gx ~@(%rest f))))\n                        `(~head ~gx ~@(%rest f))))\n                  `(~f ~gx)))\n              forms)\n       ~gx)))\n\n;; if-not: Inverse of if\n(macro if-not [test then else]\n  `(if ~test ~else ~then))\n\n;; when-not: Inverse of when\n(macro when-not [test & body]\n  `(if ~test nil (do ~@body)))\n\n;; xor: Logical XOR\n(macro xor [a b]\n  (let (ga (gensym \"xor_a\")\n        gb (gensym \"xor_b\"))\n    `(let (~ga ~a\n           ~gb ~b)\n       (if ~ga (not ~gb) ~gb))))\n\n;; min/max macros expanding to Math functions\n(macro min [& args]\n  `(Math.min ~@args))\n\n(macro max [& args]\n  `(Math.max ~@args))\n",
  "@hql/lib/macro/loop.hql": ";; ====================================================\n;; HQL Loop Constructs Library - Enhanced Version\n;; This library implements a series of looping constructs\n;; built on the fundamental loop/recur mechanism\n;; ====================================================\n;;\n;; IMPORTANT: This is the SOURCE FILE for loop macros.\n;; After editing this file, run: deno task embed-macros\n;; to regenerate core/src/lib/embedded-macros.ts\n;; ====================================================\n\n;; ====================\n;; 1. While Loop\n;; ====================\n\n;; Simple while loop - repeats body as long as condition is true\n(macro while [condition & body]\n  `(loop []\n     (if ~condition\n       (do\n         ~@body\n         (recur))\n       nil)))\n\n;; ====================\n;; 2. Dotimes Loop (Clojure-style fixed iteration)\n;; ====================\n\n;; Simple dotimes loop - executes body a specific number of times\n;; Named after Clojure's dotimes to avoid conflicts with user code\n;; Example usage:\n;; (dotimes 3 (print \"hello\"))\n(macro dotimes [count & body]\n  `(loop [i 0]\n     (if (< i ~count)\n       (do\n         ~@body\n         (recur (+ i 1)))\n       nil)))\n\n;; ====================\n;; 2b. Repeat Loop (alias for dotimes)\n;; ====================\n\n;; repeat loop - executes body a specific number of times\n;; Same as dotimes but with a different name\n;; Example usage:\n;; (repeat 3 (print \"hello\"))\n(macro repeat [count & body]\n  `(loop [__repeat_i 0]\n     (if (< __repeat_i ~count)\n       (do\n         ~@body\n         (recur (+ __repeat_i 1)))\n       nil)))\n\n;; ====================\n;; 3. Enhanced For Loop\n;; ====================\n\n;; for loop - enhanced iteration with multiple syntaxes\n;; Handle [] syntax: (for [x coll]) is parsed as (for (vector x coll))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n(macro for [binding & body]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var (%first normalized-binding)\n          spec (%rest normalized-binding)\n          spec-count (%length spec)\n          first-elem (%first spec))\n    (cond\n      ;; Error: empty spec\n      ;; Error: empty spec\n      ((= spec-count 0)\n       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n\n      ;; Collection iteration: (for (x coll) ...)\n      ((= spec-count 1)\n       `(__hql_for_each ~first-elem\n          (fn [~var]\n            (do\n              ~@body))))\n\n      ;; spec-count is 2 - could be positional OR named \"to:\"\n      ((= spec-count 2)\n       ;; Check if first element is the SYMBOL \"to:\"\n       (if (symbol? first-elem)\n           (if (= (name first-elem) \"to:\")\n               ;; Named form: (for (i to: end) ...)\n               (let (end (%nth spec 1))\n                 `(__hql_for_each (__hql_range 0 ~end)\n                    (fn [~var]\n                      (do\n                        ~@body))))\n               ;; Positional form: (for (i start end) ...)\n               (let (start first-elem\n                     end (%nth spec 1))\n                 `(__hql_for_each (__hql_range ~start ~end)\n                    (fn [~var]\n                      (do\n                        ~@body)))))\n           ;; Positional form: (for (i start end) ...)\n           (let (start first-elem\n                 end (%nth spec 1))\n             `(__hql_for_each (__hql_range ~start ~end)\n                (fn [~var]\n                  (do\n                    ~@body))))))\n\n      ;; spec-count is 3 - could be positional OR named with step\n      ((= spec-count 3)\n       ;; Positional form: (for (i start end step) ...)\n       (let (start first-elem\n             end (%nth spec 1)\n             step (%nth spec 2))\n         `(__hql_for_each (__hql_range ~start ~end ~step)\n            (fn [~var]\n              (do\n                ~@body)))))\n\n      ;; spec-count is 4 - must be named \"to: end by: step\" OR \"from: start to: end\"\n      ((= spec-count 4)\n       (if (symbol? first-elem)\n           (if (= (name first-elem) \"to:\")\n               ;; Named form: (for (i to: end by: step) ...)\n               (if (symbol? (%nth spec 2))\n                   (if (= (name (%nth spec 2)) \"by:\")\n                       (let (end (%nth spec 1)\n                             step (%nth spec 3))\n                         `(__hql_for_each (__hql_range 0 ~end ~step)\n                            (fn [~var]\n                              (do\n                                ~@body))))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n               (if (= (name first-elem) \"from:\")\n                   ;; Named form: (for (i from: start to: end) ...)\n                   (if (symbol? (%nth spec 2))\n                       (if (= (name (%nth spec 2)) \"to:\")\n                           (let (start (%nth spec 1)\n                                 end (%nth spec 3))\n                             `(__hql_for_each (__hql_range ~start ~end)\n                                (fn [~var]\n                                  (do\n                                    ~@body))))\n                           `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n           `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n\n      ;; spec-count is 6 - must be named \"from: start to: end by: step\"\n      ((= spec-count 6)\n       (if (symbol? first-elem)\n           (if (= (name first-elem) \"from:\")\n               (if (symbol? (%nth spec 2))\n                   (if (= (name (%nth spec 2)) \"to:\")\n                       (if (symbol? (%nth spec 4))\n                           (if (= (name (%nth spec 4)) \"by:\")\n                               (let (start (%nth spec 1)\n                                     end (%nth spec 3)\n                                     step (%nth spec 5))\n                                 `(__hql_for_each (__hql_range ~start ~end ~step)\n                                    (fn [~var]\n                                      (do\n                                        ~@body))))\n                               `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                           `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n               `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n           `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n\n      (true `(throw (str \"Invalid 'for' loop binding: \" '~binding))))))\n  )\n",
  "@hql/lib/stdlib/stdlib.hql": ";; lib/stdlib/stdlib.hql - HQL re-exports JavaScript implementation\n;; Note: These functions are auto-loaded by the runtime, so this file is mainly\n;; for documentation and explicit imports in user code.\n;;\n;; IMPORTANT: This must match STDLIB_PUBLIC_API behavior!\n;; - We import rangeGenerator (lazy) and export it as range\n;; - This ensures explicit imports match auto-loaded behavior\n\n;; Import all 51 fundamental functions from modular JS implementation\n(import [\n  ;; Sequence primitives (Lisp Trinity)\n  first, rest, cons,\n\n  ;; Indexed access & counting (Week 1)\n  nth, count, second, last,\n\n  ;; Sequence predicates\n  isEmpty, some,\n\n  ;; Sequence operations\n  take, map, filter, reduce, drop, concat, flatten, distinct,\n\n  ;; Map operations (Week 2)\n  mapIndexed, keepIndexed, mapcat, keep,\n\n  ;; Collection protocols (Week 3)\n  seq, empty, conj, into,\n\n  ;; Lazy constructors (Week 4)\n  repeat, repeatedly, cycle,\n\n  ;; Sequence predicates (Week 5)\n  every, notAny, notEvery, isSome,\n\n  ;; Map/Object operations (Week 6)\n  get, getIn, assoc, assocIn, dissoc, update, updateIn, merge,\n\n  ;; Type conversions (Week 6)\n  vec, set,\n\n  ;; Sequence generators\n  rangeGenerator, iterate,\n\n  ;; Function operations\n  comp, partial, apply,\n\n  ;; Utilities\n  groupBy, keys, doall, realized, lazySeq\n] from \"./js/stdlib.js\")\n\n;; Create alias for range to match runtime behavior\n;; rangeGenerator is imported above, we alias it as \"range\" here\n(let range rangeGenerator)\n\n;; Export all functions (matching STDLIB_PUBLIC_API - 51 total)\n(export [\n  ;; Sequence primitives (Lisp Trinity)\n  first, rest, cons,\n\n  ;; Indexed access & counting (Week 1)\n  nth, count, second, last,\n\n  ;; Sequence predicates\n  isEmpty, some,\n\n  ;; Sequence operations\n  take, map, filter, reduce, drop, concat, flatten, distinct,\n\n  ;; Map operations (Week 2)\n  mapIndexed, keepIndexed, mapcat, keep,\n\n  ;; Collection protocols (Week 3)\n  seq, empty, conj, into,\n\n  ;; Lazy constructors (Week 4)\n  repeat, repeatedly, cycle,\n\n  ;; Sequence predicates (Week 5)\n  every, notAny, notEvery, isSome,\n\n  ;; Map/Object operations (Week 6)\n  get, getIn, assoc, assocIn, dissoc, update, updateIn, merge,\n\n  ;; Type conversions (Week 6)\n  vec, set,\n\n  ;; Sequence generators\n  range, rangeGenerator, iterate,\n\n  ;; Function operations\n  comp, partial, apply,\n\n  ;; Utilities\n  groupBy, keys, doall, realized, lazySeq\n])",
  "@hql/test": "(fn assert [condition message]\n  (if (not condition)\n      (throw (or message \"Assertion failed\"))\n      true))\n\n(fn assert-eq [actual expected message]\n  (if (not (= actual expected))\n      (throw (+ (or message \"Assertion failed\") \" - Expected: \" expected \", Actual: \" actual))\n      true))\n\n(fn assert-throws [fn message]\n  (try\n    (fn)\n    (throw (or message \"Expected function to throw an error, but it didn't\"))\n    (catch e true)))\n\n(export [assert, assert-eq, assert-throws])\n",
  "@hql/date": "(fn now [] (js-call js/Date \"now\"))\n(fn parse [s] (js-call js/Date \"parse\" s))\n(fn format [ts] (.toISOString (new js/Date ts)))\n(fn add [ts ms] (+ ts ms))\n(fn diff [t1 t2] (- t1 t2))\n(export [now, parse, format, add, diff])\n",
  "@hql/math": "(fn abs [n] (js/Math.abs n))\n(fn floor [n] (js/Math.floor n))\n(fn ceil [n] (js/Math.ceil n))\n(fn round [n] (js/Math.round n))\n(fn min [& args] (apply js/Math.min args))\n(fn max [& args] (apply js/Math.max args))\n(fn pow [base exp] (js/Math.pow base exp))\n(fn sqrt [n] (js/Math.sqrt n))\n(export [abs, floor, ceil, round, min, max, pow, sqrt])\n",
  "@hql/http": "(fn request [url options] (js/fetch url options))\n(fn get [url] (js/fetch url))\n(fn post [url body] (js/fetch url {\"method\": \"POST\", \"body\": body}))\n(export [request, get, post])\n",
  "@hql/string": "(fn split [s sep] (.split s sep))\n(fn join [arr sep] (.join arr sep))\n(fn trim [s] (.trim s))\n(fn upper-case [s] (.toUpperCase s))\n(fn lower-case [s] (.toLowerCase s))\n(fn starts-with? [s search] (.startsWith s search))\n(fn ends-with? [s search] (.endsWith s search))\n(fn replace [s search replacement] (.replace s search replacement))\n(export [split, join, trim, upper-case, lower-case, starts-with?, ends-with?, replace])\n",
  "@hql/fs": "(fn read [path] (js/Deno.readTextFile path))\n(fn write [path content] (js/Deno.writeTextFile path content))\n(fn remove [path] (js/Deno.remove path))\n(fn exists? [path] \n  (try \n    (js/Deno.statSync path) \n    true \n    (catch e false)))\n(export [read, write, remove, exists?])\n"
};
