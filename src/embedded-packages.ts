// Auto-generated file with embedded HQL packages
// This file is generated by scripts/embed-packages.ts
// DO NOT EDIT MANUALLY

export const EMBEDDED_PACKAGES: Record<string, string> = {
  "@hql/lib/macro/core.hql": ";; ====================================================\n;; HQL Core Macros Library\n;; ====================================================\n;;\n;; IMPORTANT: This is the SOURCE FILE for core macros.\n;; After editing this file, run: deno task embed-macros\n;; to regenerate core/src/lib/embedded-macros.ts\n;; ====================================================\n\n(macro not [value]\n  `(if ~value false true))\n\n;; Note: list?, symbol?, and name are built-in functions defined in environment.ts\n\n;; Macro versions for user code (generate efficient inline code)\n;; NOTE: first, rest, cons, nth, second, seq are in STDLIB (core.js)\n;; They handle LazySeq properly - DO NOT shadow them with macros!\n\n(macro length [coll]\n  `(if (=== ~coll null)\n       0\n       (js-get ~coll \"length\")))\n\n(macro list [& items]\n  `[~@items])\n\n;; REMOVED: nil? - use isNil instead (camelCase convention)\n;; REMOVED: empty? - use isEmpty from stdlib instead (camelCase convention)\n\n;; ----------------------------------------\n;; JavaScript-Style Type Predicates\n;; ----------------------------------------\n;; These compile to OPTIMAL inline JS - no IIFEs, no function calls.\n;; Uses JS loose equality (==) for nullish checks: x == null is true for both null AND undefined.\n\n;; Null/Undefined checks - use JS loose equality for efficiency\n(macro isNull [x]\n  `(=== ~x null))\n\n(macro isUndefined [x]\n  `(=== ~x undefined))\n\n(macro isNil [x]\n  `(== ~x null))              ;; JS: x == null catches both null and undefined\n\n(macro isDefined [x]\n  `(!== ~x undefined))        ;; Direct !== check\n\n(macro notNil [x]\n  `(!= ~x null))              ;; JS: x != null is true when x is neither null nor undefined\n\n;; Type checks - compile to inline typeof checks\n(macro isString [x]\n  `(=== (typeof ~x) \"string\"))\n\n(macro isNumber [x]\n  `(=== (typeof ~x) \"number\"))\n\n(macro isBoolean [x]\n  `(=== (typeof ~x) \"boolean\"))\n\n(macro isFunction [x]\n  `(=== (typeof ~x) \"function\"))\n\n(macro isSymbol [x]\n  `(=== (typeof ~x) \"symbol\"))\n\n;; Object/Array checks - use && for direct JS output\n(macro isArray [x]\n  `(Array.isArray ~x))\n\n(macro isObject [x]\n  `(&& (&& (=== (typeof ~x) \"object\")\n           (!== ~x null))\n       (! (Array.isArray ~x))))\n\n;; Numeric predicates: isEven, isOdd, isZero, isPositive, isNegative\n;; These are FUNCTIONS in stdlib (core.js), not macros.\n;; Functions can be passed to higher-order functions like filter/map.\n\n;; ----------------------------------------\n;; camelCase Aliases for Lisp-Style Macros\n;; ----------------------------------------\n;; Pure aliases - expand to the kebab-case versions.\n\n(macro ifLet [binding then-expr else-expr]\n  `(if-let ~binding ~then-expr ~else-expr))\n\n(macro whenLet [binding & body]\n  `(when-let ~binding ~@body))\n\n(macro or [& args]\n  (cond\n    ((%empty? args) false)\n    ((=== (%length args) 1) (%first args))\n    (true `(|| ~(%first args) (or ~@(%rest args))))))\n\n(macro and [& args]\n  (cond\n    ((%empty? args) true)\n    ((=== (%length args) 1) (%first args))\n    (true `(&& ~(%first args) (and ~@(%rest args))))))\n\n(macro when [test & body]\n  `(if ~test\n       (do ~@body)\n       nil))\n\n;; Handle [] syntax: (when-let [x val]) is parsed as (when-let (vector x val))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n(macro when-let [binding & body]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var-name (%first normalized-binding)\n          var-value (%nth normalized-binding 1))\n      `((fn [~var-name]\n           (when ~var-name\n               ~@body))\n         ~var-value))))\n\n(macro unless [test & body]\n  `(if ~test\n       nil\n       (do ~@body)))\n\n(macro inc [x]\n  `(+ ~x 1))\n\n(macro dec [x]\n  `(- ~x 1))\n\n(macro print [& args]\n  `(console.log ~@args))\n\n;; NOTE: cons is in STDLIB - handles LazySeq properly\n\n(macro set [target value]\n  `(= ~target ~value))\n\n(macro str [& args]\n  (cond\n    ((%empty? args) `\"\")\n    ((=== (%length args) 1) `(+ \"\" ~(%first args)))\n    (true `(+ ~@args))))\n\n(macro contains [coll key]\n  `(js-call ~coll \"has\" ~key))\n\n;; NOTE: nth is in STDLIB - handles LazySeq properly\n\n;; Handle [] syntax: (if-let [x val]) is parsed as (if-let (vector x val))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n(macro if-let [binding then-expr else-expr]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var-name (%first normalized-binding)\n          var-value (%nth normalized-binding 1))\n      `((fn [~var-name]\n           (if ~var-name\n               ~then-expr\n               ~else-expr))\n         ~var-value))))\n\n;; NOTE: second is in STDLIB - handles LazySeq properly\n\n(macro hasElements [coll]\n  `(> (length ~coll) 0))\n\n(macro isEmptyList [coll]\n  `(=== (length ~coll) 0))\n\n;; NOTE: seq is in STDLIB - handles LazySeq properly\n\n(macro empty-array []\n  `(vector))\n\n;; NOTE: `throw` is a kernel primitive, not a macro\n;; It needs to create ThrowStatement IR node for exception handling\n\n;; method-call is syntactic sugar over js-call\n(macro method-call [obj method & args]\n  `(js-call ~obj ~method ~@args))\n\n(macro hash-map [& items]\n  `(__hql_hash_map ~@items))\n\n(macro empty-map []\n  `(hash-map))\n\n(macro empty-set []\n  `(hash-set))\n\n;; ----------------------------------------\n;; Core control flow\n;; ----------------------------------------\n\n(macro cond [& clauses]\n  (if (%empty? clauses)\n      nil\n      (let (first-clause (%first clauses)\n            rest-clauses (%rest clauses)\n            first-el (%first first-clause))\n        ;; Check if first clause is a list (e.g., (else expr))\n        ;; If we can extract a first element, it's a list\n        (if (=== first-el nil)\n            ;; Flat syntax: test result test result...\n            (if (%empty? rest-clauses)\n                (throw \"cond requires result expression for test\")\n                (let (test first-clause\n                      result (%first rest-clauses)\n                      remaining (%rest rest-clauses))\n                  (if (%empty? remaining)\n                      `(if ~test ~result nil)\n                      `(if ~test ~result (cond ~@remaining)))))\n            ;; List clause syntax: ((test) result)\n            (let (test first-el\n                  result (%first (%rest first-clause)))\n              ;; Check if test is the symbol 'else' - if so, return result directly\n              (if (symbol? test)\n                  (if (=== (name test) \"else\")\n                      result\n                      ;; Otherwise generate if expression\n                      (if (%empty? rest-clauses)\n                          `(if ~test ~result nil)\n                          `(if ~test ~result (cond ~@rest-clauses))))\n                  ;; test is not a symbol, generate if expression\n                  (if (%empty? rest-clauses)\n                      `(if ~test ~result nil)\n                      `(if ~test ~result (cond ~@rest-clauses)))))))))\n\n;; NOTE: `do` is a kernel primitive, not a macro\n;; It needs to create an IIFE with BlockStatement to handle both statements and expressions\n;; A macro version using nested `let` can only handle expressions, fails with `var`/statements\n\n;; ----------------------------------------\n;; Threading Macros (Clojure-compatible)\n;; ----------------------------------------\n;; These are compile-time transformations with ZERO runtime overhead.\n;; They transform nested function calls into readable linear pipelines.\n\n;; Thread-first: inserts x as FIRST argument of each form\n;; (-> x (f a) (g b)) => (g (f x a) b)\n;; (-> x f g) => (g (f x))\n(macro -> [x & forms]\n  (if (%empty? forms)\n    x\n    (let (form (%first forms)\n          rest-forms (%rest forms)\n          threaded (if (list? form)\n                     ;; Form is a list like (f a b), insert x as first arg: (f x a b)\n                     `(~(%first form) ~x ~@(%rest form))\n                     ;; Form is a symbol like f, make it (f x)\n                     `(~form ~x)))\n      `(-> ~threaded ~@rest-forms))))\n\n;; Thread-last: inserts x as LAST argument of each form\n;; (->> x (f a) (g b)) => (g b (f a x))\n;; (->> x f g) => (g (f x))\n(macro ->> [x & forms]\n  (if (%empty? forms)\n    x\n    (let (form (%first forms)\n          rest-forms (%rest forms)\n          threaded (if (list? form)\n                     ;; Form is a list like (f a b), insert x as last arg: (f a b x)\n                     `(~@form ~x)\n                     ;; Form is a symbol like f, make it (f x)\n                     `(~form ~x)))\n      `(->> ~threaded ~@rest-forms))))\n\n;; Thread-as: binds x to a symbol for arbitrary placement\n;; (as-> 2 x (+ x 1) (* x 3)) => ((fn [x] (* x 3)) ((fn [x] (+ x 1)) 2))\n;; Each form is wrapped in a function that binds the name, avoiding rebinding issues\n(macro as-> [expr name & forms]\n  (if (%empty? forms)\n    expr\n    (let (first-form (%first forms)\n          rest-forms (%rest forms))\n      `((fn [~name] (as-> ~first-form ~name ~@rest-forms))\n        ~expr))))\n\n;; ----------------------------------------\n;; Pattern Matching (Swift/Scala-style syntax)\n;; ----------------------------------------\n;; Syntax:\n;;   (match value\n;;     (case pattern result)\n;;     (case pattern (if guard) result)\n;;     (default result))\n;;\n;; Supported patterns:\n;;   - Literals: 42, \"hello\", true, null\n;;   - Wildcard: _ (matches anything, no binding)\n;;   - Symbol: x (matches anything, binds to x)\n;;   - Array: [a, b], [], [h, & t] (rest pattern)\n;;   - Object: {name, age}, {name: n, age: a}\n;;\n;; Guards: (if condition) checked AFTER pattern binding\n;;\n;; Implementation: Uses IIFE with JS destructuring for object/array patterns.\n;; This avoids macro-time let evaluation issues.\n;; Time complexity: O(n) where n = number of clauses (optimal for sequential matching)\n\n\n;; Main match macro - binds value once, dispatches to implementation\n;; Uses auto-gensym (val#) for hygiene - Clojure-style syntax\n(macro match [value & clauses]\n  `(let (val# ~value)\n     (__match_impl__ val# ~@clauses)))\n\n;; Implementation macro - processes clauses recursively\n(macro __match_impl__ [val-sym & clauses]\n  (if (%empty? clauses)\n      `((fn [] (throw (new Error \"No matching pattern\"))))\n      (let (clause (%first clauses)\n            rest-clauses (%rest clauses)\n            clause-kind (if (list? clause)\n                            (if (symbol? (%first clause))\n                                (name (%first clause))\n                                \"unknown\")\n                            \"unknown\"))\n        (cond\n          ((=== clause-kind \"default\")\n           (%nth clause 1))\n\n          ((=== clause-kind \"case\")\n           (let (pattern (%nth clause 1)\n                 ;; Guard detection\n                 has-guard (if (>= (%length clause) 4)\n                               (if (list? (%nth clause 2))\n                                   (if (symbol? (%first (%nth clause 2)))\n                                       (=== (name (%first (%nth clause 2))) \"if\")\n                                       false)\n                                   false)\n                               false)\n                 guard-expr (if has-guard (%nth (%nth clause 2) 1) nil)\n                 result-expr (if has-guard (%nth clause 3) (%nth clause 2))\n                 ;; Pattern classification - single symbol? check, reuse result\n                 pat-name (if (symbol? pattern) (name pattern) nil)\n                 is-wildcard (=== pat-name \"_\")\n                 is-null-pat (=== pat-name \"null\")\n                 is-binding (if pat-name (if is-wildcard false (if is-null-pat false true)) false)\n                 ;; List pattern detection\n                 is-list (if pat-name false (list? pattern))\n                 head-name (if is-list (if (symbol? (%first pattern)) (name (%first pattern)) nil) nil)\n                 is-object (if head-name (if (=== head-name \"hash-map\") true (=== head-name \"__hql_hash_map\")) false)\n                 is-array (if is-list (if is-object false true) false)\n                 ;; Array rest pattern detection\n                 arr-len (if is-array (%length pattern) 0)\n                 has-rest (if (>= arr-len 2)\n                              (if (symbol? (%nth pattern (- arr-len 2)))\n                                  (=== (name (%nth pattern (- arr-len 2))) \"&\")\n                                  false)\n                              false)\n                 check-len (if has-rest (- arr-len 2) arr-len)\n                 ;; Generate condition using runtime helper __hql_match_obj\n                 ;; For object patterns, pass the entire pattern - runtime extracts keys dynamically\n                 ;; No hardcoding of key count - works for ANY number of keys\n                 condition (cond\n                             (is-wildcard true)\n                             (is-binding true)\n                             (is-null-pat `(=== ~val-sym null))\n                             ;; Object pattern: pass pattern to runtime helper\n                             ;; __hql_match_obj(val, pattern) extracts keys from pattern at indices 1,3,5,...\n                             (is-object `(__hql_match_obj ~val-sym (quote ~pattern)))\n                             (is-array (if has-rest\n                                           `(and (Array.isArray ~val-sym)\n                                                 (>= (js-get ~val-sym \"length\") ~check-len))\n                                           `(and (Array.isArray ~val-sym)\n                                                 (=== (js-get ~val-sym \"length\") ~check-len))))\n                             (else `(=== ~val-sym ~pattern)))\n                 ;; Fallback for next clause\n                 fallback `(__match_impl__ ~val-sym ~@rest-clauses)\n                 ;; Generate body - uses IIFE with destructuring param for object/array\n                 ;; This bypasses macro-time let evaluation which doesn't support destructuring\n                 body (cond\n                        ;; Simple symbol binding\n                        (is-binding\n                         (if has-guard\n                             `(let (~pattern ~val-sym) (if ~guard-expr ~result-expr ~fallback))\n                             `(let (~pattern ~val-sym) ~result-expr)))\n                        ;; Destructuring via IIFE - fn param supports destructuring!\n                        (is-object\n                         (if has-guard\n                             `((fn [~pattern] (if ~guard-expr ~result-expr ~fallback)) ~val-sym)\n                             `((fn [~pattern] ~result-expr) ~val-sym)))\n                        (is-array\n                         (if has-guard\n                             `((fn [~pattern] (if ~guard-expr ~result-expr ~fallback)) ~val-sym)\n                             `((fn [~pattern] ~result-expr) ~val-sym)))\n                        ;; No binding (wildcard, null, literal)\n                        (else\n                         (if has-guard `(if ~guard-expr ~result-expr ~fallback) result-expr))))\n             ;; Optimization: skip (if true ...) when condition is always true\n             (if (=== condition true)\n                 body\n                 `(if ~condition ~body ~fallback))))\n\n          (else\n           `((fn [] (throw (new Error \"Invalid match clause\")))))))))\n",
  "@hql/lib/macro/utils.hql": ";; ====================================================\n;; HQL Utility Macros\n;; Common Lisp-style utilities\n;; ====================================================\n\n;; doto: Executes forms with x as first argument, returns x\n;; (doto (new HashMap) (.set \"a\" 1) (.set \"b\" 2))\n(macro doto [x & forms]\n  (let (gx (gensym \"doto\"))\n    `(let (~gx ~x)\n       ~@(map (fn [f]\n                (if (list? f)\n                  (let (head (%first f))\n                    (if (symbol? head)\n                        (let (hname (name head))\n                          (if (=== (js-call hname \"charAt\" 0) \".\")\n                              `(js-call ~gx ~(js-call hname \"substring\" 1) ~@(%rest f))\n                              `(~head ~gx ~@(%rest f))))\n                        `(~head ~gx ~@(%rest f))))\n                  `(~f ~gx)))\n              forms)\n       ~gx)))\n\n;; if-not: Inverse of if\n(macro if-not [test then else]\n  `(if ~test ~else ~then))\n\n;; when-not: Inverse of when\n(macro when-not [test & body]\n  `(if ~test nil (do ~@body)))\n\n;; xor: Logical XOR\n(macro xor [a b]\n  (let (ga (gensym \"xor_a\")\n        gb (gensym \"xor_b\"))\n    `(let (~ga ~a\n           ~gb ~b)\n       (if ~ga (not ~gb) ~gb))))\n\n;; min/max macros expanding to Math functions\n(macro min [& args]\n  `(Math.min ~@args))\n\n(macro max [& args]\n  `(Math.max ~@args))\n\n;; with-gensyms: Hygiene helper for macro writers\n;; Binds each name to a unique gensym for safe macro expansion.\n;;\n;; Usage:\n;;   (macro my-swap [a b]\n;;     (with-gensyms [tmp]\n;;       `(let (~tmp ~a)\n;;          (set! ~a ~b)\n;;          (set! ~b ~tmp))))\n;;\n;; Each name in the vector gets bound to (gensym \"name\"), making the\n;; macro hygienic by avoiding variable capture.\n(macro with-gensyms [names & body]\n  `(let ~(apply vector\n           (apply concat\n             (map (fn [n]\n                    [n `(gensym ~(if (symbol? n) (name n) \"g\"))])\n                  names)))\n     ~@body))\n",
  "@hql/lib/macro/loop.hql": ";; ====================================================\n;; HQL Loop Constructs Library - Enhanced Version\n;; This library implements a series of looping constructs\n;; built on the fundamental loop/recur mechanism\n;; ====================================================\n;;\n;; IMPORTANT: This is the SOURCE FILE for loop macros.\n;; After editing this file, run: deno task embed-macros\n;; to regenerate core/src/lib/embedded-macros.ts\n;; ====================================================\n\n;; ====================\n;; 1. While Loop\n;; ====================\n\n;; Simple while loop - repeats body as long as condition is true\n(macro while [condition & body]\n  `(loop []\n     (if ~condition\n       (do\n         ~@body\n         (recur))\n       nil)))\n\n;; ====================\n;; 2. Dotimes Loop (Clojure-style fixed iteration)\n;; ====================\n\n;; Simple dotimes loop - executes body a specific number of times\n;; Named after Clojure's dotimes to avoid conflicts with user code\n;; Example usage:\n;; (dotimes 3 (print \"hello\"))\n(macro dotimes [count & body]\n  `(loop [i 0]\n     (if (< i ~count)\n       (do\n         ~@body\n         (recur (+ i 1)))\n       nil)))\n\n;; ====================\n;; 2b. Repeat Loop (alias for dotimes)\n;; ====================\n\n;; repeat loop - executes body a specific number of times\n;; Same as dotimes but with a different name\n;; Example usage:\n;; (repeat 3 (print \"hello\"))\n(macro repeat [count & body]\n  `(loop [__repeat_i 0]\n     (if (< __repeat_i ~count)\n       (do\n         ~@body\n         (recur (+ __repeat_i 1)))\n       nil)))\n\n;; ====================\n;; 3. Enhanced For Loop\n;; ====================\n\n;; for loop - enhanced iteration with multiple syntaxes\n;; Handle [] syntax: (for [x coll]) is parsed as (for (vector x coll))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n;;\n;; IMPORTANT: Uses for-of internally (not __hql_for_each with callback)\n;; so that return/break/continue work correctly from the enclosing function.\n(macro for [binding & body]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var (%first normalized-binding)\n          spec (%rest normalized-binding)\n          spec-count (%length spec)\n          first-elem (%first spec))\n    (cond\n      ;; Error: empty spec\n      ((=== spec-count 0)\n       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n\n      ;; Collection/count iteration: (for (x coll) ...) or (for (i n) ...)\n      ;; Uses for-of with __hql_toIterable to handle both collections and numbers\n      ;; Numbers are converted to range(0, n) at runtime\n      ((=== spec-count 1)\n       `(for-of [~var (__hql_toIterable ~first-elem)]\n          ~@body))\n\n      ;; spec-count is 2 - could be positional OR named \"to:\"\n      ((=== spec-count 2)\n       ;; Check if first element is the SYMBOL \"to:\"\n       (if (symbol? first-elem)\n           (if (=== (name first-elem) \"to:\")\n               ;; Named form: (for (i to: end) ...)\n               (let (end (%nth spec 1))\n                 `(for-of [~var (__hql_range 0 ~end)]\n                    ~@body))\n               ;; Positional form: (for (i start end) ...)\n               (let (start first-elem\n                     end (%nth spec 1))\n                 `(for-of [~var (__hql_range ~start ~end)]\n                    ~@body)))\n           ;; Positional form: (for (i start end) ...)\n           (let (start first-elem\n                 end (%nth spec 1))\n             `(for-of [~var (__hql_range ~start ~end)]\n                ~@body))))\n\n      ;; spec-count is 3 - could be positional OR named with step\n      ((=== spec-count 3)\n       ;; Positional form: (for (i start end step) ...)\n       (let (start first-elem\n             end (%nth spec 1)\n             step (%nth spec 2))\n         `(for-of [~var (__hql_range ~start ~end ~step)]\n            ~@body)))\n\n      ;; spec-count is 4 - must be named \"to: end by: step\" OR \"from: start to: end\"\n      ((=== spec-count 4)\n       (if (symbol? first-elem)\n           (if (=== (name first-elem) \"to:\")\n               ;; Named form: (for (i to: end by: step) ...)\n               (if (symbol? (%nth spec 2))\n                   (if (=== (name (%nth spec 2)) \"by:\")\n                       (let (end (%nth spec 1)\n                             step (%nth spec 3))\n                         `(for-of [~var (__hql_range 0 ~end ~step)]\n                            ~@body))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n               (if (=== (name first-elem) \"from:\")\n                   ;; Named form: (for (i from: start to: end) ...)\n                   (if (symbol? (%nth spec 2))\n                       (if (=== (name (%nth spec 2)) \"to:\")\n                           (let (start (%nth spec 1)\n                                 end (%nth spec 3))\n                             `(for-of [~var (__hql_range ~start ~end)]\n                                ~@body))\n                           `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n           `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n\n      ;; spec-count is 6 - must be named \"from: start to: end by: step\"\n      ((=== spec-count 6)\n       (if (symbol? first-elem)\n           (if (=== (name first-elem) \"from:\")\n               (if (symbol? (%nth spec 2))\n                   (if (=== (name (%nth spec 2)) \"to:\")\n                       (if (symbol? (%nth spec 4))\n                           (if (=== (name (%nth spec 4)) \"by:\")\n                               (let (start (%nth spec 1)\n                                     end (%nth spec 3)\n                                     step (%nth spec 5))\n                                 `(for-of [~var (__hql_range ~start ~end ~step)]\n                                    ~@body))\n                               `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                           `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n               `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n           `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n\n      (true `(throw (str \"Invalid 'for' loop binding: \" '~binding))))))\n  )\n",
  "@hql/lib/stdlib/stdlib.hql": ";; lib/stdlib/stdlib.hql - HQL stdlib with self-hosted functions\n;;\n;; SELF-HOSTED FUNCTIONS:\n;; Phase 1 - Core Sequence Operations:\n;; - take: Returns first n elements from a collection (lazy)\n;; - drop: Drops first n elements from a collection (lazy)\n;; - map: Maps function over collection (lazy)\n;; - filter: Filters collection by predicate (lazy)\n;; - reduce: Reduces collection with function and initial value (EAGER)\n;; - concat: Concatenates multiple collections (lazy)\n;; - flatten: Flattens nested collections (lazy)\n;; - distinct: Removes duplicate elements (lazy)\n;;\n;; Phase 2 - Indexed Operations:\n;; - next: Returns seq of rest, or nil if empty (same as (seq (rest coll)))\n;; - second: Returns second element (same as (nth coll 1 nil))\n;; - nth: Returns element at index with optional not-found\n;; - count: Returns count of elements (EAGER)\n;; - last: Returns last element (EAGER)\n;;\n;; Phase 3 - Map Operations:\n;; - mapIndexed: Maps (index, item) over collection (lazy)\n;; - keepIndexed: Like mapIndexed but filters nil results (lazy)\n;; - mapcat: Maps then flattens one level (lazy)\n;; - keep: Maps and filters nil results (lazy)\n;;\n;; The self-hosted approach:\n;; - Import primitive functions from JS (first, rest, cons, seq, lazy-seq)\n;; - Build higher-level functions in HQL using those primitives\n;; - This is TRUE self-hosting: HQL code that gets transpiled\n\n;; Import primitive functions from JavaScript (the foundation)\n(import [\n  ;; Sequence primitives (Lisp Trinity) - these are the foundation\n  first, rest, cons, seq,\n\n  ;; NOTE: nth, count, second, last, next are NOW SELF-HOSTED BELOW!\n\n  ;; Sequence predicates\n  isEmpty, some,\n\n  ;; Sequence operations (NOT take/drop/map/filter/reduce/concat/flatten/distinct - those are self-hosted below!)\n\n  ;; NOTE: mapIndexed, keepIndexed, mapcat, keep are NOW SELF-HOSTED BELOW!\n\n  ;; Collection protocols (Week 3)\n  seq, empty, conj, into,\n\n  ;; Lazy constructors (Week 4)\n  repeat, repeatedly, cycle,\n\n  ;; Sequence predicates (Week 5)\n  every, notAny, notEvery, isSome,\n\n  ;; Map/Object operations (Week 6)\n  get, getIn, assoc, assocIn, dissoc, update, updateIn, merge,\n\n  ;; Type conversions (Week 6)\n  vec, set,\n\n  ;; Sequence generators\n  rangeGenerator, iterate,\n\n  ;; Function operations\n  comp, partial, apply,\n\n  ;; Utilities\n  groupBy, keys, doall, realized, lazySeq,\n\n  ;; Delay/Force primitives (explicit laziness)\n  force, isDelay\n] from \"./js/stdlib.js\")\n\n;; Create alias for range to match runtime behavior\n(let range rangeGenerator)\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; SELF-HOSTED STDLIB FUNCTIONS\n;; These are implemented in HQL, not JavaScript!\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; take - Returns first n elements from a collection (lazy)\n;; This is TRUE self-hosted HQL code using lazy-seq foundation\n(fn take [n coll]\n  (lazy-seq\n    (when (> n 0)\n      (when-let [s (seq coll)]\n        (cons (first s) (take (- n 1) (rest s)))))))\n\n;; drop - Drops first n elements from a collection (lazy)\n;; Returns remaining elements after skipping n\n;; Note: Uses iterative skip + cons to ensure seq-protocol compatibility\n(fn drop [n coll]\n  (lazy-seq\n    (loop [s (seq coll) remaining n]\n      (if (and s (> remaining 0))\n        (recur (rest s) (- remaining 1))\n        (when s\n          (cons (first s) (drop 0 (rest s))))))))\n\n;; map - Maps function over collection (lazy)\n;; This is the heart of functional programming\n;; Pattern: (lazy-seq (when-let [s (seq coll)] (cons (f (first s)) (map f (rest s)))))\n(fn map [f coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (cons (f (first s)) (map f (rest s))))))\n\n;; filter - Filters collection by predicate (lazy)\n;; Only includes elements where (pred elem) is truthy\n;; Pattern: skip non-matching elements recursively until we find one\n(fn filter [pred coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [f (first s)]\n        (if (pred f)\n          (cons f (filter pred (rest s)))\n          (filter pred (rest s)))))))\n\n;; reduce - Reduces collection with function and initial value (EAGER)\n;; This is the foundation of many aggregate operations\n;; Unlike map/filter, reduce consumes the entire collection\n(fn reduce [f init coll]\n  (loop [acc init, s (seq coll)]\n    (if s\n      (recur (f acc (first s)) (rest s))\n      acc)))\n\n;; concat - Concatenates multiple collections (lazy)\n;; Variadic function: (concat [1 2] [3 4]) => (1 2 3 4)\n;; Processes collections one element at a time\n(fn concat [& colls]\n  (lazy-seq\n    (when-let [cs (seq colls)]\n      (if-let [s (seq (first cs))]\n        (cons (first s) (apply concat (cons (rest s) (rest cs))))\n        (apply concat (rest cs))))))\n\n;; flatten - Flattens nested collections (lazy)\n;; Recursively flattens all iterable items (except strings)\n;; Note: Uses JS interop for iterable checking in pre-transpiled version\n(fn flatten [coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [f (first s)]\n        (if (coll? f)  ;; coll? checks for collections (arrays, seqs) but not strings\n          (concat (flatten f) (flatten (rest s)))\n          (cons f (flatten (rest s))))))))\n\n;; distinct - Removes duplicate elements (lazy)\n;; Uses a Set to track seen elements efficiently\n;; Note: Pre-transpiled version uses JS Set for O(1) lookup\n(fn distinct [coll]\n  (let [step (fn [s seen]\n               (lazy-seq\n                 (when-let [xs (seq s)]\n                   (let [f (first xs)]\n                     (if (contains? seen f)\n                       (step (rest xs) seen)\n                       (cons f (step (rest xs) (conj seen f))))))))]\n    (step coll #{})))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 2: INDEXED OPERATIONS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; next - Returns (seq (rest coll)), nil if rest is empty\n;; This is the Clojure-style \"next\" that differs from \"rest\"\n;; next returns nil for empty, rest returns empty seq\n(fn next [coll]\n  (seq (rest coll)))\n\n;; nth - Returns element at index, with optional not-found value\n;; Uses loop to iterate to the index position\n;; Throws error if out of bounds and no not-found provided\n;; Note: Uses (seq args) instead of (count args) to avoid circular dependency\n(fn nth [coll index & args]\n  (let [not-found (first args)\n        has-not-found (seq args)]  ;; truthy if args is non-empty\n    (if (nil? coll)\n      (if has-not-found\n        not-found\n        (throw (js/Error (str \"nth: index \" index \" out of bounds for null collection\"))))\n      (loop [s (seq coll), i 0]\n        (if s\n          (if (=== i index)\n            (first s)\n            (recur (rest s) (+ i 1)))\n          (if has-not-found\n            not-found\n            (throw (js/Error (str \"nth: index \" index \" out of bounds\")))))))))\n\n;; second - Returns second element of collection\n;; Simply (nth coll 1 nil) - returns nil if less than 2 elements\n(fn second [coll]\n  (nth coll 1 nil))\n\n;; count - Returns count of elements (EAGER)\n;; Forces full realization of lazy sequences\n(fn count [coll]\n  (if (nil? coll)\n    0\n    (loop [s (seq coll), n 0]\n      (if s\n        (recur (rest s) (+ n 1))\n        n))))\n\n;; last - Returns last element (EAGER)\n;; Forces full realization to find the last element\n(fn last [coll]\n  (if (nil? coll)\n    nil\n    (loop [s (seq coll), result nil]\n      (if s\n        (recur (rest s) (first s))\n        result))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 3: MAP OPERATIONS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; mapIndexed - Maps function (index, item) over collection (lazy)\n;; Like map but the function receives (index, item) instead of just (item)\n(fn mapIndexed [f coll]\n  (let [step (fn [s idx]\n               (lazy-seq\n                 (when-let [xs (seq s)]\n                   (cons (f idx (first xs))\n                         (step (rest xs) (+ idx 1))))))]\n    (step coll 0)))\n\n;; keepIndexed - Like mapIndexed but filters nil results (lazy)\n;; Only keeps results where (f index item) is not nil/undefined\n(fn keepIndexed [f coll]\n  (let [step (fn [s idx]\n               (lazy-seq\n                 (when-let [xs (seq s)]\n                   (let [result (f idx (first xs))]\n                     (if (some? result)\n                       (cons result (step (rest xs) (+ idx 1)))\n                       (step (rest xs) (+ idx 1)))))))]\n    (step coll 0)))\n\n;; mapcat - Maps function then concatenates/flattens one level (lazy)\n;; Equivalent to (apply concat (map f coll))\n(fn mapcat [f coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (concat (f (first s)) (mapcat f (rest s))))))\n\n;; keep - Maps function and filters nil results (lazy)\n;; Only keeps results where (f item) is not nil/undefined\n(fn keep [f coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [result (f (first s))]\n        (if (some? result)\n          (cons result (keep f (rest s)))\n          (keep f (rest s)))))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 3B: CONDITIONAL LAZY FUNCTIONS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; takeWhile - Returns elements while predicate is true (lazy)\n;; Clojure: (take-while pos? [1 2 3 0 -1]) => (1 2 3)\n(fn takeWhile [pred coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [f (first s)]\n        (when (pred f)\n          (cons f (takeWhile pred (rest s))))))))\n\n;; dropWhile - Drops elements while predicate is true (lazy)\n;; Clojure: (drop-while pos? [1 2 3 0 -1 2]) => (0 -1 2)\n(fn dropWhile [pred coll]\n  (lazy-seq\n    (loop [s (seq coll)]\n      (if (and s (pred (first s)))\n        (recur (rest s))\n        (when s\n          (cons (first s) (rest s)))))))\n\n;; splitWith - Returns [(takeWhile pred coll) (dropWhile pred coll)]\n(fn splitWith [pred coll]\n  [(doall (takeWhile pred coll)) (doall (dropWhile pred coll))])\n\n;; splitAt - Returns [(take n coll) (drop n coll)]\n(fn splitAt [n coll]\n  [(doall (take n coll)) (doall (drop n coll))])\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 3C: REDUCTION VARIANTS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; reductions - Returns lazy seq of intermediate reduce values\n;; Clojure: (reductions + [1 2 3 4]) => (1 3 6 10)\n;; Clojure: (reductions + 0 [1 2 3]) => (0 1 3 6)\n(fn reductions [f & args]\n  (let [reductions-with-init\n        (fn reductions-with-init [f init coll]\n          (cons init\n                (lazy-seq\n                  (when-let [s (seq coll)]\n                    (reductions-with-init f (f init (first s)) (rest s))))))]\n    (if (=== (count args) 1)\n      ;; 2-arity: (reductions f coll)\n      (let [coll (first args)]\n        (lazy-seq\n          (when-let [s (seq coll)]\n            (reductions-with-init f (first s) (rest s)))))\n      ;; 3-arity: (reductions f init coll)\n      (reductions-with-init f (first args) (second args)))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 3D: SEQUENCE COMBINATORS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; interpose - Inserts separator between elements (lazy)\n;; Clojure: (interpose :x [1 2 3]) => (1 :x 2 :x 3)\n(fn interpose [sep coll]\n  (let [interpose-rest\n        (fn interpose-rest [sep coll]\n          (lazy-seq\n            (when-let [s (seq coll)]\n              (cons sep (cons (first s) (interpose-rest sep (rest s)))))))]\n    (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (first s) (interpose-rest sep (rest s)))))))\n\n;; interleave - Interleaves multiple sequences (lazy)\n;; Clojure: (interleave [1 2 3] [:a :b :c]) => (1 :a 2 :b 3 :c)\n(fn interleave [& colls]\n  (lazy-seq\n    (let [seqs (map seq colls)]\n      (when (every some? seqs)\n        (concat (map first seqs)\n                (apply interleave (map rest seqs)))))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 3E: PARTITION FAMILY\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; partition - Partitions into groups of n, drops incomplete (lazy)\n;; 2-arity: (partition n coll) - step defaults to n\n;; 3-arity: (partition n step coll) - explicit step\n;; Clojure: (partition 3 [1 2 3 4 5 6 7]) => ((1 2 3) (4 5 6))\n(fn partition [n & args]\n  (let [arg-count (count args)\n        step (if (=== arg-count 1) n (first args))\n        coll (if (=== arg-count 1) (first args) (second args))]\n    (lazy-seq\n      (when-let [s (seq coll)]\n        (let [p (doall (take n s))]\n          (when (=== (count p) n)\n            (cons p (partition n step (drop step s)))))))))\n\n;; partitionAll - Like partition but includes incomplete final group (lazy)\n;; Clojure: (partition-all 3 [1 2 3 4 5 6 7]) => ((1 2 3) (4 5 6) (7))\n(fn partitionAll [n & args]\n  (let [arg-count (count args)\n        step (if (=== arg-count 1) n (first args))\n        coll (if (=== arg-count 1) (first args) (second args))]\n    (lazy-seq\n      (when-let [s (seq coll)]\n        (let [p (doall (take n s))]\n          (cons p (partitionAll n step (drop step s))))))))\n\n;; partitionBy - Partitions when function result changes (lazy)\n;; Clojure: (partition-by odd? [1 1 2 2 3]) => ((1 1) (2 2) (3))\n(fn partitionBy [f coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [fst (first s)\n            fv (f fst)\n            run (doall (cons fst (takeWhile (fn [x] (=== (f x) fv)) (rest s))))]\n        (cons run (partitionBy f (drop (count run) s)))))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 4: PREDICATES\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; isEmpty - Tests if collection is empty\n;; Returns true if nil or empty, false otherwise\n(fn isEmpty [coll]\n  (nil? (seq coll)))\n\n;; some - Returns first item where predicate returns truthy, or nil\n;; Short-circuits on first match\n(fn some [pred coll]\n  (loop [s (seq coll)]\n    (if s\n      (if (pred (first s))\n        (first s)\n        (recur (rest s)))\n      nil)))\n\n;; every - Returns true if predicate returns truthy for all items\n;; Short-circuits on first falsy, empty collection returns true (vacuous truth)\n(fn every [pred coll]\n  (loop [s (seq coll)]\n    (if s\n      (if (pred (first s))\n        (recur (rest s))\n        false)\n      true)))\n\n;; notAny - Returns true if predicate returns false for all items\n;; Equivalent to (not (some pred coll))\n(fn notAny [pred coll]\n  (loop [s (seq coll)]\n    (if s\n      (if (pred (first s))\n        false\n        (recur (rest s)))\n      true)))\n\n;; notEvery - Returns true if predicate returns false for at least one item\n;; Equivalent to (not (every pred coll))\n(fn notEvery [pred coll]\n  (loop [s (seq coll)]\n    (if s\n      (if (pred (first s))\n        (recur (rest s))\n        true)\n      false)))\n\n;; isSome - Returns true if value is not nil (null or undefined)\n;; Note: This only checks for nil, not falsiness (0, false, \"\" return true)\n(fn isSome [x]\n  (not (nil? x)))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 5: TYPE PREDICATES\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n(fn isNil [x] (nil? x))\n(fn isEven [n] (== 0 (mod n 2)))\n(fn isOdd [n] (not (== 0 (mod n 2))))\n(fn isZero [n] (== n 0))\n(fn isPositive [n] (> n 0))\n(fn isNegative [n] (< n 0))\n(fn isNumber [x] (== \"number\" (typeof x)))\n(fn isString [x] (== \"string\" (typeof x)))\n(fn isBoolean [x] (== \"boolean\" (typeof x)))\n(fn isFunction [x] (== \"function\" (typeof x)))\n(fn isArray [x] (js-call Array.isArray x))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 6: ARITHMETIC\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n(fn inc [x] (+ x 1))\n(fn dec [x] (- x 1))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 7: COMPARISON\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n(fn eq [& vals]\n  (if (< (count vals) 2)\n    true\n    (let [fst (first vals)]\n      (loop [s (rest vals)]\n        (if (seq s)\n          (if (=== fst (first s))\n            (recur (rest s))\n            false)\n          true)))))\n\n(fn neq [a b] (not (=== a b)))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 8: LAZY CONSTRUCTORS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; repeat - Infinite sequence of the same value\n(fn repeat [x]\n  (lazy-seq (cons x (repeat x))))\n\n;; repeatedly - Infinite sequence calling f each time\n(fn repeatedly [f]\n  (lazy-seq (cons (f) (repeatedly f))))\n\n;; cycle - Infinite sequence cycling through collection\n(fn cycle [coll]\n  (let [xs (seq coll)]\n    (if xs\n      (let [step (fn [s]\n                   (lazy-seq\n                     (if (seq s)\n                       (cons (first s) (step (rest s)))\n                       (step xs))))]\n        (step xs))\n      nil)))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 9: FUNCTION OPERATIONS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; iterate - Returns x, f(x), f(f(x)), ...\n(fn iterate [f x]\n  (lazy-seq (cons x (iterate f (f x)))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 10: UTILITIES\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; keys - Get keys from an object\n(fn keys [obj]\n  (if (nil? obj)\n    []\n    (js-call Object.keys obj)))\n\n;; reverse - Reverse a collection\n(fn reverse [coll]\n  (if (nil? coll)\n    []\n    (.. (js-call Array.from coll) (reverse))))\n\n;; Export all functions\n(export [\n  ;; Sequence primitives (Lisp Trinity)\n  first, rest, cons,\n\n  ;; Indexed access & counting (Phase 2 self-hosted)\n  next, nth, count, second, last,\n\n  ;; Sequence predicates\n  isEmpty, some,\n\n  ;; Sequence operations\n  take, map, filter, reduce, drop, concat, flatten, distinct,\n\n  ;; Map operations (Phase 3 self-hosted)\n  mapIndexed, keepIndexed, mapcat, keep,\n\n  ;; Conditional lazy functions (Phase 3B)\n  takeWhile, dropWhile, splitWith, splitAt,\n\n  ;; Reduction variants (Phase 3C)\n  reductions,\n\n  ;; Sequence combinators (Phase 3D)\n  interleave, interpose,\n\n  ;; Partition family (Phase 3E)\n  partition, partitionAll, partitionBy,\n\n  ;; Collection protocols (Week 3)\n  seq, empty, conj, into,\n\n  ;; Lazy constructors (Week 4)\n  repeat, repeatedly, cycle,\n\n  ;; Sequence predicates (Week 5)\n  every, notAny, notEvery, isSome,\n\n  ;; Map/Object operations (Week 6)\n  get, getIn, assoc, assocIn, dissoc, update, updateIn, merge,\n\n  ;; Type conversions (Week 6)\n  vec, set,\n\n  ;; Sequence generators\n  range, rangeGenerator, iterate,\n\n  ;; Function operations\n  comp, partial, apply,\n\n  ;; Utilities\n  groupBy, keys, doall, realized, lazySeq,\n\n  ;; Delay/Force (explicit laziness)\n  ;; Note: 'delay' is a special form, not a function\n  force, isDelay\n])",
  "@hql/test": "(fn assert [condition message]\n  (if (not condition)\n      (throw (or message \"Assertion failed\"))\n      true))\n\n(fn assert-eq [actual expected message]\n  (if (!== actual expected)\n      (throw (+ (or message \"Assertion failed\") \" - Expected: \" expected \", Actual: \" actual))\n      true))\n\n(fn assert-throws [fn message]\n  (try\n    (fn)\n    (throw (or message \"Expected function to throw an error, but it didn't\"))\n    (catch e true)))\n\n(export [assert, assert-eq, assert-throws])\n",
  "@hql/date": "(fn now [] (js-call js/Date \"now\"))\n(fn parse [s] (js-call js/Date \"parse\" s))\n(fn format [ts] (.toISOString (new js/Date ts)))\n(fn add [ts ms] (+ ts ms))\n(fn diff [t1 t2] (- t1 t2))\n(export [now, parse, format, add, diff])\n",
  "@hql/math": "(fn abs [n] (js/Math.abs n))\n(fn floor [n] (js/Math.floor n))\n(fn ceil [n] (js/Math.ceil n))\n(fn round [n] (js/Math.round n))\n(fn min [& args] (apply js/Math.min args))\n(fn max [& args] (apply js/Math.max args))\n(fn pow [base exp] (js/Math.pow base exp))\n(fn sqrt [n] (js/Math.sqrt n))\n(export [abs, floor, ceil, round, min, max, pow, sqrt])\n",
  "@hql/http": "(fn request [url options] (js/fetch url options))\n(fn get [url] (js/fetch url))\n(fn post [url body] (js/fetch url {\"method\": \"POST\", \"body\": body}))\n(export [request, get, post])\n",
  "@hql/ai": "; @hql/ai - AI-Native Functions for HQL\n; Usage: (import [ask generate chat] from \"@hql/ai\")\n\n; Internal: Call Ollama API\n(async fn ollama-generate [prompt model]\n  (let response (await\n    (js/fetch \"http://127.0.0.1:11434/api/generate\"\n      {\"method\": \"POST\",\n       \"headers\": {\"Content-Type\": \"application/json\"},\n       \"body\": (js/JSON.stringify {\"model\": (or model \"gemma3:1b\"),\n                                   \"prompt\": prompt,\n                                   \"stream\": false})})))\n  (let data (await (response .json)))\n  (js-get data \"response\"))\n\n(async fn ollama-chat [messages model]\n  (let response (await\n    (js/fetch \"http://127.0.0.1:11434/api/chat\"\n      {\"method\": \"POST\",\n       \"headers\": {\"Content-Type\": \"application/json\"},\n       \"body\": (js/JSON.stringify {\"model\": (or model \"gemma3:1b\"),\n                                   \"messages\": messages,\n                                   \"stream\": false})})))\n  (let data (await (response .json)))\n  (js-get (js-get data \"message\") \"content\"))\n\n; Public API\n\n; (ask \"question\") - Ask AI a question, get text response\n(async fn ask [prompt & options]\n  (let model (get (first options) \"model\"))\n  (await (ollama-generate prompt model)))\n\n; (generate \"description\") - Generate code\n(async fn generate [description & options]\n  (let model (get (first options) \"model\"))\n  (let full-prompt (str \"Generate code for: \" description \". Output ONLY code, no explanations.\"))\n  (await (ollama-generate full-prompt model)))\n\n; (chat messages) - Multi-turn conversation\n(async fn chat [messages & options]\n  (let model (get (first options) \"model\"))\n  (await (ollama-chat messages model)))\n\n; (summarize text) - Summarize text\n(async fn summarize [text & options]\n  (let model (get (first options) \"model\"))\n  (let full-prompt (str \"Summarize the following text concisely:\\n\\n\" text))\n  (await (ollama-generate full-prompt model)))\n\n(export [ask generate chat summarize])\n",
  "@hql/string": "(fn split [s sep] (.split s sep))\n(fn join [arr sep] (.join arr sep))\n(fn trim [s] (.trim s))\n(fn upper-case [s] (.toUpperCase s))\n(fn lower-case [s] (.toLowerCase s))\n(fn starts-with? [s search] (.startsWith s search))\n(fn ends-with? [s search] (.endsWith s search))\n(fn replace [s search replacement] (.replace s search replacement))\n(export [split, join, trim, upper-case, lower-case, starts-with?, ends-with?, replace])\n",
  "@hql/fs": "(fn read [path] (js/Deno.readTextFile path))\n(fn write [path content] (js/Deno.writeTextFile path content))\n(fn remove [path] (js/Deno.remove path))\n(fn exists? [path] \n  (try \n    (js/Deno.statSync path) \n    true \n    (catch e false)))\n(export [read, write, remove, exists?])\n"
};
