// Auto-generated file with embedded HQL packages
// This file is generated by scripts/embed-packages.ts
// DO NOT EDIT MANUALLY

export const EMBEDDED_PACKAGES: Record<string, string> = {
  "@hql/test": ";; @hql/test - Testing utilities for HQL\n;; Version: 0.1.0\n;;\n;; Usage:\n;;   (import [assert, assert-eq, assert-throws] from \"@hql/test\")\n;;   (assert true \"should be true\")\n\n(fn assert [condition message]\n  \"Assert that a condition is truthy.\n\n  Args:\n    condition - Value to test (should be truthy)\n    message - Error message if assertion fails (optional)\n\n  Throws:\n    Error if condition is falsy\n\n  Example:\n    (assert (=== 1 1) \\\"1 should equal 1\\\")\n    (assert (> 5 3) \\\"5 should be greater than 3\\\")\"\n  (if condition\n    true\n    (throw (new js/Error (if message message \"Assertion failed\")))))\n\n(fn assert-eq [actual expected message]\n  \"Assert that two values are equal using deep equality.\n\n  Args:\n    actual - Actual value\n    expected - Expected value\n    message - Error message if assertion fails (optional)\n\n  Throws:\n    Error if values are not equal\n\n  Example:\n    (assert-eq (+ 1 2) 3 \\\"1 + 2 should equal 3\\\")\n    (assert-eq {\\\"a\\\" 1} {\\\"a\\\" 1} \\\"objects should be equal\\\")\"\n  (var actualStr (js/JSON.stringify actual))\n  (var expectedStr (js/JSON.stringify expected))\n  (var isEqual (=== actualStr expectedStr))\n  (if isEqual\n    true\n    (do\n      (var errorMsg\n        (if message\n          (str message \" - Expected: \" expectedStr \", Actual: \" actualStr)\n          (str \"Assertion failed - Expected: \" expectedStr \", Actual: \" actualStr)))\n      (throw (new js/Error errorMsg)))))\n\n(fn assert-throws [testFn expectedMessage]\n  \"Assert that a function throws an error.\n\n  Args:\n    testFn - Function that should throw\n    expectedMessage - Expected error message substring (not yet implemented)\n\n  Throws:\n    Error if function doesn't throw\n\n  Returns:\n    true if assertion passes\n\n  Example:\n    (assert-throws (fn [] (throw (new js/Error \\\"oops\\\"))) nil)\n    (assert-throws (fn [] (/ 1 0)) nil)\"\n  (var didThrow false)\n  (try\n    (testFn)\n    (catch err (= didThrow true)))\n  (if didThrow\n    true\n    (throw (new js/Error \"Expected function to throw an error, but it didn't\"))))\n\n;; Export all test utilities\n(export [assert, assert-eq, assert-throws])\n",
  "@hql/date": ";; @hql/date - Date utilities for HQL\n;; Version: 0.1.0\n;;\n;; Usage:\n;;   (import [now, format] from \"@hql/date\")\n;;   (now)                    ;; => 1699564800000\n;;   (format (now))           ;; => \"2024-11-09T12:00:00.000Z\"\n\n(fn now []\n  \"Get current timestamp in milliseconds.\n\n  Returns:\n    Current timestamp as number\n\n  Example:\n    (now)  ;; => 1699564800000\"\n  (.getTime (new js/Date)))\n\n(fn parse [date-str]\n  \"Parse ISO date string to timestamp.\n\n  Args:\n    date-str - ISO 8601 date string\n\n  Returns:\n    Timestamp in milliseconds\n\n  Example:\n    (parse \\\"2024-01-01T00:00:00.000Z\\\")  ;; => 1704067200000\"\n  (.getTime (new js/Date date-str)))\n\n(fn format [timestamp]\n  \"Format timestamp to ISO string.\n\n  Args:\n    timestamp - Milliseconds since epoch\n\n  Returns:\n    ISO 8601 formatted string\n\n  Example:\n    (format 1704067200000)  ;; => \\\"2024-01-01T00:00:00.000Z\\\"\"\n  (.toISOString (new js/Date timestamp)))\n\n(fn add [timestamp milliseconds]\n  \"Add milliseconds to timestamp.\n\n  Args:\n    timestamp - Base timestamp\n    milliseconds - Amount to add\n\n  Returns:\n    New timestamp\n\n  Example:\n    (add 1704067200000 3600000)  ;; Add 1 hour\"\n  (+ timestamp milliseconds))\n\n(fn diff [timestamp1 timestamp2]\n  \"Get difference between two timestamps.\n\n  Args:\n    timestamp1 - First timestamp\n    timestamp2 - Second timestamp\n\n  Returns:\n    Difference in milliseconds (timestamp1 - timestamp2)\n\n  Example:\n    (diff 1704070800000 1704067200000)  ;; => 3600000 (1 hour)\"\n  (- timestamp1 timestamp2))\n\n;; Export all date utilities\n(export [now, parse, format, add, diff])\n",
  "@hql/math": ";; @hql/math - Math utilities for HQL\n;; Version: 0.1.0\n;;\n;; Usage:\n;;   (import [abs, floor, ceil] from \"@hql/math\")\n;;   (abs -5)      ;; => 5\n;;   (floor 3.7)   ;; => 3\n\n(fn abs [x]\n  \"Return absolute value of number.\n\n  Args:\n    x - Number\n\n  Returns:\n    Absolute value\n\n  Example:\n    (abs -5)   ;; => 5\n    (abs 3.2)  ;; => 3.2\"\n  (js/Math.abs x))\n\n(fn floor [x]\n  \"Round number down to nearest integer.\n\n  Args:\n    x - Number to round down\n\n  Returns:\n    Floored number\n\n  Example:\n    (floor 3.7)  ;; => 3\n    (floor -2.3) ;; => -3\"\n  (js/Math.floor x))\n\n(fn ceil [x]\n  \"Round number up to nearest integer.\n\n  Args:\n    x - Number to round up\n\n  Returns:\n    Ceiled number\n\n  Example:\n    (ceil 3.2)  ;; => 4\n    (ceil -2.7) ;; => -2\"\n  (js/Math.ceil x))\n\n(fn round [x]\n  \"Round number to nearest integer.\n\n  Args:\n    x - Number to round\n\n  Returns:\n    Rounded number\n\n  Example:\n    (round 3.7)  ;; => 4\n    (round 3.2)  ;; => 3\"\n  (js/Math.round x))\n\n(fn min [& args]\n  \"Return minimum value from arguments.\n\n  Args:\n    args - Numbers to compare\n\n  Returns:\n    Minimum value\n\n  Example:\n    (min 1 5 3 9 2)  ;; => 1\"\n  (js/Math.min.apply nil args))\n\n(fn max [& args]\n  \"Return maximum value from arguments.\n\n  Args:\n    args - Numbers to compare\n\n  Returns:\n    Maximum value\n\n  Example:\n    (max 1 5 3 9 2)  ;; => 9\"\n  (js/Math.max.apply nil args))\n\n;; Export all math utilities\n(export [abs, floor, ceil, round, min, max])\n",
  "@hql/http": ";; @hql/http - HTTP utilities for HQL\n;; Version: 0.1.0\n\n(fn request [url options]\n  \"Perform HTTP request using fetch API.\n\n  Args:\n    url - URL to fetch\n    options - Options object or nil (method, body, headers, etc.)\n\n  Returns:\n    Promise resolving to Response object\n\n  Example:\n    ;; GET request\n    (var resp (request \\\"https://api.example.com/data\\\" nil))\n\n    ;; POST request with options\n    (var opts {\\\"method\\\": \\\"POST\\\", \\\"body\\\": \\\"data\\\"})\n    (var resp (request \\\"https://api.example.com/data\\\" opts))\"\n  (if options\n    (js/fetch url options)\n    (js/fetch url)))\n\n(fn get [url]\n  \"Perform HTTP GET request.\n\n  Args:\n    url - URL to fetch\n\n  Returns:\n    Promise resolving to Response object\n\n  Example:\n    (var resp (get \\\"https://api.example.com/data\\\"))\n    (var data (await (.json resp)))\"\n  (js/fetch url))\n\n(fn post [url body]\n  \"Perform HTTP POST request with body.\n\n  Args:\n    url - URL to post to\n    body - Request body (string or object)\n\n  Returns:\n    Promise resolving to Response object\n\n  Example:\n    (var resp (post \\\"https://api.example.com/data\\\" \\\"hello\\\"))\n    (var data (await (.json resp)))\"\n  (var opts {\"method\": \"POST\", \"body\": body})\n  (js/fetch url opts))\n\n(export [request, get, post])\n",
  "@hql/string": ";; @hql/string - String utilities for HQL\n;; Version: 0.1.0\n;;\n;; Usage:\n;;   (import [split, join, trim] from \"@hql/string\")\n;;   (split \"hello,world\" \",\")  ;; => [\"hello\" \"world\"]\n\n(fn split [str sep]\n  \"Split string by separator.\n\n  Args:\n    str - String to split\n    sep - Separator string\n\n  Returns:\n    Array of string parts\n\n  Example:\n    (split \\\"hello,world\\\" \\\",\\\")  ;; => [\\\"hello\\\" \\\"world\\\"]\"\n  (.split str sep))\n\n(fn join [arr sep]\n  \"Join array elements into string.\n\n  Args:\n    arr - Array to join\n    sep - Separator string\n\n  Returns:\n    Joined string\n\n  Example:\n    (join [\\\"a\\\" \\\"b\\\" \\\"c\\\"] \\\"-\\\")  ;; => \\\"a-b-c\\\"\"\n  (.join arr sep))\n\n(fn trim [str]\n  \"Remove whitespace from both ends of string.\n\n  Args:\n    str - String to trim\n\n  Returns:\n    Trimmed string\n\n  Example:\n    (trim \\\"  hello  \\\")  ;; => \\\"hello\\\"\"\n  (.trim str))\n\n(fn upper-case [str]\n  \"Convert string to uppercase.\n\n  Args:\n    str - String to convert\n\n  Returns:\n    Uppercase string\n\n  Example:\n    (upper-case \\\"hello\\\")  ;; => \\\"HELLO\\\"\"\n  (.toUpperCase str))\n\n(fn lower-case [str]\n  \"Convert string to lowercase.\n\n  Args:\n    str - String to convert\n\n  Returns:\n    Lowercase string\n\n  Example:\n    (lower-case \\\"HELLO\\\")  ;; => \\\"hello\\\"\"\n  (.toLowerCase str))\n\n(fn starts-with? [str prefix]\n  \"Check if string starts with prefix.\n\n  Args:\n    str - String to check\n    prefix - Prefix to look for\n\n  Returns:\n    Boolean - true if str starts with prefix\n\n  Example:\n    (starts-with? \\\"hello\\\" \\\"he\\\")  ;; => true\n    (starts-with? \\\"hello\\\" \\\"lo\\\")  ;; => false\"\n  (.startsWith str prefix))\n\n(fn ends-with? [str suffix]\n  \"Check if string ends with suffix.\n\n  Args:\n    str - String to check\n    suffix - Suffix to look for\n\n  Returns:\n    Boolean - true if str ends with suffix\n\n  Example:\n    (ends-with? \\\"hello\\\" \\\"lo\\\")  ;; => true\n    (ends-with? \\\"hello\\\" \\\"he\\\")  ;; => false\"\n  (.endsWith str suffix))\n\n(fn replace [str search replacement]\n  \"Replace first occurrence of search string.\n\n  Args:\n    str - String to search in\n    search - String to find\n    replacement - String to replace with\n\n  Returns:\n    String with first occurrence replaced\n\n  Example:\n    (replace \\\"hello world\\\" \\\"world\\\" \\\"there\\\")  ;; => \\\"hello there\\\"\"\n  (.replace str search replacement))\n\n;; Export all string utilities\n(export [split, join, trim, upper-case, lower-case, starts-with?, ends-with?, replace])\n",
  "@hql/fs": ";; @hql/fs - File system utilities for HQL\n;; Version: 0.1.0\n;;\n;; Usage:\n;;   (import [read, write, exists?] from \"@hql/fs\")\n;;   (await (read \"./file.txt\"))\n;;   (await (write \"./file.txt\" \"content\"))\n\n(fn read [path]\n  \"Read file contents as string.\n\n  Args:\n    path - File path to read\n\n  Returns:\n    Promise resolving to file contents\n\n  Example:\n    (await (read \\\"./file.txt\\\"))\"\n  (js/Deno.readTextFile path))\n\n(fn write [path content]\n  \"Write string content to file.\n\n  Args:\n    path - File path to write\n    content - String content to write\n\n  Returns:\n    Promise resolving when complete\n\n  Example:\n    (await (write \\\"./file.txt\\\" \\\"hello\\\"))\"\n  (js/Deno.writeTextFile path content))\n\n(fn exists? [path]\n  \"Check if file or directory exists.\n\n  Args:\n    path - Path to check\n\n  Returns:\n    Promise resolving to boolean\n\n  Example:\n    (await (exists? \\\"./file.txt\\\"))\"\n  (.then\n    (.stat js/Deno path)\n    (fn [_] true)\n    (fn [_] false)))\n\n(fn remove [path]\n  \"Remove (delete) file or directory.\n\n  Args:\n    path - Path to remove\n\n  Returns:\n    Promise resolving when complete\n\n  Example:\n    (await (remove \\\"./file.txt\\\"))\"\n  (js/Deno.remove path))\n\n;; Export all fs utilities\n(export [read, write, exists?, remove])\n",
  "@hql/lib/macro/core.hql": ";; ====================================================\n;; HQL Core Macros Library\n;; ====================================================\n;;\n;; IMPORTANT: This is the SOURCE FILE for core macros.\n;; After editing this file, run: deno task embed-macros\n;; to regenerate core/src/lib/embedded-macros.ts\n;; ====================================================\n\n(macro not [value]\n  `(if ~value false true))\n\n;; Note: list?, symbol?, and name are built-in functions defined in environment.ts\n\n;; Macro versions for user code (generate efficient inline code)\n;; NOTE: first, rest, cons, nth, second, seq are in STDLIB (core.js)\n;; They handle LazySeq properly - DO NOT shadow them with macros!\n\n(macro length [coll]\n  `(if (=== ~coll null)\n       0\n       (js-get ~coll \"length\")))\n\n(macro list [& items]\n  `[~@items])\n\n(macro nil? [x]\n  `(=== ~x null))\n\n(macro empty? [coll]\n  `(if (nil? ~coll)\n       true\n       (=== (length ~coll) 0)))\n\n;; ----------------------------------------\n;; JavaScript-Style Type Predicates\n;; ----------------------------------------\n;; These compile to OPTIMAL inline JS - no IIFEs, no function calls.\n;; Uses JS loose equality (==) for nullish checks: x == null is true for both null AND undefined.\n\n;; Null/Undefined checks - use JS loose equality for efficiency\n(macro isNull [x]\n  `(=== ~x null))\n\n(macro isUndefined [x]\n  `(=== ~x undefined))\n\n(macro isNil [x]\n  `(== ~x null))              ;; JS: x == null catches both null and undefined\n\n(macro isDefined [x]\n  `(!== ~x undefined))        ;; Direct !== check\n\n(macro notNil [x]\n  `(!= ~x null))              ;; JS: x != null is true when x is neither null nor undefined\n\n;; Type checks - compile to inline typeof checks\n(macro isString [x]\n  `(=== (typeof ~x) \"string\"))\n\n(macro isNumber [x]\n  `(=== (typeof ~x) \"number\"))\n\n(macro isBoolean [x]\n  `(=== (typeof ~x) \"boolean\"))\n\n(macro isFunction [x]\n  `(=== (typeof ~x) \"function\"))\n\n(macro isSymbol [x]\n  `(=== (typeof ~x) \"symbol\"))\n\n;; Object/Array checks - use && for direct JS output\n(macro isArray [x]\n  `(Array.isArray ~x))\n\n(macro isObject [x]\n  `(&& (&& (=== (typeof ~x) \"object\")\n           (!== ~x null))\n       (! (Array.isArray ~x))))\n\n;; ----------------------------------------\n;; camelCase Aliases for Lisp-Style Macros\n;; ----------------------------------------\n;; Pure aliases - expand to the kebab-case versions.\n\n(macro ifLet [binding then-expr else-expr]\n  `(if-let ~binding ~then-expr ~else-expr))\n\n(macro whenLet [binding & body]\n  `(when-let ~binding ~@body))\n\n(macro or [& args]\n  (cond\n    ((%empty? args) false)\n    ((=== (%length args) 1) (%first args))\n    (true\n      `((fn [value]\n          (if value\n              value\n              (or ~@(%rest args))))\n        ~(%first args)))))\n\n(macro and [& args]\n  (cond\n    ((%empty? args) true)\n    ((=== (%length args) 1) (%first args))\n    (true\n      `((fn [value]\n          (if value\n              (and ~@(%rest args))\n              value))\n        ~(%first args)))))\n\n(macro when [test & body]\n  `(if ~test\n       (do ~@body)\n       nil))\n\n(macro when-let [binding & body]\n  (let (var-name (%first binding)\n        var-value (%nth binding 1))\n    `((fn [~var-name]\n         (when ~var-name\n             ~@body))\n       ~var-value)))\n\n(macro unless [test & body]\n  `(if ~test\n       nil\n       (do ~@body)))\n\n(macro inc [x]\n  `(+ ~x 1))\n\n(macro dec [x]\n  `(- ~x 1))\n\n(macro print [& args]\n  `(console.log ~@args))\n\n;; NOTE: cons is in STDLIB - handles LazySeq properly\n\n(macro set [target value]\n  `(= ~target ~value))\n\n(macro str [& args]\n  (cond\n    ((%empty? args) `\"\")\n    ((=== (%length args) 1) `(+ \"\" ~(%first args)))\n    (true `(+ ~@args))))\n\n(macro contains? [coll key]\n  `(js-call ~coll \"has\" ~key))\n\n;; NOTE: nth is in STDLIB - handles LazySeq properly\n\n(macro if-let [binding then-expr else-expr]\n  (let (var-name (%first binding)\n        var-value (%nth binding 1))\n    `((fn [~var-name]\n         (if ~var-name\n             ~then-expr\n             ~else-expr))\n       ~var-value)))\n\n;; NOTE: second is in STDLIB - handles LazySeq properly\n\n(macro rest? [coll]\n  `(> (length ~coll) 0))\n\n(macro empty-list? [coll]\n  `(=== (length ~coll) 0))\n\n;; NOTE: seq is in STDLIB - handles LazySeq properly\n\n(macro empty-array []\n  `(vector))\n\n;; NOTE: `throw` is a kernel primitive, not a macro\n;; It needs to create ThrowStatement IR node for exception handling\n\n;; method-call is syntactic sugar over js-call\n(macro method-call [obj method & args]\n  `(js-call ~obj ~method ~@args))\n\n(macro hash-map [& items]\n  `(__hql_hash_map ~@items))\n\n(macro empty-map []\n  `(hash-map))\n\n(macro empty-set []\n  `(hash-set))\n\n;; ----------------------------------------\n;; Core control flow\n;; ----------------------------------------\n\n(macro cond [& clauses]\n  (if (%empty? clauses)\n      nil\n      (let (first-clause (%first clauses)\n            rest-clauses (%rest clauses)\n            first-el (%first first-clause))\n        ;; Check if first clause is a list (e.g., (else expr))\n        ;; If we can extract a first element, it's a list\n        (if (not (=== first-el nil))\n            ;; List clause syntax: ((test) result)\n            (let (test first-el\n                  result (%first (%rest first-clause)))\n              ;; Check if test is the symbol 'else' - if so, return result directly\n              (if (symbol? test)\n                  (if (=== (name test) \"else\")\n                      result\n                      ;; Otherwise generate if expression\n                      (if (%empty? rest-clauses)\n                          `(if ~test ~result nil)\n                          `(if ~test ~result (cond ~@rest-clauses))))\n                  ;; test is not a symbol, generate if expression\n                  (if (%empty? rest-clauses)\n                      `(if ~test ~result nil)\n                      `(if ~test ~result (cond ~@rest-clauses)))))\n            ;; Flat syntax: test result test result...\n            (if (%empty? rest-clauses)\n                (throw \"cond requires result expression for test\")\n                (let (test first-clause\n                      result (%first rest-clauses)\n                      remaining (%rest rest-clauses))\n                  (if (%empty? remaining)\n                      `(if ~test ~result nil)\n                      `(if ~test ~result (cond ~@remaining)))))))))\n\n;; NOTE: `do` is a kernel primitive, not a macro\n;; It needs to create an IIFE with BlockStatement to handle both statements and expressions\n;; A macro version using nested `let` can only handle expressions, fails with `var`/statements\n",
  "@hql/lib/macro/loop.hql": ";; ====================================================\n;; HQL Loop Constructs Library - Enhanced Version\n;; This library implements a series of looping constructs\n;; built on the fundamental loop/recur mechanism\n;; ====================================================\n;;\n;; IMPORTANT: This is the SOURCE FILE for loop macros.\n;; After editing this file, run: deno task embed-macros\n;; to regenerate core/src/lib/embedded-macros.ts\n;; ====================================================\n\n;; ====================\n;; 1. While Loop\n;; ====================\n\n;; Simple while loop - repeats body as long as condition is true\n(macro while [condition & body]\n  `(loop ()\n     (if ~condition\n       (do\n         ~@body\n         (recur))\n       nil)))\n\n;; ====================\n;; 2. Dotimes Loop (Clojure-style fixed iteration)\n;; ====================\n\n;; Simple dotimes loop - executes body a specific number of times\n;; Named after Clojure's dotimes to avoid conflicts with user code\n;; Example usage:\n;; (dotimes 3 (print \"hello\"))\n(macro dotimes [count & body]\n  `(loop (i 0)\n     (if (< i ~count)\n       (do\n         ~@body\n         (recur (+ i 1)))\n       nil)))\n\n;; ====================\n;; 3. Enhanced For Loop\n;; ====================\n\n;; for loop - enhanced iteration with multiple syntaxes\n(macro for [binding & body]\n  (let (var (%first binding)\n        spec (%rest binding)\n        spec-count (%length spec)\n        first-elem (%first spec))\n    (cond\n      ;; Error: empty spec\n      ((= spec-count 0)\n       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n\n      ;; Collection iteration: (for (x coll) ...)\n      ((= spec-count 1)\n       `(__hql_for_each (__hql_toSequence ~first-elem)\n          (fn [~var]\n            (do\n              ~@body))))\n\n      ;; spec-count is 2 - could be positional OR named \"to:\"\n      ((= spec-count 2)\n       ;; Check if first element is the SYMBOL \"to:\"\n       (if (symbol? first-elem)\n           (if (= (name first-elem) \"to:\")\n               ;; Named form: (for (i to: end) ...)\n               (let (end (%nth spec 1))\n                 `(__hql_for_each (__hql_toSequence (__hql_range 0 ~end))\n                    (fn [~var]\n                      (do\n                        ~@body))))\n               ;; Positional form: (for (i start end) ...)\n               (let (start first-elem\n                     end (%nth spec 1))\n                 `(__hql_for_each (__hql_toSequence (__hql_range ~start ~end))\n                    (fn [~var]\n                      (do\n                        ~@body)))))\n           ;; Positional form: (for (i start end) ...)\n           (let (start first-elem\n                 end (%nth spec 1))\n             `(__hql_for_each (__hql_toSequence (__hql_range ~start ~end))\n                (fn [~var]\n                  (do\n                    ~@body))))))\n\n      ;; spec-count is 3 - could be positional OR named with step\n      ((= spec-count 3)\n       ;; Positional form: (for (i start end step) ...)\n       (let (start first-elem\n             end (%nth spec 1)\n             step (%nth spec 2))\n         `(__hql_for_each (__hql_toSequence (__hql_range ~start ~end ~step))\n            (fn [~var]\n              (do\n                ~@body)))))\n\n      ;; spec-count is 4 - must be named \"to: end by: step\" OR \"from: start to: end\"\n      ((= spec-count 4)\n       (if (symbol? first-elem)\n           (if (= (name first-elem) \"to:\")\n               ;; Named form: (for (i to: end by: step) ...)\n               (if (symbol? (%nth spec 2))\n                   (if (= (name (%nth spec 2)) \"by:\")\n                       (let (end (%nth spec 1)\n                             step (%nth spec 3))\n                         `(__hql_for_each (__hql_toSequence (__hql_range 0 ~end ~step))\n                            (fn [~var]\n                              (do\n                                ~@body))))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n               (if (= (name first-elem) \"from:\")\n                   ;; Named form: (for (i from: start to: end) ...)\n                   (if (symbol? (%nth spec 2))\n                       (if (= (name (%nth spec 2)) \"to:\")\n                           (let (start (%nth spec 1)\n                                 end (%nth spec 3))\n                             `(__hql_for_each (__hql_toSequence (__hql_range ~start ~end))\n                                (fn [~var]\n                                  (do\n                                    ~@body))))\n                           `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n           `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n\n      ;; spec-count is 6 - must be named \"from: start to: end by: step\"\n      ((= spec-count 6)\n       (if (symbol? first-elem)\n           (if (= (name first-elem) \"from:\")\n               (if (symbol? (%nth spec 2))\n                   (if (= (name (%nth spec 2)) \"to:\")\n                       (if (symbol? (%nth spec 4))\n                           (if (= (name (%nth spec 4)) \"by:\")\n                               (let (start (%nth spec 1)\n                                     end (%nth spec 3)\n                                     step (%nth spec 5))\n                                 `(__hql_for_each (__hql_toSequence (__hql_range ~start ~end ~step))\n                                    (fn [~var]\n                                      (do\n                                        ~@body))))\n                               `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                           `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n               `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n           `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n\n      (true `(throw (str \"Invalid 'for' loop binding: \" '~binding)))))\n  )\n",
  "@hql/lib/stdlib/stdlib.hql": ";; lib/stdlib/stdlib.hql - HQL re-exports JavaScript implementation\n;; Note: These functions are auto-loaded by the runtime, so this file is mainly\n;; for documentation and explicit imports in user code.\n;;\n;; IMPORTANT: This must match STDLIB_PUBLIC_API behavior!\n;; - We import rangeGenerator (lazy) and export it as range\n;; - This ensures explicit imports match auto-loaded behavior\n\n;; Import all 51 fundamental functions from modular JS implementation\n(import [\n  ;; Sequence primitives (Lisp Trinity)\n  first, rest, cons,\n\n  ;; Indexed access & counting (Week 1)\n  nth, count, second, last,\n\n  ;; Sequence predicates\n  isEmpty, some,\n\n  ;; Sequence operations\n  take, map, filter, reduce, drop, concat, flatten, distinct,\n\n  ;; Map operations (Week 2)\n  mapIndexed, keepIndexed, mapcat, keep,\n\n  ;; Collection protocols (Week 3)\n  seq, empty, conj, into,\n\n  ;; Lazy constructors (Week 4)\n  repeat, repeatedly, cycle,\n\n  ;; Sequence predicates (Week 5)\n  every, notAny, notEvery, isSome,\n\n  ;; Map/Object operations (Week 6)\n  get, getIn, assoc, assocIn, dissoc, update, updateIn, merge,\n\n  ;; Type conversions (Week 6)\n  vec, set,\n\n  ;; Sequence generators\n  rangeGenerator, iterate,\n\n  ;; Function operations\n  comp, partial, apply,\n\n  ;; Utilities\n  groupBy, keys, doall, realized, lazySeq\n] from \"./js/stdlib.js\")\n\n;; Create alias for range to match runtime behavior\n;; rangeGenerator is imported above, we alias it as \"range\" here\n(let range rangeGenerator)\n\n;; Export all functions (matching STDLIB_PUBLIC_API - 51 total)\n(export [\n  ;; Sequence primitives (Lisp Trinity)\n  first, rest, cons,\n\n  ;; Indexed access & counting (Week 1)\n  nth, count, second, last,\n\n  ;; Sequence predicates\n  isEmpty, some,\n\n  ;; Sequence operations\n  take, map, filter, reduce, drop, concat, flatten, distinct,\n\n  ;; Map operations (Week 2)\n  mapIndexed, keepIndexed, mapcat, keep,\n\n  ;; Collection protocols (Week 3)\n  seq, empty, conj, into,\n\n  ;; Lazy constructors (Week 4)\n  repeat, repeatedly, cycle,\n\n  ;; Sequence predicates (Week 5)\n  every, notAny, notEvery, isSome,\n\n  ;; Map/Object operations (Week 6)\n  get, getIn, assoc, assocIn, dissoc, update, updateIn, merge,\n\n  ;; Type conversions (Week 6)\n  vec, set,\n\n  ;; Sequence generators\n  range, rangeGenerator, iterate,\n\n  ;; Function operations\n  comp, partial, apply,\n\n  ;; Utilities\n  groupBy, keys, doall, realized, lazySeq\n])"
};

export const EMBEDDED_PACKAGE_COUNT = 9;
