// Auto-generated file with embedded HQL packages
// This file is generated by scripts/embed-packages.ts
// DO NOT EDIT MANUALLY

export const EMBEDDED_PACKAGES: Record<string, string> = {
  "@hql/lib/macro/core.hql": ";; ====================================================\n;; HQL Core Macros Library\n;; ====================================================\n;;\n;; IMPORTANT: This is the SOURCE FILE for core macros.\n;; After editing this file, run: deno task embed-macros\n;; to regenerate core/src/lib/embedded-macros.ts\n;; ====================================================\n\n(macro not [value]\n  `(if ~value false true))\n\n;; Note: list?, symbol?, and name are built-in functions defined in environment.ts\n\n;; Macro versions for user code (generate efficient inline code)\n;; NOTE: first, rest, cons, nth, second, seq are in STDLIB (core.js)\n;; They handle LazySeq properly - DO NOT shadow them with macros!\n\n(macro length [coll]\n  `(if (=== ~coll null)\n       0\n       (js-get ~coll \"length\")))\n\n(macro list [& items]\n  `[~@items])\n\n;; REMOVED: nil? - use isNil instead (camelCase convention)\n;; REMOVED: empty? - use isEmpty from stdlib instead (camelCase convention)\n\n;; ----------------------------------------\n;; JavaScript-Style Type Predicates\n;; ----------------------------------------\n;; These compile to OPTIMAL inline JS - no IIFEs, no function calls.\n;; Uses JS loose equality (==) for nullish checks: x == null is true for both null AND undefined.\n\n;; Null/Undefined checks - use JS loose equality for efficiency\n(macro isNull [x]\n  `(=== ~x null))\n\n(macro isUndefined [x]\n  `(=== ~x undefined))\n\n(macro isNil [x]\n  `(== ~x null))              ;; JS: x == null catches both null and undefined\n\n(macro isDefined [x]\n  `(!== ~x undefined))        ;; Direct !== check\n\n(macro notNil [x]\n  `(!= ~x null))              ;; JS: x != null is true when x is neither null nor undefined\n\n;; Type checks - compile to inline typeof checks\n(macro isString [x]\n  `(=== (typeof ~x) \"string\"))\n\n(macro isNumber [x]\n  `(=== (typeof ~x) \"number\"))\n\n(macro isBoolean [x]\n  `(=== (typeof ~x) \"boolean\"))\n\n(macro isFunction [x]\n  `(=== (typeof ~x) \"function\"))\n\n(macro isSymbol [x]\n  `(=== (typeof ~x) \"symbol\"))\n\n;; Object/Array checks - use && for direct JS output\n(macro isArray [x]\n  `(Array.isArray ~x))\n\n(macro isObject [x]\n  `(&& (&& (=== (typeof ~x) \"object\")\n           (!== ~x null))\n       (! (Array.isArray ~x))))\n\n;; Numeric predicates: isEven, isOdd, isZero, isPositive, isNegative\n;; These are FUNCTIONS in stdlib (core.js), not macros.\n;; Functions can be passed to higher-order functions like filter/map.\n\n;; ----------------------------------------\n;; camelCase Aliases for Lisp-Style Macros\n;; ----------------------------------------\n;; Pure aliases - expand to the kebab-case versions.\n\n(macro ifLet [binding then-expr else-expr]\n  `(if-let ~binding ~then-expr ~else-expr))\n\n(macro whenLet [binding & body]\n  `(when-let ~binding ~@body))\n\n(macro or [& args]\n  (cond\n    ((%empty? args) false)\n    ((=== (%length args) 1) (%first args))\n    (true `(|| ~(%first args) (or ~@(%rest args))))))\n\n(macro and [& args]\n  (cond\n    ((%empty? args) true)\n    ((=== (%length args) 1) (%first args))\n    (true `(&& ~(%first args) (and ~@(%rest args))))))\n\n(macro when [test & body]\n  `(if ~test\n       (do ~@body)\n       nil))\n\n;; Handle [] syntax: (when-let [x val]) is parsed as (when-let (vector x val))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n(macro when-let [binding & body]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var-name (%first normalized-binding)\n          var-value (%nth normalized-binding 1))\n      `((fn [~var-name]\n           (when ~var-name\n               ~@body))\n         ~var-value))))\n\n(macro unless [test & body]\n  `(if ~test\n       nil\n       (do ~@body)))\n\n(macro inc [x]\n  `(+ ~x 1))\n\n(macro dec [x]\n  `(- ~x 1))\n\n(macro print [& args]\n  `(console.log ~@args))\n\n;; NOTE: cons is in STDLIB - handles LazySeq properly\n\n(macro set [target value]\n  `(= ~target ~value))\n\n(macro str [& args]\n  (cond\n    ((%empty? args) `\"\")\n    ((=== (%length args) 1) `(+ \"\" ~(%first args)))\n    (true `(+ ~@args))))\n\n(macro contains [coll key]\n  `(js-call ~coll \"has\" ~key))\n\n;; NOTE: nth is in STDLIB - handles LazySeq properly\n\n;; Handle [] syntax: (if-let [x val]) is parsed as (if-let (vector x val))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n(macro if-let [binding then-expr else-expr]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var-name (%first normalized-binding)\n          var-value (%nth normalized-binding 1))\n      `((fn [~var-name]\n           (if ~var-name\n               ~then-expr\n               ~else-expr))\n         ~var-value))))\n\n;; NOTE: second is in STDLIB - handles LazySeq properly\n\n(macro hasElements [coll]\n  `(> (length ~coll) 0))\n\n(macro isEmptyList [coll]\n  `(=== (length ~coll) 0))\n\n;; NOTE: seq is in STDLIB - handles LazySeq properly\n\n(macro empty-array []\n  `(vector))\n\n;; NOTE: `throw` is a kernel primitive, not a macro\n;; It needs to create ThrowStatement IR node for exception handling\n\n;; method-call is syntactic sugar over js-call\n(macro method-call [obj method & args]\n  `(js-call ~obj ~method ~@args))\n\n(macro hash-map [& items]\n  `(__hql_hash_map ~@items))\n\n(macro empty-map []\n  `(hash-map))\n\n(macro empty-set []\n  `(hash-set))\n\n;; ----------------------------------------\n;; Core control flow\n;; ----------------------------------------\n\n;; cond - Supports BOTH syntaxes:\n;; Grouped syntax: (cond ((< x 0) \"neg\") ((> x 0) \"pos\") (true \"zero\"))\n;; Flat syntax:    (cond (< x 0) \"neg\" (> x 0) \"pos\" :else \"zero\")\n;; Detection: If first clause is a list with exactly 2 elements, use grouped syntax.\n;; NOTE: Uses nested if instead of && to avoid circular dependency (and macro uses cond)\n(macro cond [& clauses]\n  (if (%empty? clauses)\n      nil\n      ;; Detect syntax based on first clause\n      (let (first-clause (%first clauses))\n        ;; Grouped syntax: first clause is a list with 2 elements like ((< x 0) \"result\")\n        ;; Use nested if instead of && to avoid circular dependency\n        (if (list? first-clause)\n            (if (=== (%length first-clause) 2)\n                ;; Grouped syntax: each clause is (test result)\n                (let (test (%first first-clause)\n                      result (%first (%rest first-clause))\n                      remaining (%rest clauses))\n                  (if (symbol? test)\n                      (if (=== (name test) \"else\")\n                          result\n                          (if (%empty? remaining)\n                              `(if ~test ~result nil)\n                              `(if ~test ~result (cond ~@remaining))))\n                      (if (%empty? remaining)\n                          `(if ~test ~result nil)\n                          `(if ~test ~result (cond ~@remaining)))))\n                ;; List but not 2 elements - treat as flat syntax\n                (if (%empty? (%rest clauses))\n                    first-clause\n                    (let (test first-clause\n                          result (%first (%rest clauses))\n                          remaining (%rest (%rest clauses)))\n                      (if (symbol? test)\n                          (if (=== (name test) \"else\")\n                              result\n                              (if (%empty? remaining)\n                                  `(if ~test ~result nil)\n                                  `(if ~test ~result (cond ~@remaining))))\n                          (if (%empty? remaining)\n                              `(if ~test ~result nil)\n                              `(if ~test ~result (cond ~@remaining)))))))\n            ;; Not a list - flat syntax: test1 result1 test2 result2 ...\n            (if (%empty? (%rest clauses))\n                ;; Single element - just return it (handles :else or true at end)\n                first-clause\n                (let (test first-clause\n                      result (%first (%rest clauses))\n                      remaining (%rest (%rest clauses)))\n                  (if (symbol? test)\n                      (if (=== (name test) \"else\")\n                          result\n                          (if (%empty? remaining)\n                              `(if ~test ~result nil)\n                              `(if ~test ~result (cond ~@remaining))))\n                      (if (%empty? remaining)\n                          `(if ~test ~result nil)\n                          `(if ~test ~result (cond ~@remaining))))))))))\n\n;; NOTE: `do` is a kernel primitive, not a macro\n;; It needs to create an IIFE with BlockStatement to handle both statements and expressions\n;; A macro version using nested `let` can only handle expressions, fails with `var`/statements\n\n;; ----------------------------------------\n;; Threading Macros (Clojure-compatible)\n;; ----------------------------------------\n;; These are compile-time transformations with ZERO runtime overhead.\n;; They transform nested function calls into readable linear pipelines.\n\n;; Thread-first: inserts x as FIRST argument of each form\n;; (-> x (f a) (g b)) => (g (f x a) b)\n;; (-> x f g) => (g (f x))\n(macro -> [x & forms]\n  (if (%empty? forms)\n    x\n    (let (form (%first forms)\n          rest-forms (%rest forms)\n          threaded (if (list? form)\n                     ;; Form is a list like (f a b), insert x as first arg: (f x a b)\n                     `(~(%first form) ~x ~@(%rest form))\n                     ;; Form is a symbol like f, make it (f x)\n                     `(~form ~x)))\n      `(-> ~threaded ~@rest-forms))))\n\n;; Thread-last: inserts x as LAST argument of each form\n;; (->> x (f a) (g b)) => (g b (f a x))\n;; (->> x f g) => (g (f x))\n(macro ->> [x & forms]\n  (if (%empty? forms)\n    x\n    (let (form (%first forms)\n          rest-forms (%rest forms)\n          threaded (if (list? form)\n                     ;; Form is a list like (f a b), insert x as last arg: (f a b x)\n                     `(~@form ~x)\n                     ;; Form is a symbol like f, make it (f x)\n                     `(~form ~x)))\n      `(->> ~threaded ~@rest-forms))))\n\n;; Thread-as: binds x to a symbol for arbitrary placement\n;; (as-> 2 x (+ x 1) (* x 3)) => ((fn [x] (* x 3)) ((fn [x] (+ x 1)) 2))\n;; Each form is wrapped in a function that binds the name, avoiding rebinding issues\n(macro as-> [expr name & forms]\n  (if (%empty? forms)\n    expr\n    (let (first-form (%first forms)\n          rest-forms (%rest forms))\n      `((fn [~name] (as-> ~first-form ~name ~@rest-forms))\n        ~expr))))\n\n;; ----------------------------------------\n;; Pattern Matching (Swift/Scala-style syntax)\n;; ----------------------------------------\n;; Syntax:\n;;   (match value\n;;     (case pattern result)\n;;     (case pattern (if guard) result)\n;;     (default result))\n;;\n;; Supported patterns:\n;;   - Literals: 42, \"hello\", true, null\n;;   - Wildcard: _ (matches anything, no binding)\n;;   - Symbol: x (matches anything, binds to x)\n;;   - Array: [a, b], [], [h, & t] (rest pattern)\n;;   - Object: {name, age}, {name: n, age: a}\n;;\n;; Guards: (if condition) checked AFTER pattern binding\n;;\n;; Implementation: Uses IIFE with JS destructuring for object/array patterns.\n;; This avoids macro-time let evaluation issues.\n;; Time complexity: O(n) where n = number of clauses (optimal for sequential matching)\n\n\n;; Main match macro - binds value once, dispatches to implementation\n;; Uses auto-gensym (val#) for hygiene - Clojure-style syntax\n(macro match [value & clauses]\n  `(let (val# ~value)\n     (__match_impl__ val# ~@clauses)))\n\n;; Implementation macro - processes clauses recursively\n(macro __match_impl__ [val-sym & clauses]\n  (if (%empty? clauses)\n      `((fn [] (throw (new Error \"No matching pattern\"))))\n      (let (clause (%first clauses)\n            rest-clauses (%rest clauses)\n            clause-kind (if (list? clause)\n                            (if (symbol? (%first clause))\n                                (name (%first clause))\n                                \"unknown\")\n                            \"unknown\"))\n        (cond\n          ((=== clause-kind \"default\")\n           (%nth clause 1))\n\n          ((=== clause-kind \"case\")\n           (let (pattern (%nth clause 1)\n                 ;; Guard detection\n                 has-guard (if (>= (%length clause) 4)\n                               (if (list? (%nth clause 2))\n                                   (if (symbol? (%first (%nth clause 2)))\n                                       (=== (name (%first (%nth clause 2))) \"if\")\n                                       false)\n                                   false)\n                               false)\n                 guard-expr (if has-guard (%nth (%nth clause 2) 1) nil)\n                 result-expr (if has-guard (%nth clause 3) (%nth clause 2))\n                 ;; Pattern classification - single symbol? check, reuse result\n                 pat-name (if (symbol? pattern) (name pattern) nil)\n                 is-wildcard (=== pat-name \"_\")\n                 is-null-pat (=== pat-name \"null\")\n                 is-binding (if pat-name (if is-wildcard false (if is-null-pat false true)) false)\n                 ;; List pattern detection\n                 is-list (if pat-name false (list? pattern))\n                 head-name (if is-list (if (symbol? (%first pattern)) (name (%first pattern)) nil) nil)\n                 is-object (if head-name (if (=== head-name \"hash-map\") true (=== head-name \"__hql_hash_map\")) false)\n                 is-array (if is-list (if is-object false true) false)\n                 ;; Array rest pattern detection\n                 arr-len (if is-array (%length pattern) 0)\n                 has-rest (if (>= arr-len 2)\n                              (if (symbol? (%nth pattern (- arr-len 2)))\n                                  (=== (name (%nth pattern (- arr-len 2))) \"&\")\n                                  false)\n                              false)\n                 check-len (if has-rest (- arr-len 2) arr-len)\n                 ;; Generate condition using runtime helper __hql_match_obj\n                 ;; For object patterns, pass the entire pattern - runtime extracts keys dynamically\n                 ;; No hardcoding of key count - works for ANY number of keys\n                 condition (cond\n                             (is-wildcard true)\n                             (is-binding true)\n                             (is-null-pat `(=== ~val-sym null))\n                             ;; Object pattern: pass pattern to runtime helper\n                             ;; __hql_match_obj(val, pattern) extracts keys from pattern at indices 1,3,5,...\n                             (is-object `(__hql_match_obj ~val-sym (quote ~pattern)))\n                             (is-array (if has-rest\n                                           `(and (Array.isArray ~val-sym)\n                                                 (>= (js-get ~val-sym \"length\") ~check-len))\n                                           `(and (Array.isArray ~val-sym)\n                                                 (=== (js-get ~val-sym \"length\") ~check-len))))\n                             (else `(=== ~val-sym ~pattern)))\n                 ;; Fallback for next clause\n                 fallback `(__match_impl__ ~val-sym ~@rest-clauses)\n                 ;; Generate body - uses IIFE with destructuring param for object/array\n                 ;; This bypasses macro-time let evaluation which doesn't support destructuring\n                 body (cond\n                        ;; Simple symbol binding\n                        (is-binding\n                         (if has-guard\n                             `(let (~pattern ~val-sym) (if ~guard-expr ~result-expr ~fallback))\n                             `(let (~pattern ~val-sym) ~result-expr)))\n                        ;; Destructuring via IIFE - fn param supports destructuring!\n                        (is-object\n                         (if has-guard\n                             `((fn [~pattern] (if ~guard-expr ~result-expr ~fallback)) ~val-sym)\n                             `((fn [~pattern] ~result-expr) ~val-sym)))\n                        (is-array\n                         (if has-guard\n                             `((fn [~pattern] (if ~guard-expr ~result-expr ~fallback)) ~val-sym)\n                             `((fn [~pattern] ~result-expr) ~val-sym)))\n                        ;; No binding (wildcard, null, literal)\n                        (else\n                         (if has-guard `(if ~guard-expr ~result-expr ~fallback) result-expr))))\n             ;; Optimization: skip (if true ...) when condition is always true\n             (if (=== condition true)\n                 body\n                 `(if ~condition ~body ~fallback))))\n\n          (else\n           `((fn [] (throw (new Error \"Invalid match clause\")))))))))\n",
  "@hql/lib/macro/utils.hql": ";; ====================================================\n;; HQL Utility Macros\n;; Common Lisp-style utilities\n;; ====================================================\n\n;; doto: Executes forms with x as first argument, returns x\n;; (doto (new HashMap) (.set \"a\" 1) (.set \"b\" 2))\n(macro doto [x & forms]\n  (let (gx (gensym \"doto\"))\n    `(let (~gx ~x)\n       ~@(map (fn [f]\n                (if (list? f)\n                  (let (head (%first f))\n                    (if (symbol? head)\n                        (let (hname (name head))\n                          (if (=== (js-call hname \"charAt\" 0) \".\")\n                              `(js-call ~gx ~(js-call hname \"substring\" 1) ~@(%rest f))\n                              `(~head ~gx ~@(%rest f))))\n                        `(~head ~gx ~@(%rest f))))\n                  `(~f ~gx)))\n              forms)\n       ~gx)))\n\n;; if-not: Inverse of if\n(macro if-not [test then else]\n  `(if ~test ~else ~then))\n\n;; when-not: Inverse of when\n(macro when-not [test & body]\n  `(if ~test nil (do ~@body)))\n\n;; xor: Logical XOR\n(macro xor [a b]\n  (let (ga (gensym \"xor_a\")\n        gb (gensym \"xor_b\"))\n    `(let (~ga ~a\n           ~gb ~b)\n       (if ~ga (not ~gb) ~gb))))\n\n;; min/max macros expanding to Math functions\n(macro min [& args]\n  `(Math.min ~@args))\n\n(macro max [& args]\n  `(Math.max ~@args))\n\n;; with-gensyms: Hygiene helper for macro writers\n;; Binds each name to a unique gensym for safe macro expansion.\n;;\n;; Usage:\n;;   (macro my-swap [a b]\n;;     (with-gensyms [tmp]\n;;       `(let (~tmp ~a)\n;;          (set! ~a ~b)\n;;          (set! ~b ~tmp))))\n;;\n;; Each name in the vector gets bound to (gensym \"name\"), making the\n;; macro hygienic by avoiding variable capture.\n(macro with-gensyms [names & body]\n  `(let ~(apply vector\n           (apply concat\n             (map (fn [n]\n                    [n `(gensym ~(if (symbol? n) (name n) \"g\"))])\n                  names)))\n     ~@body))\n",
  "@hql/lib/macro/loop.hql": ";; ====================================================\n;; HQL Loop Constructs Library - Enhanced Version\n;; This library implements a series of looping constructs\n;; built on the fundamental loop/recur mechanism\n;; ====================================================\n;;\n;; IMPORTANT: This is the SOURCE FILE for loop macros.\n;; After editing this file, run: deno task embed-macros\n;; to regenerate core/src/lib/embedded-macros.ts\n;; ====================================================\n\n;; ====================\n;; 1. While Loop\n;; ====================\n\n;; Simple while loop - repeats body as long as condition is true\n(macro while [condition & body]\n  `(loop []\n     (if ~condition\n       (do\n         ~@body\n         (recur))\n       nil)))\n\n;; ====================\n;; 2. Dotimes Loop (Clojure-style fixed iteration)\n;; ====================\n\n;; Simple dotimes loop - executes body a specific number of times\n;; Named after Clojure's dotimes to avoid conflicts with user code\n;; Example usage:\n;; (dotimes 3 (print \"hello\"))\n(macro dotimes [count & body]\n  `(loop [i 0]\n     (if (< i ~count)\n       (do\n         ~@body\n         (recur (+ i 1)))\n       nil)))\n\n;; ====================\n;; 2b. Repeat Loop (alias for dotimes)\n;; ====================\n\n;; repeat loop - executes body a specific number of times\n;; Same as dotimes but with a different name\n;; Example usage:\n;; (repeat 3 (print \"hello\"))\n(macro repeat [count & body]\n  `(loop [__repeat_i 0]\n     (if (< __repeat_i ~count)\n       (do\n         ~@body\n         (recur (+ __repeat_i 1)))\n       nil)))\n\n;; ====================\n;; 3. Enhanced For Loop\n;; ====================\n\n;; for loop - enhanced iteration with multiple syntaxes\n;; Handle [] syntax: (for [x coll]) is parsed as (for (vector x coll))\n;; Strip the \"vector\" prefix to normalize both () and [] syntax\n;;\n;; IMPORTANT: Uses for-of internally (not __hql_for_each with callback)\n;; so that return/break/continue work correctly from the enclosing function.\n(macro for [binding & body]\n  (let (normalized-binding\n         (if (symbol? (%first binding))\n             (if (=== (name (%first binding)) \"vector\")\n                 (%rest binding)\n                 (if (=== (name (%first binding)) \"empty-array\")\n                     (%rest binding)\n                     binding))\n             binding))\n    (let (var (%first normalized-binding)\n          spec (%rest normalized-binding)\n          spec-count (%length spec)\n          first-elem (%first spec))\n    (cond\n      ;; Error: empty spec\n      ((=== spec-count 0)\n       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n\n      ;; Collection/count iteration: (for (x coll) ...) or (for (i n) ...)\n      ;; Uses for-of with __hql_toIterable to handle both collections and numbers\n      ;; Numbers are converted to range(0, n) at runtime\n      ((=== spec-count 1)\n       `(for-of [~var (__hql_toIterable ~first-elem)]\n          ~@body))\n\n      ;; spec-count is 2 - could be positional OR named \"to:\"\n      ((=== spec-count 2)\n       ;; Check if first element is the SYMBOL \"to:\"\n       (if (symbol? first-elem)\n           (if (=== (name first-elem) \"to:\")\n               ;; Named form: (for (i to: end) ...)\n               (let (end (%nth spec 1))\n                 `(for-of [~var (__hql_range 0 ~end)]\n                    ~@body))\n               ;; Positional form: (for (i start end) ...)\n               (let (start first-elem\n                     end (%nth spec 1))\n                 `(for-of [~var (__hql_range ~start ~end)]\n                    ~@body)))\n           ;; Positional form: (for (i start end) ...)\n           (let (start first-elem\n                 end (%nth spec 1))\n             `(for-of [~var (__hql_range ~start ~end)]\n                ~@body))))\n\n      ;; spec-count is 3 - could be positional OR named with step\n      ((=== spec-count 3)\n       ;; Positional form: (for (i start end step) ...)\n       (let (start first-elem\n             end (%nth spec 1)\n             step (%nth spec 2))\n         `(for-of [~var (__hql_range ~start ~end ~step)]\n            ~@body)))\n\n      ;; spec-count is 4 - must be named \"to: end by: step\" OR \"from: start to: end\"\n      ((=== spec-count 4)\n       (if (symbol? first-elem)\n           (if (=== (name first-elem) \"to:\")\n               ;; Named form: (for (i to: end by: step) ...)\n               (if (symbol? (%nth spec 2))\n                   (if (=== (name (%nth spec 2)) \"by:\")\n                       (let (end (%nth spec 1)\n                             step (%nth spec 3))\n                         `(for-of [~var (__hql_range 0 ~end ~step)]\n                            ~@body))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n               (if (=== (name first-elem) \"from:\")\n                   ;; Named form: (for (i from: start to: end) ...)\n                   (if (symbol? (%nth spec 2))\n                       (if (=== (name (%nth spec 2)) \"to:\")\n                           (let (start (%nth spec 1)\n                                 end (%nth spec 3))\n                             `(for-of [~var (__hql_range ~start ~end)]\n                                ~@body))\n                           `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n           `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n\n      ;; spec-count is 6 - must be named \"from: start to: end by: step\"\n      ((=== spec-count 6)\n       (if (symbol? first-elem)\n           (if (=== (name first-elem) \"from:\")\n               (if (symbol? (%nth spec 2))\n                   (if (=== (name (%nth spec 2)) \"to:\")\n                       (if (symbol? (%nth spec 4))\n                           (if (=== (name (%nth spec 4)) \"by:\")\n                               (let (start (%nth spec 1)\n                                     end (%nth spec 3)\n                                     step (%nth spec 5))\n                                 `(for-of [~var (__hql_range ~start ~end ~step)]\n                                    ~@body))\n                               `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                           `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                       `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n                   `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n               `(throw (str \"Invalid 'for' loop binding: \" '~binding)))\n           `(throw (str \"Invalid 'for' loop binding: \" '~binding))))\n\n      (true `(throw (str \"Invalid 'for' loop binding: \" '~binding))))))\n  )\n",
  "@hql/lib/stdlib/js/ai.js": "// @hql/ai - JavaScript implementation\n// This provides AI functions that call Ollama\n\nconst OLLAMA_URL = \"http://127.0.0.1:11434\";\n\n/**\n * Ask AI a question\n * @param {string} prompt - The question to ask\n * @param {Object} options - Optional settings (model, etc.)\n * @returns {Promise<string>} - AI response\n */\nexport async function ask(prompt, options = {}) {\n  const model = options.model || \"gemma3:1b\";\n  const response = await fetch(`${OLLAMA_URL}/api/generate`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({ model, prompt, stream: false })\n  });\n\n  if (!response.ok) {\n    throw new Error(`AI request failed: ${response.status}`);\n  }\n\n  const data = await response.json();\n  return data.response.trim();\n}\n\n/**\n * Generate code from description\n * @param {string} description - What to generate\n * @param {Object} options - Optional settings\n * @returns {Promise<string>} - Generated code\n */\nexport async function generate(description, options = {}) {\n  const fullPrompt = `Generate code for: ${description}. Output ONLY code, no explanations.`;\n  return ask(fullPrompt, options);\n}\n\n/**\n * Multi-turn chat conversation\n * @param {Array<{role: string, content: string}>} messages - Conversation messages\n * @param {Object} options - Optional settings\n * @returns {Promise<string>} - AI response\n */\nexport async function chat(messages, options = {}) {\n  const model = options.model || \"gemma3:1b\";\n  const response = await fetch(`${OLLAMA_URL}/api/chat`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify({ model, messages, stream: false })\n  });\n\n  if (!response.ok) {\n    throw new Error(`Chat request failed: ${response.status}`);\n  }\n\n  const data = await response.json();\n  return data.message.content.trim();\n}\n\n/**\n * Summarize text\n * @param {string} text - Text to summarize\n * @param {Object} options - Optional settings\n * @returns {Promise<string>} - Summary\n */\nexport async function summarize(text, options = {}) {\n  const fullPrompt = `Summarize the following text concisely:\\n\\n${text}`;\n  return ask(fullPrompt, options);\n}\n\nexport default { ask, generate, chat, summarize };\n",
  "@hql/lib/stdlib/js/core.js": "// core.js - Bootstrap primitives and non-self-hosted functions\n// Self-hosted functions are in self-hosted.js (transpiled from stdlib.hql)\n\nimport { rangeCore } from \"./internal/range-core.js\";\n\n// Import Clojure-aligned foundation for lazy-seq support\n// CONSOLIDATED: All lazy sequences use seq-protocol.js (thunk-based, O(1) rest)\nimport {\n  lazySeq as seqLazySeq,\n  chunkedLazySeq,  // For chunked operations (enables chunk propagation)\n  cons as seqCons,\n  EMPTY as SEQ_EMPTY,\n  isSeqEnd,  // DRY helper: x == null || x === EMPTY\n  isActiveSeq,  // DRY helper: !isSeqEnd(x) && x.seq?.()\n  iteratorSeq,  // DRY: shared iterator-to-Cons conversion\n  maybeRealize,  // DRY: realize LazySeq if needed\n  SEQ,\n  isCons,\n  LazySeq,\n  ArraySeq,\n  NumericRange,\n  Delay,\n  delay as seqDelay,\n  force as seqForce,\n  isDelay as seqIsDelay,\n  // Transducer infrastructure\n  reduced as seqReduced,\n  isReduced as seqIsReduced,\n  unreduced as seqUnreduced,\n  ensureReduced as seqEnsureReduced,\n  toTransformer as seqToTransformer,\n  completing as seqCompleting,\n  TRANSDUCER_INIT,\n  TRANSDUCER_STEP,\n  TRANSDUCER_RESULT,\n  // Chunked sequence infrastructure\n  CHUNK_SIZE,\n  ArrayChunk,\n  ChunkBuffer,\n  ChunkedCons,\n  chunkCons as seqChunkCons,\n  arrayChunk as seqArrayChunk,\n  isChunked as seqIsChunked,\n  chunkFirst as seqChunkFirst,\n  chunkRest as seqChunkRest,\n  toChunkedSeq as seqToChunkedSeq,\n} from \"./internal/seq-protocol.js\";\nimport {\n  validateFiniteNumber,\n  validateFunction,\n  validateNonZeroNumber,\n} from \"./internal/validators.js\";\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// FOUNDATION BRIDGE (for HQL lazy-seq macro)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Creates a lazy sequence from a thunk (for HQL lazy-seq macro).\n * Uses Clojure-aligned seq-protocol.js foundation.\n */\nexport function __hql_lazy_seq(thunk) {\n  return seqLazySeq(thunk);\n}\n\n/**\n * Check if a value is a Cons cell\n */\nexport function isConsCell(value) {\n  return isCons(value);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// SEQUENCE PRIMITIVES (The Lisp Trinity)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Returns the first element of a collection\n *\n * @param {Iterable|null|undefined} coll - Any iterable collection\n * @returns {*} First element, or undefined if empty\n *\n * @example\n * first([1, 2, 3])  // → 1\n * first([])         // → undefined\n * first(null)       // → undefined\n */\nexport function first(coll) {\n  if (coll == null) return undefined;\n\n  // SEQ protocol (foundation Cons/LazySeq): use first() method\n  if (coll[SEQ]) {\n    return coll.first();\n  }\n\n  // Optimize for arrays\n  if (Array.isArray(coll)) {\n    return coll.length > 0 ? coll[0] : undefined;\n  }\n\n  // General iterable\n  for (const item of coll) {\n    return item;\n  }\n  return undefined;\n}\n\n/**\n * Returns a sequence of all but the first element\n *\n * @param {Iterable|null|undefined} coll - Any iterable collection\n * @returns {LazySeq} Lazy sequence of remaining elements\n *\n * @example\n * rest([1, 2, 3])  // → [2, 3]\n * rest([1])        // → []\n * rest([])         // → []\n * rest(null)       // → []\n */\nexport function rest(coll) {\n  if (coll == null) return SEQ_EMPTY;\n\n  // SEQ protocol (foundation Cons/LazySeq): use rest() method\n  if (coll[SEQ]) {\n    return coll.rest();\n  }\n\n  // Array fast path: O(1) ArraySeq instead of O(n) generator\n  if (Array.isArray(coll)) {\n    if (coll.length <= 1) return SEQ_EMPTY;\n    return new ArraySeq(coll, 1);  // O(1) count/nth operations\n  }\n\n  // Generic path: delegate to seq() to maintain optimized structure\n  // This prevents re-wrapping in a new generator (O(N^2) fix)\n  const s = seq(coll);\n  return s ? s.rest() : SEQ_EMPTY;\n}\n\n/**\n * Returns a new sequence with element prepended\n *\n * DRY: Delegates to concat() for simplicity and consistency.\n * Functionally equivalent to yielding item then iterating coll.\n *\n * @param {*} item - Element to prepend\n * @param {Iterable|null|undefined} coll - Collection to prepend to\n * @returns {LazySeq} New lazy sequence with item first\n *\n * @example\n * cons(0, [1, 2, 3])  // → [0, 1, 2, 3]\n * cons(1, [])         // → [1]\n * cons(1, null)       // → [1]\n */\nexport function cons(item, coll) {\n  // Use foundation's Cons cell for proper trampolining\n  // This enables stack-safe deeply nested lazy sequences\n  return seqCons(item, coll);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// SEQUENCE GENERATORS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Creates a lazy range using JavaScript generators\n * Clojure-compatible semantics:\n *\n * range()          → 0, 1, 2, 3... ∞     (infinite from 0)\n * range(end)       → 0, 1, 2... end-1    (finite to end)\n * range(start,end) → start... end-1      (finite range)\n * range(start,end,step) → start... end-1 by step\n *\n * @param {number} [start] - Starting value\n * @param {number} [end] - Ending value (exclusive)\n * @param {number} [step=1] - Step size\n * @returns {LazySeq} Lazy sequence of numbers\n */\nexport function range(start, end, step = 1) {\n  validateNonZeroNumber(step, \"range\", \"step\");\n\n  // No arguments → infinite sequence from 0\n  if (start === undefined) {\n    return rangeCore(0, undefined, step);\n  }\n\n  // Validate start - must be finite number\n  validateFiniteNumber(start, \"range\", \"start\");\n\n  // One argument → range from 0 to start\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  } else {\n    // Validate end if provided - allow Infinity for infinite sequences\n    if (typeof end !== \"number\") {\n      throw new TypeError(`range: end must be a number, got ${typeof end}`);\n    }\n  }\n\n  // Use shared core implementation (no duplication!)\n  return rangeCore(start, end, step);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// UTILITIES\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Groups collection elements by function result\n *\n * @param {Function} f - Grouping function\n * @param {Iterable|null|undefined} coll - Collection to group\n * @returns {Map} Map with grouped elements (keys preserve their types)\n */\nexport function groupBy(f, coll) {\n  validateFunction(f, \"groupBy\", \"key function\");\n\n  if (coll == null) return new Map();\n\n  const result = new Map();\n  for (const item of coll) {\n    const key = f(item); // ✅ Preserve key type (no String conversion)\n    if (!result.has(key)) {\n      result.set(key, []);\n    }\n    result.get(key).push(item);\n  }\n  return result;\n}\n\n/**\n * Checks if a LazySeq or Delay has been fully realized\n *\n * @param {*} coll - Collection or Delay to check\n * @returns {boolean} True if fully realized\n */\nexport function realized(coll) {\n  if (coll == null) return true;\n  // Delay (explicit laziness)\n  if (coll instanceof Delay) {\n    return coll._realized;\n  }\n  // LazySeq (thunk-based, from seq-protocol.js)\n  if (coll instanceof LazySeq) {\n    return coll._isRealized;\n  }\n  return true; // Non-lazy collections are always realized\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// SEQ - Sequence Abstraction (Bootstrap Primitive)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// NOTE: iteratorSeq is imported from seq-protocol.js (DRY)\n\n/**\n * Convert any collection to a lazy sequence, or return null for empty/nil\n *\n * Critical behavior: Empty collections return null (not empty LazySeq).\n * This enables idiomatic nil-punning: `if (seq(coll)) { ... }`\n *\n * @param {*} coll - Collection to convert to sequence\n * @returns {LazySeq|null} Lazy sequence or null if empty/nil\n *\n * @example\n * seq([1, 2, 3])           // => LazySeq([1, 2, 3])\n * seq([])                  // => null (empty!)\n * seq(null)                // => null\n * seq(\"abc\")               // => LazySeq([\"a\", \"b\", \"c\"])\n * seq(new Set([1,2]))      // => LazySeq([1, 2])\n * seq({a: 1, b: 2})        // => LazySeq([[\"a\", 1], [\"b\", 2]])\n */\nexport function seq(coll) {\n  // Nil input → null\n  if (coll == null) return null;\n\n  // SEQ protocol (foundation Cons/LazySeq): use seq() method for nil-punning\n  if (coll[SEQ]) {\n    return coll.seq();\n  }\n\n  // Array: O(1) ArraySeq instead of O(n) generator\n  if (Array.isArray(coll)) {\n    return coll.length === 0 ? null : new ArraySeq(coll, 0);\n  }\n\n  // String: O(1) ArraySeq (treat string as array of chars)\n  if (typeof coll === \"string\") {\n    return coll.length === 0 ? null : new ArraySeq(coll, 0);\n  }\n\n  // Set: check if empty\n  if (coll instanceof Set) {\n    return coll.size === 0 ? null : iteratorSeq(coll[Symbol.iterator]());\n  }\n\n  // Map: check if empty, yield entries\n  if (coll instanceof Map) {\n    return coll.size === 0 ? null : iteratorSeq(coll[Symbol.iterator]());\n  }\n\n  // Generic iterable (generators, custom iterables): wrap in Cons chain\n  if (typeof coll[Symbol.iterator] === \"function\") {\n    return iteratorSeq(coll[Symbol.iterator]());\n  }\n\n  // Plain object: check if empty, yield [key, value] entries\n  if (typeof coll === \"object\") {\n    const entries = Object.entries(coll);\n    return entries.length === 0 ? null : iteratorSeq(entries[Symbol.iterator]());\n  }\n\n  throw new TypeError(`seq: Cannot create sequence from ${typeof coll}`);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// RUNTIME HELPERS (used by transpiled code)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Get a property from an object, or call a function with the key.\n * Used by transpiler for property access and function calls.\n */\nexport function __hql_get(obj, key, defaultValue) {\n  if (obj && typeof obj[key] !== \"undefined\") {\n    return obj[key];\n  }\n  if (typeof obj === \"function\") {\n    const fnResult = obj(key);\n    if (typeof fnResult !== \"undefined\") {\n      return fnResult;\n    }\n  }\n  return defaultValue;\n}\n\n// Alias for numeric property access\nexport const __hql_getNumeric = __hql_get;\n\n/**\n * Runtime helper for range generation (used by macros).\n * More lenient than the public range() function.\n */\nexport function __hql_range(...args) {\n  let start;\n  let end;\n  let step = 1;\n\n  // Parse arguments\n  if (args.length === 0) {\n    // No arguments → infinite sequence from 0\n    start = 0;\n    end = undefined;\n  } else if (args.length === 1) {\n    // One argument → range from 0 to args[0]\n    start = 0;\n    end = args[0];\n  } else if (args.length === 2) {\n    // Two arguments → range from start to end\n    [start, end] = args;\n  } else {\n    // Three or more arguments → range from start to end with step\n    [start, end, step] = args;\n  }\n\n  // Validate step\n  if (typeof step !== \"number\" || step === 0) {\n    step = 1;\n  }\n\n  // Validate start and end\n  if (typeof start !== \"number\" || (end !== undefined && typeof end !== \"number\")) {\n    return lazySeq(function* () {\n      // Empty sequence\n    });\n  }\n\n  // Use shared core implementation\n  return rangeCore(start, end, step);\n}\n\n/**\n * Convert a value to a sequence (array).\n */\nexport function __hql_toSequence(value) {\n  if (value == null) return [];  // nil-punning: null or undefined → empty array\n  if (Array.isArray(value)) return value;\n  if (typeof value === \"number\") {\n    const result = [];\n    const step = value >= 0 ? 1 : -1;\n    for (let i = 0; step > 0 ? i < value : i > value; i += step) {\n      result.push(i);\n    }\n    return result;\n  }\n  if (typeof value === \"string\") return value.split(\"\");\n  if (value && typeof value[Symbol.iterator] === \"function\") {\n    return [...value];\n  }\n  return [value];\n}\n\n/**\n * For-each iteration helper.\n */\nexport function __hql_for_each(sequence, iteratee) {\n  const list = Array.isArray(sequence) ? sequence : __hql_toSequence(sequence);\n  for (let index = 0; index < list.length; index++) {\n    iteratee(list[index], index);\n  }\n  return null;\n}\n\n/**\n * Create a hash map (plain object) from key-value pairs.\n */\nexport function __hql_hash_map(...entries) {\n  const result = Object.create(null);\n  const limit = entries.length - (entries.length % 2);\n  for (let i = 0; i < limit; i += 2) {\n    result[String(entries[i])] = entries[i + 1];\n  }\n  return result;\n}\n\n/**\n * Throw an error with the given value.\n */\nexport function __hql_throw(value) {\n  throw value instanceof Error ? value : new Error(String(value));\n}\n\n/**\n * Deep freeze an object to make it immutable.\n */\nexport function __hql_deepFreeze(obj) {\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (Object.isFrozen(obj)) {\n    return obj;\n  }\n  Object.freeze(obj);\n  if (Array.isArray(obj)) {\n    for (const item of obj) {\n      __hql_deepFreeze(item);\n    }\n  } else {\n    for (const value of Object.values(obj)) {\n      __hql_deepFreeze(value);\n    }\n  }\n  return obj;\n}\n\n/**\n * Trampoline for mutual recursion TCO.\n * Executes thunks until a non-function value is returned.\n *\n * @param {function} thunk - Initial thunk to execute\n * @returns {*} Final non-function result\n *\n * @example\n * const is_even = (n) => n === 0 ? true : () => is_odd(n - 1);\n * const is_odd = (n) => n === 0 ? false : () => is_even(n - 1);\n * __hql_trampoline(() => is_even(10000)) // → true (no stack overflow)\n */\nexport function __hql_trampoline(thunk) {\n  let result = thunk();\n  while (typeof result === \"function\") {\n    result = result();\n  }\n  return result;\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// FIRST-CLASS OPERATORS (single source of truth)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// Operators can be passed as first-class values to HOFs:\n// (reduce + 0 [1 2 3]) => __hql_get_op(\"+\") returns the + function\n// (map * [1 2 3] [4 5 6]) => __hql_get_op(\"*\") returns the * function\n\nconst __HQL_OPERATORS = {\n  // Arithmetic - variadic versions for use with apply/reduce\n  \"+\": (...nums) => {\n    let sum = 0;\n    for (const n of nums) sum += n;\n    return sum;\n  },\n  \"-\": (...nums) => {\n    if (nums.length === 0) return 0;\n    if (nums.length === 1) return -nums[0];\n    let result = nums[0];\n    for (let i = 1; i < nums.length; i++) result -= nums[i];\n    return result;\n  },\n  \"*\": (...nums) => {\n    let product = 1;\n    for (const n of nums) product *= n;\n    return product;\n  },\n  \"/\": (...nums) => {\n    if (nums.length === 0) return 1;\n    if (nums.length === 1) return 1 / nums[0];\n    let result = nums[0];\n    for (let i = 1; i < nums.length; i++) result /= nums[i];\n    return result;\n  },\n  \"%\": (a, b) => a % b,\n  \"**\": (a, b) => a ** b,\n\n  // Comparison\n  \"===\": (a, b) => a === b,\n  \"==\": (a, b) => a == b,\n  \"!==\": (a, b) => a !== b,\n  \"!=\": (a, b) => a != b,\n  \"<\": (a, b) => a < b,\n  \">\": (a, b) => a > b,\n  \"<=\": (a, b) => a <= b,\n  \">=\": (a, b) => a >= b,\n\n  // Logical\n  \"&&\": (a, b) => a && b,\n  \"||\": (a, b) => a || b,\n  \"!\": (a) => !a,\n\n  // Bitwise\n  \"~\": (a) => ~a,\n  \"&\": (a, b) => a & b,\n  \"|\": (a, b) => a | b,\n  \"^\": (a, b) => a ^ b,\n  \"<<\": (a, b) => a << b,\n  \">>\": (a, b) => a >> b,\n  \">>>\": (a, b) => a >>> b,\n};\n\n/**\n * Get an operator function by its symbol.\n * This is the single source of truth for all operator-as-value usage.\n * @param {string} op - The operator symbol (e.g., \"+\", \"-\", \"*\")\n * @returns {Function} The function that implements the operator\n */\nexport function __hql_get_op(op) {\n  const fn = __HQL_OPERATORS[op];\n  if (!fn) {\n    throw new Error(`Unknown operator: ${op}`);\n  }\n  return fn;\n}\n\n// Export lazySeq for creating custom lazy sequences\nexport { seqLazySeq as lazySeq };\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// DELAY/FORCE - Explicit laziness primitives\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Creates a Delay - a memoized thunk for explicit lazy evaluation.\n * The thunk is called at most once, and the result is cached.\n *\n * Unlike lazy sequences which represent collections, Delay is for\n * single deferred values that should be computed only when needed.\n *\n * @param {Function} thunk - Zero-arg function returning the delayed value\n * @returns {Delay} Delay object\n */\nexport const delay = seqDelay;\n\n/**\n * Forces evaluation of a Delay, or returns the value unchanged if not a Delay.\n *\n * @param {*} x - A Delay or any other value\n * @returns {*} The realized value\n */\nexport const force = seqForce;\n\n/**\n * Check if a value is a Delay.\n *\n * @param {*} x - Value to check\n * @returns {boolean} True if x is a Delay\n */\nexport const isDelay = seqIsDelay;\n\n/**\n * Internal function to create a Delay (for HQL delay macro).\n */\nexport function __hql_delay(thunk) {\n  return seqDelay(thunk);\n}\n\n// Export NumericRange for advanced users\nexport { NumericRange };\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// TRANSDUCERS - Composable algorithmic transformations\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n// Export transducer infrastructure\nexport const reduced = seqReduced;\nexport const isReduced = seqIsReduced;\nexport const unreduced = seqUnreduced;\nexport const ensureReduced = seqEnsureReduced;\nexport const toTransformer = seqToTransformer;\nexport const completing = seqCompleting;\n\n// Re-export protocol keys for advanced users\nexport { TRANSDUCER_INIT, TRANSDUCER_STEP, TRANSDUCER_RESULT };\n\n/**\n * transduce - Apply a transducer to a collection with a reducing function.\n *\n * A transducer is a function that takes a reducing function (rf) and\n * returns a new reducing function. Transducers allow composable, reusable\n * transformations that are independent of the source/destination.\n *\n * 3-arity: (transduce xform rf coll) - uses rf() for initial value\n * 4-arity: (transduce xform rf init coll) - explicit initial value\n *\n * @param {Function} xform - Transducer function\n * @param {Function|Object} rf - Reducing function or transformer\n * @param {*} initOrColl - Initial value (4-arity) or collection (3-arity)\n * @param {Iterable} [maybeColl] - Collection (4-arity only)\n * @returns {*} Reduced result\n */\nexport function transduce(xform, rf, initOrColl, maybeColl) {\n  let init, coll;\n\n  if (maybeColl === undefined) {\n    // 3-arity: (transduce xform rf coll)\n    coll = initOrColl;\n    const transformer = seqToTransformer(rf);\n    init = transformer[TRANSDUCER_INIT]();\n  } else {\n    // 4-arity: (transduce xform rf init coll)\n    init = initOrColl;\n    coll = maybeColl;\n  }\n\n  const xrf = xform(seqToTransformer(rf));\n  let acc = init;\n\n  for (const item of coll) {\n    acc = xrf[TRANSDUCER_STEP](acc, item);\n    if (seqIsReduced(acc)) {\n      acc = seqUnreduced(acc);\n      break;\n    }\n  }\n\n  return xrf[TRANSDUCER_RESULT](acc);\n}\n\n/**\n * into - Pour collection through optional transducer into target.\n *\n * 2-arity: (into to from) - No transducer, just conj\n * 3-arity: (into to xform from) - Apply transducer\n *\n * @param {Array|Set|Map} to - Target collection\n * @param {Function|Iterable} xformOrFrom - Transducer (3-arity) or source (2-arity)\n * @param {Iterable} [from] - Source collection (3-arity only)\n * @returns {*} Target collection with added elements\n */\nexport function intoXform(to, xformOrFrom, from) {\n  // Determine the conj function based on target type\n  const conjFn = (acc, x) => {\n    if (Array.isArray(acc)) {\n      acc.push(x);\n      return acc;\n    }\n    if (acc instanceof Set) {\n      acc.add(x);\n      return acc;\n    }\n    if (acc instanceof Map && Array.isArray(x) && x.length === 2) {\n      acc.set(x[0], x[1]);\n      return acc;\n    }\n    // Default: treat as array-like\n    acc.push(x);\n    return acc;\n  };\n\n  if (from === undefined) {\n    // 2-arity: (into to from) - just reduce with conj\n    for (const item of xformOrFrom) {\n      conjFn(to, item);\n    }\n    return to;\n  }\n\n  // 3-arity: (into to xform from)\n  const xform = xformOrFrom;\n  const rf = {\n    [TRANSDUCER_INIT]: () => to,\n    [TRANSDUCER_STEP]: conjFn,\n    [TRANSDUCER_RESULT]: (acc) => acc,\n  };\n\n  return transduce(xform, rf, to, from);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// CHUNKED SEQUENCES - 32-element batch processing (like Clojure)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n// Export chunk size constant\nexport { CHUNK_SIZE };\n\n// Export chunk classes for advanced users\nexport { ArrayChunk, ChunkBuffer, ChunkedCons };\n\n/**\n * Create a ChunkedCons from a chunk and lazy rest.\n *\n * @param {ArrayChunk} chunk - The chunk of elements\n * @param {LazySeq|null} rest - Lazy rest of the sequence\n * @returns {ChunkedCons} Chunked sequence cell\n */\nexport const chunkCons = seqChunkCons;\n\n/**\n * Create an ArrayChunk from an array (or slice).\n *\n * @param {Array} arr - Source array\n * @param {number} [off=0] - Start offset\n * @param {number} [end=arr.length] - End offset\n * @returns {ArrayChunk} Immutable chunk\n */\nexport const arrayChunk = seqArrayChunk;\n\n/**\n * Check if a sequence supports chunked iteration.\n *\n * @param {*} x - Value to check\n * @returns {boolean} True if chunked\n */\nexport const isChunked = seqIsChunked;\n\n/**\n * Get the first chunk from a chunked sequence.\n *\n * @param {ChunkedCons} s - Chunked sequence\n * @returns {ArrayChunk|null} First chunk, or null if empty\n */\nexport const chunkFirst = seqChunkFirst;\n\n/**\n * Get the rest after the first chunk.\n *\n * @param {ChunkedCons} s - Chunked sequence\n * @returns {LazySeq|EMPTY} Rest of sequence\n */\nexport const chunkRest = seqChunkRest;\n\n/**\n * Convert collection to chunked sequence if beneficial.\n *\n * Arrays and NumericRanges are chunked for efficient map/filter.\n * Other sequences pass through unchanged.\n *\n * @param {Iterable|null} coll - Collection to chunk\n * @returns {ChunkedCons|Seq|null} Chunked or normal sequence\n */\nexport const toChunkedSeq = seqToChunkedSeq;\n\n/**\n * Chunked map - map preserving chunk boundaries.\n *\n * When the input is a chunked sequence, the output preserves\n * 32-element chunks for better performance.\n *\n * @param {Function} f - Mapping function\n * @param {Iterable} coll - Collection to map over\n * @returns {ChunkedCons|LazySeq} Chunked or lazy sequence\n */\nexport function chunkedMap(f, coll) {\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  if (seqIsChunked(s)) {\n    return chunkedLazySeq(() => {\n      const chunk = s.chunkFirst();\n      const mapped = chunk.toArray().map(f);\n      const newChunk = seqArrayChunk(mapped);\n      const rest = s.chunkRest();\n      if (isSeqEnd(rest)) {\n        return seqChunkCons(newChunk, null);\n      }\n      return seqChunkCons(newChunk, chunkedLazySeq(() => chunkedMap(f, rest)));\n    });\n  }\n\n  // Fall back to element-wise for non-chunked\n  return seqLazySeq(() => {\n    const fst = s.first?.();\n    if (fst === undefined && !s.seq?.()) return null;\n    return seqCons(f(fst), seqLazySeq(() => chunkedMap(f, s.rest?.())));\n  });\n}\n\n/**\n * Chunked filter - filter preserving chunks where possible.\n *\n * @param {Function} pred - Predicate function\n * @param {Iterable} coll - Collection to filter\n * @returns {LazySeq} Lazy sequence of matching elements\n */\nexport function chunkedFilter(pred, coll) {\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  if (seqIsChunked(s)) {\n    return chunkedLazySeq(() => {\n      const chunk = s.chunkFirst();\n      const filtered = chunk.toArray().filter(pred);\n      const rest = s.chunkRest();\n\n      // Create new chunk if we have filtered elements\n      if (filtered.length > 0) {\n        const newChunk = seqArrayChunk(filtered);\n        if (isSeqEnd(rest)) {\n          return seqChunkCons(newChunk, null);\n        }\n        return seqChunkCons(newChunk, chunkedLazySeq(() => chunkedFilter(pred, rest)));\n      }\n\n      // No matches in this chunk, continue to rest\n      if (isSeqEnd(rest)) return null;\n      return chunkedFilter(pred, rest);\n    });\n  }\n\n  // Fall back for non-chunked\n  return seqLazySeq(function filterStep() {\n    let current = s;\n    while (isActiveSeq(current)) {\n      const fst = current.first();\n      if (pred(fst)) {\n        return seqCons(fst, seqLazySeq(() => chunkedFilter(pred, current.rest())));\n      }\n      current = current.rest();\n    }\n    return null;\n  });\n}\n\n/**\n * Chunked reduce - reduce with chunk-aware batching.\n *\n * When the input is chunked, reduces each chunk efficiently\n * before moving to the next.\n *\n * @param {Function} f - Reducing function (acc, x) => acc\n * @param {*} init - Initial accumulator value\n * @param {Iterable} coll - Collection to reduce\n * @returns {*} Reduced result\n */\nexport function chunkedReduce(f, init, coll) {\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return init;\n\n  let acc = init;\n\n  if (seqIsChunked(s)) {\n    let current = s;\n    while (isActiveSeq(current)) {\n      const chunk = current.chunkFirst();\n      // Reduce within chunk\n      acc = chunk.reduce(f, acc);\n      if (seqIsReduced(acc)) return seqUnreduced(acc);\n      current = maybeRealize(current.chunkRest());\n    }\n    return acc;\n  }\n\n  // Fall back for non-chunked\n  let current = s;\n  while (isActiveSeq(current)) {\n    acc = f(acc, current.first());\n    if (seqIsReduced(acc)) return seqUnreduced(acc);\n    current = current.rest();\n  }\n  return acc;\n}\n\n/**\n * Chunked take - take first n elements preserving chunks.\n *\n * @param {number} n - Number of elements to take\n * @param {Iterable} coll - Collection to take from\n * @returns {LazySeq} Lazy sequence of first n elements\n */\nexport function chunkedTake(n, coll) {\n  if (n <= 0) return null;\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  if (seqIsChunked(s)) {\n    return chunkedLazySeq(() => {\n      const chunk = s.chunkFirst();\n      const arr = chunk.toArray();\n\n      if (arr.length <= n) {\n        // Take whole chunk, continue with rest\n        const rest = s.chunkRest();\n        if (isSeqEnd(rest)) {\n          return seqChunkCons(chunk, null);\n        }\n        return seqChunkCons(chunk, chunkedLazySeq(() => chunkedTake(n - arr.length, rest)));\n      } else {\n        // Take partial chunk\n        const taken = arr.slice(0, n);\n        return seqChunkCons(seqArrayChunk(taken), null);\n      }\n    });\n  }\n\n  // Fall back for non-chunked\n  return seqLazySeq(() => {\n    const fst = s.first?.();\n    if (fst === undefined && !s.seq?.()) return null;\n    return seqCons(fst, seqLazySeq(() => chunkedTake(n - 1, s.rest?.())));\n  });\n}\n\n/**\n * Chunked drop - drop first n elements preserving chunks.\n *\n * @param {number} n - Number of elements to drop\n * @param {Iterable} coll - Collection to drop from\n * @returns {LazySeq} Lazy sequence after dropping n elements\n */\nexport function chunkedDrop(n, coll) {\n  if (n <= 0) return seqToChunkedSeq(coll);\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  if (seqIsChunked(s)) {\n    return chunkedLazySeq(() => {\n      let current = s;\n      let remaining = n;\n\n      // Skip whole chunks\n      while (isActiveSeq(current)) {\n        const chunk = current.chunkFirst();\n        const arr = chunk.toArray();\n\n        if (arr.length <= remaining) {\n          remaining -= arr.length;\n          current = maybeRealize(current.chunkRest());\n        } else {\n          // Drop partial chunk\n          const kept = arr.slice(remaining);\n          const rest = current.chunkRest();\n          if (isSeqEnd(rest)) {\n            return seqChunkCons(seqArrayChunk(kept), null);\n          }\n          return seqChunkCons(seqArrayChunk(kept), rest);\n        }\n      }\n      return null;\n    });\n  }\n\n  // Fall back for non-chunked\n  return seqLazySeq(() => {\n    let current = s;\n    let remaining = n;\n    while (remaining > 0 && isActiveSeq(current)) {\n      current = current.rest?.();\n      remaining--;\n    }\n    return current;\n  });\n}\n\n/**\n * Chunked takeWhile - take elements while predicate holds, preserving chunks.\n *\n * @param {Function} pred - Predicate function\n * @param {Iterable} coll - Collection\n * @returns {LazySeq} Lazy sequence of elements while pred is true\n */\nexport function chunkedTakeWhile(pred, coll) {\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  if (seqIsChunked(s)) {\n    return chunkedLazySeq(() => {\n      const chunk = s.chunkFirst();\n      const arr = chunk.toArray();\n\n      // Find first element that fails predicate\n      let takeCount = 0;\n      for (let i = 0; i < arr.length; i++) {\n        if (pred(arr[i])) {\n          takeCount++;\n        } else {\n          break;\n        }\n      }\n\n      if (takeCount === 0) {\n        return null; // First element failed\n      }\n\n      if (takeCount === arr.length) {\n        // Whole chunk passes, continue with rest\n        const rest = s.chunkRest();\n        if (isSeqEnd(rest)) {\n          return seqChunkCons(chunk, null);\n        }\n        return seqChunkCons(chunk, chunkedLazySeq(() => chunkedTakeWhile(pred, rest)));\n      } else {\n        // Partial chunk\n        const taken = arr.slice(0, takeCount);\n        return seqChunkCons(seqArrayChunk(taken), null);\n      }\n    });\n  }\n\n  // Fall back for non-chunked\n  return seqLazySeq(() => {\n    const fst = s.first?.();\n    if (fst === undefined && !s.seq?.()) return null;\n    if (!pred(fst)) return null;\n    return seqCons(fst, seqLazySeq(() => chunkedTakeWhile(pred, s.rest?.())));\n  });\n}\n\n/**\n * Chunked dropWhile - drop elements while predicate holds, preserving chunks.\n *\n * @param {Function} pred - Predicate function\n * @param {Iterable} coll - Collection\n * @returns {LazySeq} Lazy sequence after dropping while pred is true\n */\nexport function chunkedDropWhile(pred, coll) {\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  if (seqIsChunked(s)) {\n    return chunkedLazySeq(() => {\n      let current = s;\n\n      while (isActiveSeq(current)) {\n        const chunk = current.chunkFirst();\n        const arr = chunk.toArray();\n\n        // Find first element that fails predicate\n        let dropCount = 0;\n        for (let i = 0; i < arr.length; i++) {\n          if (pred(arr[i])) {\n            dropCount++;\n          } else {\n            break;\n          }\n        }\n\n        if (dropCount === 0) {\n          // First element fails pred, return current chunked seq\n          return current;\n        }\n\n        if (dropCount < arr.length) {\n          // Partial chunk - keep the rest\n          const kept = arr.slice(dropCount);\n          const rest = current.chunkRest();\n          if (isSeqEnd(rest)) {\n            return seqChunkCons(seqArrayChunk(kept), null);\n          }\n          return seqChunkCons(seqArrayChunk(kept), rest);\n        }\n\n        // Whole chunk dropped, continue with rest\n        current = maybeRealize(current.chunkRest());\n      }\n      return null;\n    });\n  }\n\n  // Fall back for non-chunked\n  return seqLazySeq(() => {\n    let current = s;\n    while (isActiveSeq(current)) {\n      const fst = current.first();\n      if (!pred(fst)) return current;\n      current = current.rest?.();\n    }\n    return null;\n  });\n}\n\n/**\n * Chunked concat - concatenate collections preserving chunks.\n *\n * @param {...Iterable} colls - Collections to concatenate\n * @returns {LazySeq} Lazy sequence of concatenated elements\n */\nexport function chunkedConcat(...colls) {\n  if (colls.length === 0) return chunkedLazySeq(() => null);\n\n  function concatSeqs(seqs) {\n    if (seqs.length === 0) return null;\n\n    const first = seqToChunkedSeq(seqs[0]);\n    if (first == null) {\n      return concatSeqs(seqs.slice(1));\n    }\n\n    if (seqIsChunked(first)) {\n      return chunkedLazySeq(() => {\n        const chunk = first.chunkFirst();\n        const rest = first.chunkRest();\n\n        if (isSeqEnd(rest)) {\n          // Move to next collection\n          const nextConcat = concatSeqs(seqs.slice(1));\n          if (nextConcat == null) {\n            return seqChunkCons(chunk, null);\n          }\n          return seqChunkCons(chunk, nextConcat);\n        }\n        return seqChunkCons(chunk, chunkedLazySeq(() => {\n          const restResult = concatSeqs([rest, ...seqs.slice(1)]);\n          return restResult;\n        }));\n      });\n    }\n\n    // Non-chunked first collection\n    return seqLazySeq(() => {\n      const fst = first.first?.();\n      if (fst === undefined && !first.seq?.()) {\n        return concatSeqs(seqs.slice(1));\n      }\n      const restFirst = first.rest?.();\n      return seqCons(fst, seqLazySeq(() => concatSeqs([restFirst, ...seqs.slice(1)])));\n    });\n  }\n\n  // Always wrap in chunkedLazySeq so caller can safely call .seq()\n  return chunkedLazySeq(() => concatSeqs(colls));\n}\n\n/**\n * Chunked distinct - remove duplicates preserving chunks where possible.\n *\n * @param {Iterable} coll - Collection\n * @returns {LazySeq} Lazy sequence of unique elements\n */\nexport function chunkedDistinct(coll) {\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  const seen = new Set();\n\n  function distinctStep(current) {\n    if (!isActiveSeq(current)) return null;\n\n    if (seqIsChunked(current)) {\n      const chunk = current.chunkFirst();\n      const arr = chunk.toArray();\n      const unique = [];\n\n      for (const x of arr) {\n        if (!seen.has(x)) {\n          seen.add(x);\n          unique.push(x);\n        }\n      }\n\n      const rest = maybeRealize(current.chunkRest());\n      if (unique.length > 0) {\n        if (isSeqEnd(rest)) {\n          return seqChunkCons(seqArrayChunk(unique), null);\n        }\n        return seqChunkCons(seqArrayChunk(unique), chunkedLazySeq(() => distinctStep(rest)));\n      }\n      return distinctStep(rest);\n    }\n\n    // Non-chunked\n    const fst = current.first();\n    if (!seen.has(fst)) {\n      seen.add(fst);\n      return seqCons(fst, seqLazySeq(() => distinctStep(current.rest?.())));\n    }\n    return distinctStep(current.rest?.());\n  }\n\n  return chunkedLazySeq(() => distinctStep(s));\n}\n\n/**\n * Chunked mapIndexed - map with index preserving chunks.\n *\n * @param {Function} f - Function (index, element) => result\n * @param {Iterable} coll - Collection\n * @returns {LazySeq} Lazy sequence of mapped elements\n */\nexport function chunkedMapIndexed(f, coll) {\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  let idx = 0;\n\n  function mapIndexedStep(current) {\n    if (!isActiveSeq(current)) return null;\n\n    if (seqIsChunked(current)) {\n      const chunk = current.chunkFirst();\n      const arr = chunk.toArray();\n      const mapped = arr.map((x) => f(idx++, x));\n      const rest = maybeRealize(current.chunkRest());\n      if (isSeqEnd(rest)) {\n        return seqChunkCons(seqArrayChunk(mapped), null);\n      }\n      return seqChunkCons(seqArrayChunk(mapped), chunkedLazySeq(() => mapIndexedStep(rest)));\n    }\n\n    // Non-chunked\n    const fst = current.first();\n    const mapped = f(idx++, fst);\n    return seqCons(mapped, seqLazySeq(() => mapIndexedStep(current.rest?.())));\n  }\n\n  return chunkedLazySeq(() => mapIndexedStep(s));\n}\n\n/**\n * Chunked keep - like filter but uses function result, preserving chunks.\n *\n * @param {Function} f - Function that returns value or null/undefined\n * @param {Iterable} coll - Collection\n * @returns {LazySeq} Lazy sequence of non-nil results\n */\nexport function chunkedKeep(f, coll) {\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  if (seqIsChunked(s)) {\n    return chunkedLazySeq(() => {\n      const chunk = s.chunkFirst();\n      const arr = chunk.toArray();\n      const kept = [];\n\n      for (const x of arr) {\n        const result = f(x);\n        if (result != null) {\n          kept.push(result);\n        }\n      }\n\n      const rest = s.chunkRest();\n\n      if (kept.length > 0) {\n        if (isSeqEnd(rest)) {\n          return seqChunkCons(seqArrayChunk(kept), null);\n        }\n        return seqChunkCons(seqArrayChunk(kept), chunkedLazySeq(() => chunkedKeep(f, rest)));\n      }\n\n      if (isSeqEnd(rest)) return null;\n      return chunkedKeep(f, rest);\n    });\n  }\n\n  // Fall back for non-chunked\n  return seqLazySeq(function keepStep() {\n    let current = s;\n    while (isActiveSeq(current)) {\n      const fst = current.first();\n      const result = f(fst);\n      if (result != null) {\n        return seqCons(result, seqLazySeq(() => chunkedKeep(f, current.rest())));\n      }\n      current = current.rest();\n    }\n    return null;\n  });\n}\n\n/**\n * Chunked mapcat - map then concatenate, preserving chunks where possible.\n *\n * @param {Function} f - Function that returns a collection\n * @param {Iterable} coll - Collection\n * @returns {LazySeq} Lazy sequence of concatenated results\n */\nexport function chunkedMapcat(f, coll) {\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  function mapcatStep(current, pendingResults) {\n    // First exhaust pending results from previous f(x) calls\n    if (pendingResults && pendingResults.length > 0) {\n      const first = pendingResults[0];\n      const restPending = pendingResults.slice(1);\n      const firstSeq = seqToChunkedSeq(first);\n\n      if (firstSeq == null) {\n        return mapcatStep(current, restPending);\n      }\n\n      if (seqIsChunked(firstSeq)) {\n        const chunk = firstSeq.chunkFirst();\n        const rest = firstSeq.chunkRest();\n        const newPending = !isSeqEnd(rest) ? [rest, ...restPending] : restPending;\n        return seqChunkCons(chunk, chunkedLazySeq(() => mapcatStep(current, newPending)));\n      }\n\n      // Non-chunked result\n      const fst = firstSeq.first?.();\n      if (fst === undefined && !firstSeq.seq?.()) {\n        return mapcatStep(current, restPending);\n      }\n      const restFirst = firstSeq.rest?.();\n      const newPending = restFirst ? [restFirst, ...restPending] : restPending;\n      return seqCons(fst, seqLazySeq(() => mapcatStep(current, newPending)));\n    }\n\n    // No pending, get next from source\n    if (!isActiveSeq(current)) return null;\n\n    if (seqIsChunked(current)) {\n      const chunk = current.chunkFirst();\n      const arr = chunk.toArray();\n      const results = arr.map(f);\n      const rest = maybeRealize(current.chunkRest());\n      return mapcatStep(rest, results);\n    }\n\n    // Non-chunked source\n    const fst = current.first();\n    const result = f(fst);\n    return mapcatStep(current.rest?.(), [result]);\n  }\n\n  return chunkedLazySeq(() => mapcatStep(s, []));\n}\n\n/**\n * Chunked partition - partition into groups of n, preserving chunks.\n *\n * @param {number} n - Partition size\n * @param {Iterable} coll - Collection\n * @returns {LazySeq} Lazy sequence of arrays of size n\n */\nexport function chunkedPartition(n, coll) {\n  if (n <= 0) return null;\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  function partitionStep(current, buffer) {\n    if (!isActiveSeq(current)) {\n      // Return final partition if complete\n      if (buffer.length === n) {\n        return seqCons(buffer, null);\n      }\n      return null; // Discard incomplete partition (Clojure behavior)\n    }\n\n    if (seqIsChunked(current)) {\n      const chunk = current.chunkFirst();\n      const arr = chunk.toArray();\n      const results = [];\n      let buf = buffer;\n\n      for (const x of arr) {\n        buf.push(x);\n        if (buf.length === n) {\n          results.push(buf);\n          buf = [];\n        }\n      }\n\n      const rest = maybeRealize(current.chunkRest());\n      if (results.length > 0) {\n        if (isSeqEnd(rest)) {\n          return seqChunkCons(seqArrayChunk(results), null);\n        }\n        return seqChunkCons(seqArrayChunk(results), chunkedLazySeq(() => partitionStep(rest, buf)));\n      }\n      return partitionStep(rest, buf);\n    }\n\n    // Non-chunked\n    const fst = current.first();\n    buffer.push(fst);\n    if (buffer.length === n) {\n      return seqCons(buffer, seqLazySeq(() => partitionStep(current.rest?.(), [])));\n    }\n    return partitionStep(current.rest?.(), buffer);\n  }\n\n  return chunkedLazySeq(() => partitionStep(s, []));\n}\n\n/**\n * Chunked interleave - interleave collections, re-chunking output.\n *\n * @param {...Iterable} colls - Collections to interleave\n * @returns {LazySeq} Lazy sequence of interleaved elements\n */\nexport function chunkedInterleave(...colls) {\n  if (colls.length === 0) return null;\n  if (colls.length === 1) return seqToChunkedSeq(colls[0]);\n\n  const seqs = colls.map(c => seqToChunkedSeq(c));\n  if (seqs.some(s => s == null)) return null;\n\n  function interleaveStep(currents, buffer) {\n    // Check if any sequence is exhausted\n    if (currents.some(c => !isActiveSeq(c))) {\n      // Flush buffer as chunk\n      if (buffer.length > 0) {\n        return seqChunkCons(seqArrayChunk(buffer), null);\n      }\n      return null;\n    }\n\n    // Collect one element from each sequence\n    const newBuffer = [...buffer];\n    const nexts = [];\n\n    for (const curr of currents) {\n      if (seqIsChunked(curr)) {\n        const chunk = curr.chunkFirst();\n        const arr = chunk.toArray();\n        newBuffer.push(arr[0]);\n\n        // Create sequence from rest of chunk + chunkRest\n        if (arr.length > 1) {\n          const restChunk = seqArrayChunk(arr.slice(1));\n          const rest = curr.chunkRest();\n          nexts.push(seqChunkCons(restChunk, rest));\n        } else {\n          nexts.push(maybeRealize(curr.chunkRest()));\n        }\n      } else {\n        newBuffer.push(curr.first());\n        nexts.push(curr.rest?.());\n      }\n    }\n\n    // Emit chunk when buffer is full\n    if (newBuffer.length >= 32) {\n      const chunk = seqArrayChunk(newBuffer.slice(0, 32));\n      const remaining = newBuffer.slice(32);\n      return seqChunkCons(chunk, chunkedLazySeq(() => interleaveStep(nexts, remaining)));\n    }\n\n    return interleaveStep(nexts, newBuffer);\n  }\n\n  return chunkedLazySeq(() => interleaveStep(seqs, []));\n}\n\n/**\n * Chunked interpose - insert separator between elements, re-chunking output.\n *\n * @param {*} sep - Separator to insert\n * @param {Iterable} coll - Collection\n * @returns {LazySeq} Lazy sequence with separators\n */\nexport function chunkedInterpose(sep, coll) {\n  const s = seqToChunkedSeq(coll);\n  if (s == null) return null;\n\n  let isFirst = true;\n\n  function interposeStep(current, buffer) {\n    if (!isActiveSeq(current)) {\n      if (buffer.length > 0) {\n        return seqChunkCons(seqArrayChunk(buffer), null);\n      }\n      return null;\n    }\n\n    if (seqIsChunked(current)) {\n      const chunk = current.chunkFirst();\n      const arr = chunk.toArray();\n      const newBuffer = [...buffer];\n\n      for (const x of arr) {\n        if (!isFirst) {\n          newBuffer.push(sep);\n        }\n        newBuffer.push(x);\n        isFirst = false;\n      }\n\n      const rest = maybeRealize(current.chunkRest());\n\n      // Emit chunks when buffer is large enough\n      if (newBuffer.length >= 32) {\n        const chunk = seqArrayChunk(newBuffer.slice(0, 32));\n        const remaining = newBuffer.slice(32);\n        if (isSeqEnd(rest)) {\n          if (remaining.length > 0) {\n            return seqChunkCons(chunk, seqChunkCons(seqArrayChunk(remaining), null));\n          }\n          return seqChunkCons(chunk, null);\n        }\n        return seqChunkCons(chunk, chunkedLazySeq(() => interposeStep(rest, remaining)));\n      }\n\n      if (isSeqEnd(rest)) {\n        if (newBuffer.length > 0) {\n          return seqChunkCons(seqArrayChunk(newBuffer), null);\n        }\n        return null;\n      }\n      return interposeStep(rest, newBuffer);\n    }\n\n    // Non-chunked\n    const fst = current.first();\n    const newBuffer = [...buffer];\n    if (!isFirst) {\n      newBuffer.push(sep);\n    }\n    newBuffer.push(fst);\n    isFirst = false;\n\n    if (newBuffer.length >= 32) {\n      const chunk = seqArrayChunk(newBuffer.slice(0, 32));\n      const remaining = newBuffer.slice(32);\n      return seqChunkCons(chunk, seqLazySeq(() => interposeStep(current.rest?.(), remaining)));\n    }\n    return interposeStep(current.rest?.(), newBuffer);\n  }\n\n  return chunkedLazySeq(() => interposeStep(s, []));\n}\n\n/**\n * Chunked reductions - like reduce but returns intermediate values, preserving chunks.\n *\n * @param {Function} f - Reducing function\n * @param {*} init - Initial value\n * @param {Iterable} coll - Collection\n * @returns {LazySeq} Lazy sequence of intermediate reduction values\n */\nexport function chunkedReductions(f, init, coll) {\n  const s = seqToChunkedSeq(coll);\n\n  function reductionsStep(current, acc, buffer, includeInit) {\n    const newBuffer = includeInit ? [acc, ...buffer] : [...buffer];\n\n    if (!isActiveSeq(current)) {\n      if (newBuffer.length > 0) {\n        return seqChunkCons(seqArrayChunk(newBuffer), null);\n      }\n      return null;\n    }\n\n    if (seqIsChunked(current)) {\n      const chunk = current.chunkFirst();\n      const arr = chunk.toArray();\n      let currAcc = acc;\n\n      for (const x of arr) {\n        currAcc = f(currAcc, x);\n        if (seqIsReduced(currAcc)) {\n          newBuffer.push(seqUnreduced(currAcc));\n          return seqChunkCons(seqArrayChunk(newBuffer), null);\n        }\n        newBuffer.push(currAcc);\n      }\n\n      const rest = maybeRealize(current.chunkRest());\n\n      // Emit chunk when buffer is large enough\n      if (newBuffer.length >= 32) {\n        const chunk = seqArrayChunk(newBuffer.slice(0, 32));\n        const remaining = newBuffer.slice(32);\n        if (isSeqEnd(rest)) {\n          if (remaining.length > 0) {\n            return seqChunkCons(chunk, seqChunkCons(seqArrayChunk(remaining), null));\n          }\n          return seqChunkCons(chunk, null);\n        }\n        return seqChunkCons(chunk, chunkedLazySeq(() => reductionsStep(rest, currAcc, remaining, false)));\n      }\n\n      if (isSeqEnd(rest)) {\n        if (newBuffer.length > 0) {\n          return seqChunkCons(seqArrayChunk(newBuffer), null);\n        }\n        return null;\n      }\n      return reductionsStep(rest, currAcc, newBuffer, false);\n    }\n\n    // Non-chunked\n    const fst = current.first();\n    const newAcc = f(acc, fst);\n    if (seqIsReduced(newAcc)) {\n      newBuffer.push(seqUnreduced(newAcc));\n      return seqChunkCons(seqArrayChunk(newBuffer), null);\n    }\n    newBuffer.push(newAcc);\n\n    if (newBuffer.length >= 32) {\n      const chunk = seqArrayChunk(newBuffer.slice(0, 32));\n      const remaining = newBuffer.slice(32);\n      return seqChunkCons(chunk, seqLazySeq(() => reductionsStep(current.rest?.(), newAcc, remaining, false)));\n    }\n    return reductionsStep(current.rest?.(), newAcc, newBuffer, false);\n  }\n\n  return chunkedLazySeq(() => reductionsStep(s, init, [], true));\n}\n",
  "@hql/lib/stdlib/js/self-hosted.js": "// self-hosted.js - Pre-transpiled HQL stdlib functions\n// Source of truth: stdlib.hql - this JS is the bootstrap execution form\n\nimport {\n  lazySeq,\n  cons,\n  SEQ,\n  reduced,\n  isReduced,\n  ensureReduced,\n  shouldChunk,  // DRY helper: shouldChunk(coll)\n  TRANSDUCER_INIT,\n  TRANSDUCER_STEP,\n  TRANSDUCER_RESULT,\n} from \"./internal/seq-protocol.js\";\nimport {\n  seq, first, rest,\n  chunkedMap, chunkedFilter, chunkedReduce,\n  chunkedTake, chunkedDrop, chunkedTakeWhile, chunkedDropWhile,\n  chunkedConcat, chunkedDistinct, chunkedMapIndexed, chunkedKeep,\n  chunkedMapcat, chunkedPartition, chunkedInterleave, chunkedInterpose,\n  chunkedReductions,\n} from \"./core.js\";\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 1: CORE SEQUENCE OPERATIONS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** take - Returns first n elements (lazy) */\nexport function take(n, coll) {\n  // Use chunked path for large arrays or already-chunked seqs\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (shouldChunk(coll)) {\n    return chunkedTake(n, coll);\n  }\n\n  return lazySeq(() => {\n    if (n > 0) {\n      const s = seq(coll);\n      if (s != null) {\n        return cons(first(s), take(n - 1, rest(s)));\n      }\n    }\n    return null;\n  });\n}\n\n/** drop - Drops first n elements (lazy) */\nexport function drop(n, coll) {\n  // Use chunked path for large arrays or already-chunked seqs\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (shouldChunk(coll)) {\n    return chunkedDrop(n, coll);\n  }\n\n  return lazySeq(() => {\n    let s = seq(coll);\n    let remaining = n;\n    while (s != null && remaining > 0) {\n      s = next(s);  // Use next() for idiomatic seq traversal\n      remaining--;\n    }\n    // Must return Cons structure for LazySeq protocol\n    if (s != null) {\n      return cons(first(s), drop(0, rest(s)));\n    }\n    return null;\n  });\n}\n\n/**\n * map - Maps function over collection(s) (lazy)\n *\n * Multi-arity support like Clojure:\n * - (map f coll) - single collection\n * - (map f c1 c2) - parallel map over 2 collections\n * - (map f c1 c2 c3 ...) - parallel map over n collections\n *\n * Clojure: (map + [1 2 3] [4 5 6]) => (5 7 9)\n * Clojure: (map vector [1 2] [:a :b]) => ([1 :a] [2 :b])\n */\nexport function map(f, ...colls) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"map: first argument must be a function, got \" + typeof f);\n  }\n\n  if (colls.length === 0) {\n    throw new TypeError(\"map: requires at least one collection\");\n  }\n\n  if (colls.length === 1) {\n    // Single collection\n    const coll = colls[0];\n\n    // Optimization: Use chunked path for large arrays or already-chunked seqs\n    // isChunked now properly detects LazySeq with _isChunkedSource flag\n    if (shouldChunk(coll)) {\n      return chunkedMap(f, coll);\n    }\n\n    // Standard lazy sequence for other cases\n    return lazySeq(() => {\n      const s = seq(coll);\n      if (s != null) {\n        return cons(f(first(s)), map(f, rest(s)));\n      }\n      return null;\n    });\n  }\n\n  // Multi-collection parallel map\n  return lazySeq(() => {\n    const seqs = colls.map(c => seq(c));\n\n    // Stop when any sequence is exhausted\n    if (seqs.some(s => s == null)) {\n      return null;\n    }\n\n    // Apply f to first elements of all sequences\n    const firsts = seqs.map(s => first(s));\n    const result = f(...firsts);\n\n    // Recur with rest of each sequence\n    const rests = seqs.map(s => rest(s));\n    return cons(result, map(f, ...rests));\n  });\n}\n\n/** filter - Filters collection by predicate (lazy) */\nexport function filter(pred, coll) {\n  if (typeof pred !== \"function\") {\n    throw new TypeError(\"filter: predicate must be a function, got \" + typeof pred);\n  }\n\n  // Optimization: Use chunked path for large arrays or already-chunked seqs\n  // isChunked now properly detects LazySeq with _isChunkedSource flag\n  if (shouldChunk(coll)) {\n    return chunkedFilter(pred, coll);\n  }\n\n  // Standard lazy sequence for other cases\n  return lazySeq(() => {\n    const s = seq(coll);\n    if (s != null) {\n      const f = first(s);\n      if (pred(f)) {\n        return cons(f, filter(pred, rest(s)));\n      } else {\n        return filter(pred, rest(s)).seq();\n      }\n    }\n    return null;\n  });\n}\n\n/**\n * reduce - Reduces collection with function (EAGER)\n *\n * Multi-arity support like Clojure:\n * - (reduce f coll) - 2-arity, uses first element as init\n * - (reduce f init coll) - 3-arity, explicit init\n *\n * Supports early termination with Reduced:\n * - If f returns (reduced x), stops immediately and returns x\n *\n * Clojure: (reduce + [1 2 3 4]) => 10\n * Clojure: (reduce + 10 [1 2 3]) => 16\n * Clojure: (reduce (fn [acc x] (if (> acc 5) (reduced acc) (+ acc x))) [1 2 3 4 5]) => 6\n */\nexport function reduce(f, initOrColl, maybeColl) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"reduce: reducer must be a function, got \" + typeof f);\n  }\n\n  let acc, s, coll;\n\n  if (maybeColl === undefined) {\n    // 2-arity: (reduce f coll)\n    coll = initOrColl;\n    s = seq(coll);\n    if (s == null) {\n      // Empty collection - call f with no args for identity\n      return f();\n    }\n    acc = first(s);\n    s = next(s);\n\n    // Optimization: Use chunked path for large arrays or already-chunked seqs\n    // isChunked now properly detects LazySeq with _isChunkedSource flag\n    if (shouldChunk(coll)) {\n      // For 2-arity, skip first element (already used as init)\n      const restColl = Array.isArray(coll) ? coll.slice(1) : rest(coll);\n      return chunkedReduce(f, acc, restColl);\n    }\n  } else {\n    // 3-arity: (reduce f init coll)\n    acc = initOrColl;\n    coll = maybeColl;\n    s = seq(coll);\n\n    // Optimization: Use chunked path for large arrays or already-chunked seqs\n    // isChunked now properly detects LazySeq with _isChunkedSource flag\n    if (shouldChunk(coll)) {\n      return chunkedReduce(f, acc, coll);\n    }\n  }\n\n  // Standard reduce loop with Reduced support\n  while (s != null) {\n    acc = f(acc, first(s));\n    // Check for early termination\n    if (isReduced(acc)) {\n      return acc._val;\n    }\n    s = next(s);\n  }\n  return acc;\n}\n\n/** concat - Concatenates multiple collections (lazy) - O(k) for k collections */\nexport function concat(...colls) {\n  // Use chunked path if any collection is large or already-chunked\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (colls.some(shouldChunk)) {\n    return chunkedConcat(...colls);\n  }\n\n  // Use index-based iteration to avoid array slicing\n  function step(collIdx, currSeq) {\n    return lazySeq(() => {\n      // Continue current sequence if non-empty\n      const s = currSeq != null ? seq(currSeq) : null;\n      if (s != null) {\n        return cons(first(s), step(collIdx, rest(s)));\n      }\n      // Move to next collection\n      let idx = collIdx;\n      while (idx < colls.length) {\n        const nextSeq = seq(colls[idx]);\n        idx++;\n        if (nextSeq != null) {\n          return cons(first(nextSeq), step(idx, rest(nextSeq)));\n        }\n      }\n      return null;\n    });\n  }\n  return step(0, null);\n}\n\n/** Check if a value is a collection (iterable but not a string) */\nfunction isColl(x) {\n  return x != null && typeof x !== \"string\" && typeof x[Symbol.iterator] === \"function\";\n}\n\n/** flatten - Flattens nested collections (lazy) */\nexport function flatten(coll) {\n  return lazySeq(() => {\n    const s = seq(coll);\n    if (s != null) {\n      const f = first(s);\n      if (isColl(f)) {\n        return concat(flatten(f), flatten(rest(s))).seq();\n      } else {\n        return cons(f, flatten(rest(s)));\n      }\n    }\n    return null;\n  });\n}\n\n/**\n * distinct - Removes duplicate elements (lazy) - O(n) time\n *\n * WARNING: For infinite sequences, this function maintains an unbounded\n * Set of seen elements which will grow indefinitely. Use with caution\n * on infinite sequences or consider using distinctT transducer with\n * bounded input.\n *\n * @param {Iterable} coll - The collection to deduplicate\n * @returns {LazySeq} Lazy sequence of unique elements\n */\nexport function distinct(coll) {\n  // Handle null/undefined input\n  if (coll == null) return lazySeq(() => null);\n\n  // Use chunked path for large arrays or already-chunked seqs\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (shouldChunk(coll)) {\n    return chunkedDistinct(coll);\n  }\n\n  const seen = new Set();  // Single mutable set per distinct() call\n  function step(s) {\n    return lazySeq(() => {\n      let xs = seq(s);\n      // Skip already-seen elements in a single pass\n      while (xs != null) {\n        const f = first(xs);\n        if (!seen.has(f)) {\n          seen.add(f);\n          return cons(f, step(rest(xs)));\n        }\n        xs = next(xs);\n      }\n      return null;\n    });\n  }\n  return step(coll);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 2: INDEXED OPERATIONS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** next - Returns seq of rest, or null if rest is empty */\nexport function next(coll) {\n  return seq(rest(coll));\n}\n\n/** nth - Returns element at index with optional not-found value */\nexport function nth(coll, index, notFound) {\n  if (!Number.isInteger(index) || index < 0) {\n    throw new TypeError(`nth: index must be non-negative integer, got ${index}`);\n  }\n  const hasNotFound = arguments.length >= 3;\n  if (coll == null) {\n    if (hasNotFound) return notFound;\n    throw new Error(`nth: index ${index} out of bounds for null collection`);\n  }\n  // Array/string fast path\n  if (Array.isArray(coll) || typeof coll === \"string\") {\n    if (index >= 0 && index < coll.length) return coll[index];\n    if (hasNotFound) return notFound;\n    throw new Error(`nth: index ${index} out of bounds (length ${coll.length})`);\n  }\n  // Generic seq path\n  let s = seq(coll);\n  let i = 0;\n  while (s != null) {\n    if (i === index) return first(s);\n    s = next(s);\n    i++;\n  }\n  if (hasNotFound) return notFound;\n  throw new Error(`nth: index ${index} out of bounds`);\n}\n\n/** second - Returns second element of collection */\nexport function second(coll) {\n  return nth(coll, 1, null);\n}\n\n/** count - Returns count of elements (EAGER) */\nexport function count(coll) {\n  if (coll == null) return 0;\n  if (Array.isArray(coll) || typeof coll === \"string\") return coll.length;\n  if (coll instanceof Set || coll instanceof Map) return coll.size;\n  // Direct iterable path for efficiency\n  if (typeof coll[Symbol.iterator] === \"function\") {\n    let n = 0;\n    for (const _ of coll) n++;\n    return n;\n  }\n  // Generic seq path for LazySeq\n  let s = seq(coll);\n  let n = 0;\n  while (s != null) {\n    n++;\n    s = next(s);\n  }\n  return n;\n}\n\n/** last - Returns last element (EAGER) */\nexport function last(coll) {\n  if (coll == null) return null;\n  if (Array.isArray(coll)) return coll.length > 0 ? coll[coll.length - 1] : null;\n  if (typeof coll === \"string\") return coll.length > 0 ? coll[coll.length - 1] : null;\n  let s = seq(coll);\n  let result = null;\n  while (s != null) {\n    result = first(s);\n    s = next(s);\n  }\n  return result;\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 3: MAP OPERATIONS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** mapIndexed - Maps function (index, item) over collection (lazy) */\nexport function mapIndexed(f, coll) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"mapIndexed: first argument must be a function, got \" + typeof f);\n  }\n\n  // Use chunked path for large arrays or already-chunked seqs\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (shouldChunk(coll)) {\n    return chunkedMapIndexed(f, coll);\n  }\n\n  function step(s, idx) {\n    return lazySeq(() => {\n      const xs = seq(s);\n      if (xs != null) {\n        return cons(f(idx, first(xs)), step(rest(xs), idx + 1));\n      }\n      return null;\n    });\n  }\n  return step(coll, 0);\n}\n\n/** keepIndexed - Like mapIndexed but filters nil results (lazy) */\nexport function keepIndexed(f, coll) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"keepIndexed: first argument must be a function, got \" + typeof f);\n  }\n  function step(s, idx) {\n    return lazySeq(() => {\n      const xs = seq(s);\n      if (xs != null) {\n        const result = f(idx, first(xs));\n        if (result != null) {\n          return cons(result, step(rest(xs), idx + 1));\n        } else {\n          return step(rest(xs), idx + 1).seq();\n        }\n      }\n      return null;\n    });\n  }\n  return step(coll, 0);\n}\n\n/** mapcat - Maps function then flattens one level (lazy) */\nexport function mapcat(f, coll) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"mapcat: first argument must be a function, got \" + typeof f);\n  }\n\n  // Use chunked path for large arrays or already-chunked seqs\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (shouldChunk(coll)) {\n    return chunkedMapcat(f, coll);\n  }\n\n  return lazySeq(() => {\n    const s = seq(coll);\n    if (s != null) {\n      const mapped = f(first(s));\n      return concat(mapped, mapcat(f, rest(s))).seq();\n    }\n    return null;\n  });\n}\n\n/** keep - Maps function and filters nil results (lazy) */\nexport function keep(f, coll) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"keep: first argument must be a function, got \" + typeof f);\n  }\n\n  // Use chunked path for large arrays or already-chunked seqs\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (shouldChunk(coll)) {\n    return chunkedKeep(f, coll);\n  }\n\n  return lazySeq(() => {\n    const s = seq(coll);\n    if (s != null) {\n      const result = f(first(s));\n      if (result != null) {\n        return cons(result, keep(f, rest(s)));\n      } else {\n        return keep(f, rest(s)).seq();\n      }\n    }\n    return null;\n  });\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 4: PREDICATES\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** isEmpty - Tests if collection is empty */\nexport function isEmpty(coll) {\n  return seq(coll) == null;\n}\n\n/** some - Returns first item where predicate returns truthy, or null */\nexport function some(pred, coll) {\n  if (typeof pred !== \"function\") {\n    throw new TypeError(\"some: predicate must be a function, got \" + typeof pred);\n  }\n  let s = seq(coll);\n  while (s != null) {\n    const f = first(s);\n    if (pred(f)) return f;\n    s = next(s);\n  }\n  return null;\n}\n\n/** every - Returns true if predicate returns truthy for all items */\nexport function every(pred, coll) {\n  if (typeof pred !== \"function\") {\n    throw new TypeError(\"every: predicate must be a function, got \" + typeof pred);\n  }\n  let s = seq(coll);\n  while (s != null) {\n    if (!pred(first(s))) return false;\n    s = next(s);\n  }\n  return true;\n}\n\n/** notAny - Returns true if predicate returns false for all items */\nexport function notAny(pred, coll) {\n  if (typeof pred !== \"function\") {\n    throw new TypeError(\"notAny: predicate must be a function, got \" + typeof pred);\n  }\n  let s = seq(coll);\n  while (s != null) {\n    if (pred(first(s))) return false;\n    s = next(s);\n  }\n  return true;\n}\n\n/** notEvery - Returns true if predicate returns false for at least one item */\nexport function notEvery(pred, coll) {\n  if (typeof pred !== \"function\") {\n    throw new TypeError(\"notEvery: predicate must be a function, got \" + typeof pred);\n  }\n  let s = seq(coll);\n  while (s != null) {\n    if (!pred(first(s))) return true;\n    s = next(s);\n  }\n  return false;\n}\n\n/** isSome - Returns true if value is not nil (null or undefined) */\nexport function isSome(x) {\n  return x != null;\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 5: TYPE PREDICATES\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nexport function isNil(x) { return x == null; }\nexport function isEven(n) { return n % 2 === 0; }\nexport function isOdd(n) { return n % 2 !== 0; }\nexport function isZero(n) { return n === 0; }\nexport function isPositive(n) { return n > 0; }\nexport function isNegative(n) { return n < 0; }\nexport function isNumber(x) { return typeof x === \"number\"; }\nexport function isString(x) { return typeof x === \"string\"; }\nexport function isBoolean(x) { return typeof x === \"boolean\"; }\nexport function isFunction(x) { return typeof x === \"function\"; }\nexport function isArray(x) { return Array.isArray(x); }\nexport function isObject(x) { return x !== null && typeof x === \"object\" && !Array.isArray(x); }\n\n// Lisp-style predicate aliases (with ? suffix)\n// These map `nil?` -> `nil_QMARK_` via sanitizeIdentifier\nexport { isNil as nil_QMARK_ };\nexport { isNumber as number_QMARK_ };\nexport { isString as string_QMARK_ };\nexport { isBoolean as boolean_QMARK_ };\nexport { isArray as array_QMARK_ };\nexport { isObject as object_QMARK_ };\nexport { isFunction as fn_QMARK_ };\nexport { isEmpty as empty_QMARK_ };\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 6: ARITHMETIC\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nexport function inc(x) { return x + 1; }\nexport function dec(x) { return x - 1; }\nexport function abs(x) { return Math.abs(x); }\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 7: COMPARISON\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nexport function eq(...vals) {\n  if (vals.length < 2) return true;\n  const fst = vals[0];\n  for (let i = 1; i < vals.length; i++) {\n    if (vals[i] !== fst) return false;\n  }\n  return true;\n}\n\nexport function neq(a, b) { return a !== b; }\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 8: LAZY CONSTRUCTORS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** repeat - Infinite sequence of the same value */\nexport function repeat(x) {\n  return lazySeq(() => cons(x, repeat(x)));\n}\n\n/** repeatedly - Infinite sequence calling f each time */\nexport function repeatedly(f) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"repeatedly: argument must be a function\");\n  }\n  return lazySeq(() => cons(f(), repeatedly(f)));\n}\n\n/** cycle - Infinite sequence cycling through collection */\nexport function cycle(coll) {\n  const xs = seq(coll);\n  if (xs == null) return null;\n  function step(s) {\n    return lazySeq(() => {\n      const curr = seq(s);\n      if (curr != null) {\n        return cons(first(curr), step(rest(curr)));\n      }\n      return step(xs).seq();\n    });\n  }\n  return step(xs);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 9: FUNCTION OPERATIONS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** iterate - Returns x, f(x), f(f(x)), ... */\nexport function iterate(f, x) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"iterate: iterator function must be a function\");\n  }\n  return lazySeq(() => cons(x, iterate(f, f(x))));\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 10: UTILITIES\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** keys - Get keys from an object */\nexport function keys(obj) {\n  if (obj == null) return [];\n  return Object.keys(obj);\n}\n\n/** reverse - Reverse a collection */\nexport function reverse(coll) {\n  if (coll == null) return [];\n  return Array.from(coll).reverse();\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 11: FUNCTION OPERATIONS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** comp - Compose functions right-to-left: (comp f g h)(x) = f(g(h(x))) */\nexport function comp(...fns) {\n  for (let i = 0; i < fns.length; i++) {\n    if (typeof fns[i] !== \"function\") {\n      throw new TypeError(`comp: argument ${i + 1} must be a function`);\n    }\n  }\n  if (fns.length === 0) return x => x;\n  if (fns.length === 1) return fns[0];\n  return function(...args) {\n    let result = fns[fns.length - 1](...args);\n    for (let i = fns.length - 2; i >= 0; i--) result = fns[i](result);\n    return result;\n  };\n}\n\n/** partial - Partial function application: (partial f a b)(c) = f(a, b, c) */\nexport function partial(f, ...args) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"partial: function must be a function\");\n  }\n  return function(...moreArgs) {\n    return f(...args, ...moreArgs);\n  };\n}\n\n/** apply - Apply function to args collection: (apply f [a b c]) = f(a, b, c) */\nexport function apply(f, args) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"apply: function must be a function\");\n  }\n  if (args == null || typeof args[Symbol.iterator] !== \"function\") {\n    throw new TypeError(\"apply: args must be iterable\");\n  }\n  const arr = Array.isArray(args) ? args : Array.from(args);\n  return f(...arr);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 12: COMPARISON (variadic chain semantics)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** lt - Less than: (< a b c) = (a < b) && (b < c) */\nexport function lt(...nums) {\n  for (let i = 0; i < nums.length - 1; i++) {\n    if (!(nums[i] < nums[i + 1])) return false;\n  }\n  return true;\n}\n\n/** gt - Greater than: (> a b c) = (a > b) && (b > c) */\nexport function gt(...nums) {\n  for (let i = 0; i < nums.length - 1; i++) {\n    if (!(nums[i] > nums[i + 1])) return false;\n  }\n  return true;\n}\n\n/** lte - Less than or equal: (<= a b c) = (a <= b) && (b <= c) */\nexport function lte(...nums) {\n  for (let i = 0; i < nums.length - 1; i++) {\n    if (!(nums[i] <= nums[i + 1])) return false;\n  }\n  return true;\n}\n\n/** gte - Greater than or equal: (>= a b c) = (a >= b) && (b >= c) */\nexport function gte(...nums) {\n  for (let i = 0; i < nums.length - 1; i++) {\n    if (!(nums[i] >= nums[i + 1])) return false;\n  }\n  return true;\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 13: ARITHMETIC (variadic with identity semantics)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** add - Sum: (+) = 0, (+ a) = a, (+ a b c) = a + b + c */\nexport function add(...nums) {\n  let sum = 0;\n  for (const n of nums) sum += n;\n  return sum;\n}\n\n/** sub - Subtract: (-) = 0, (- a) = -a, (- a b c) = a - b - c */\nexport function sub(...nums) {\n  if (nums.length === 0) return 0;\n  if (nums.length === 1) return -nums[0];\n  let result = nums[0];\n  for (let i = 1; i < nums.length; i++) result -= nums[i];\n  return result;\n}\n\n/** mul - Multiply: (*) = 1, (* a) = a, (* a b c) = a * b * c */\nexport function mul(...nums) {\n  let product = 1;\n  for (const n of nums) product *= n;\n  return product;\n}\n\n/** div - Divide: (/) = 1, (/ a) = 1/a, (/ a b c) = a / b / c */\nexport function div(...nums) {\n  if (nums.length === 0) return 1;\n  if (nums.length === 1) return 1 / nums[0];\n  let result = nums[0];\n  for (let i = 1; i < nums.length; i++) result /= nums[i];\n  return result;\n}\n\n/** mod - Modulo: (mod a b) = a % b */\nexport function mod(a, b) {\n  return a % b;\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 14: SYMBOL/KEYWORD\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** symbol - Create symbol from string */\nexport function symbol(name) {\n  return String(name);\n}\n\n/** keyword - Create keyword (string with : prefix) */\nexport function keyword(name) {\n  const s = String(name);\n  return s.startsWith(\":\") ? s : \":\" + s;\n}\n\n/** name - Get name part (removes : prefix from keywords) */\nexport function name(x) {\n  if (x == null) return null;\n  const s = String(x);\n  return s.startsWith(\":\") ? s.slice(1) : s;\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 15: TYPE CONVERSIONS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** vec - Convert collection to array (always new copy) */\nexport function vec(coll) {\n  if (coll == null) return [];\n  return Array.from(coll);\n}\n\n/** set - Convert collection to Set (always new copy) */\nexport function set(coll) {\n  if (coll == null) return new Set();\n  return new Set(coll);\n}\n\n/** doall - Force realization of lazy sequence */\nexport function doall(coll) {\n  if (coll == null) return [];\n  if (Array.isArray(coll)) return coll; // O(1) - already realized\n  return Array.from(coll);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 16: MAP ACCESS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** get - Get value at key from map/object, with optional default */\nexport function get(m, key, notFound) {\n  if (m == null) return notFound;\n  if (m instanceof Map) return m.has(key) ? m.get(key) : notFound;\n  return (key in m) ? m[key] : notFound;\n}\n\n/** getIn - Get value at nested path */\nexport function getIn(m, path, notFound) {\n  // Validate path is array-like\n  if (path == null || typeof path.length !== \"number\") {\n    throw new TypeError(\"getIn: path must be an array, got \" + (path == null ? \"null\" : typeof path));\n  }\n  if (path.length === 0) return m;\n  let current = m;\n  for (const key of path) {\n    current = get(current, key, null);\n    if (current == null) return notFound;\n  }\n  return current;\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 17: MAP MUTATIONS (immutable)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** assoc - Associate key with value (returns new map)\n * For arrays: index must be 0 <= key <= length (Clojure semantics)\n * Use key === length to append, 0 <= key < length to replace\n */\nexport function assoc(m, key, value) {\n  if (m == null) {\n    // nil + numeric key: create single-element array at index 0 only\n    // For Clojure compatibility, only index 0 is valid on nil\n    if (typeof key === \"number\") {\n      if (key !== 0) {\n        throw new RangeError(`assoc: index ${key} out of bounds for nil (only 0 is valid)`);\n      }\n      return [value];\n    }\n    return { [key]: value };\n  }\n  if (m instanceof Map) { const r = new Map(m); r.set(key, value); return r; }\n  if (Array.isArray(m)) {\n    // Clojure semantics: index must be 0 <= key <= length\n    if (typeof key === \"number\") {\n      if (key < 0 || key > m.length) {\n        throw new RangeError(`assoc: index ${key} out of bounds for array of length ${m.length}`);\n      }\n    }\n    const r = [...m]; r[key] = value; return r;\n  }\n  return { ...m, [key]: value };\n}\n\n/** assocIn - Associate value at nested path */\nexport function assocIn(m, path, value) {\n  // Validate path is array-like\n  if (path == null || typeof path.length !== \"number\") {\n    throw new TypeError(\"assocIn: path must be an array, got \" + (path == null ? \"null\" : typeof path));\n  }\n  if (path.length === 0) return value;\n  if (path.length === 1) return assoc(m, path[0], value);\n  const [key, ...restPath] = path;\n  const existing = get(m == null ? {} : m, key);\n  const nested = (existing != null && typeof existing === \"object\")\n    ? existing\n    : (typeof restPath[0] === \"number\" ? [] : {});\n  return assoc(m == null ? {} : m, key, assocIn(nested, restPath, value));\n}\n\n/** dissoc - Remove keys from map (returns new map) */\nexport function dissoc(m, ...keys) {\n  if (m == null) return {};\n  if (m instanceof Map) {\n    const r = new Map(m);\n    for (const k of keys) r.delete(k);\n    return r;\n  }\n  if (Array.isArray(m)) {\n    const r = [...m];\n    for (const k of keys) delete r[k];\n    return r;\n  }\n  const r = { ...m };\n  for (const k of keys) delete r[k];\n  return r;\n}\n\n/** update - Transform value at key with function */\nexport function update(m, key, fn) {\n  if (typeof fn !== \"function\") throw new TypeError(\"update: transform function must be a function\");\n  return assoc(m, key, fn(get(m, key)));\n}\n\n/** updateIn - Transform value at nested path with function */\nexport function updateIn(m, path, fn) {\n  if (typeof fn !== \"function\") throw new TypeError(\"updateIn: transform function must be a function\");\n  // Validate path is array-like\n  if (path == null || typeof path.length !== \"number\") {\n    throw new TypeError(\"updateIn: path must be an array, got \" + (path == null ? \"null\" : typeof path));\n  }\n  if (path.length === 0) return fn(m);\n  return assocIn(m, path, fn(getIn(m, path)));\n}\n\n/** merge - Merge multiple maps (later wins, shallow) */\nexport function merge(...maps) {\n  const nonNil = maps.filter(m => m != null);\n  if (nonNil.length === 0) return {};\n\n  if (nonNil[0] instanceof Map) {\n    const r = new Map();\n    for (const m of nonNil) {\n      if (m instanceof Map) {\n        for (const [k, v] of m) r.set(k, v);\n      } else if (typeof m === \"object\") {\n        // Coerce plain objects into Map entries\n        for (const [k, v] of Object.entries(m)) r.set(k, v);\n      }\n      // Skip non-object types silently (matches Clojure behavior)\n    }\n    return r;\n  }\n\n  return Object.assign({}, ...nonNil);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 18: COLLECTION PROTOCOLS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** empty - Return empty collection of same type */\nexport function empty(coll) {\n  if (coll == null) return null;\n  if (Array.isArray(coll)) return [];\n  if (typeof coll === \"string\") return \"\";\n  if (coll[SEQ]) return null; // LazySeq -> null (empty lazy seq)\n  if (coll instanceof Set) return new Set();\n  if (coll instanceof Map) return new Map();\n  if (typeof coll === \"object\") return {};\n  throw new TypeError(`Cannot create empty collection from ${typeof coll}`);\n}\n\n/** conj - Add item(s) to collection (type-preserving) */\nexport function conj(coll, ...items) {\n  if (items.length === 0) return coll == null ? [] : coll;\n  if (coll == null) return [...items];\n  if (Array.isArray(coll)) return [...coll, ...items];\n  if (typeof coll === \"string\") return coll + items.join(\"\");\n  if (coll[SEQ]) {\n    // LazySeq: prepend items (reverse order for correct result)\n    let result = coll;\n    for (let i = items.length - 1; i >= 0; i--) result = cons(items[i], result);\n    return result;\n  }\n  if (coll instanceof Set) {\n    const r = new Set(coll);\n    for (const item of items) r.add(item);\n    return r;\n  }\n  if (coll instanceof Map) {\n    const r = new Map(coll);\n    for (const item of items) {\n      if (!Array.isArray(item) || item.length !== 2) throw new TypeError(\"Map entries must be [key, value] pairs\");\n      r.set(item[0], item[1]);\n    }\n    return r;\n  }\n  if (typeof coll === \"object\") {\n    const r = { ...coll };\n    for (const item of items) {\n      if (!Array.isArray(item) || item.length !== 2) throw new TypeError(\"Object entries must be [key, value] pairs\");\n      r[item[0]] = item[1];\n    }\n    return r;\n  }\n  throw new TypeError(`Cannot conj to ${typeof coll}`);\n}\n\n/** into - Pour collection into target - O(n) optimized */\nexport function into(to, from) {\n  if (from == null) return to == null ? [] : to;\n  // Fast paths to avoid O(n²) from repeated conj\n  if (to == null) {\n    return Array.from(from);\n  }\n  if (Array.isArray(to)) {\n    const arr = [...to];\n    for (const item of from) arr.push(item);\n    return arr;\n  }\n  if (to instanceof Set) {\n    const result = new Set(to);\n    for (const item of from) result.add(item);\n    return result;\n  }\n  if (to instanceof Map) {\n    const result = new Map(to);\n    for (const item of from) {\n      if (Array.isArray(item) && item.length === 2) result.set(item[0], item[1]);\n    }\n    return result;\n  }\n  // Fallback for other types (strings, objects, etc.)\n  return reduce((acc, item) => conj(acc, item), to, from);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 19: CONDITIONAL LAZY FUNCTIONS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * takeWhile - Returns elements while predicate is true (lazy)\n * Clojure: (take-while pos? [1 2 3 0 -1]) => (1 2 3)\n */\nexport function takeWhile(pred, coll) {\n  if (typeof pred !== \"function\") {\n    throw new TypeError(\"takeWhile: predicate must be a function, got \" + typeof pred);\n  }\n\n  // Use chunked path for large arrays or already-chunked seqs\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (shouldChunk(coll)) {\n    return chunkedTakeWhile(pred, coll);\n  }\n\n  return lazySeq(() => {\n    const s = seq(coll);\n    if (s != null) {\n      const f = first(s);\n      if (pred(f)) {\n        return cons(f, takeWhile(pred, rest(s)));\n      }\n    }\n    return null;\n  });\n}\n\n/**\n * dropWhile - Drops elements while predicate is true (lazy)\n * Clojure: (drop-while pos? [1 2 3 0 -1 2]) => (0 -1 2)\n */\nexport function dropWhile(pred, coll) {\n  if (typeof pred !== \"function\") {\n    throw new TypeError(\"dropWhile: predicate must be a function, got \" + typeof pred);\n  }\n\n  // Use chunked path for large arrays or already-chunked seqs\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (shouldChunk(coll)) {\n    return chunkedDropWhile(pred, coll);\n  }\n\n  return lazySeq(() => {\n    let s = seq(coll);\n    // Skip while predicate is true\n    while (s != null && pred(first(s))) {\n      s = next(s);\n    }\n    // Return remaining elements\n    if (s != null) {\n      return cons(first(s), rest(s));\n    }\n    return null;\n  });\n}\n\n/**\n * splitWith - Returns [(takeWhile pred coll) (dropWhile pred coll)]\n * Clojure: (split-with pos? [1 2 -1 3]) => [(1 2) (-1 3)]\n */\nexport function splitWith(pred, coll) {\n  if (typeof pred !== \"function\") {\n    throw new TypeError(\"splitWith: predicate must be a function, got \" + typeof pred);\n  }\n  return [doall(takeWhile(pred, coll)), doall(dropWhile(pred, coll))];\n}\n\n/**\n * splitAt - Returns [(take n coll) (drop n coll)]\n * Clojure: (split-at 2 [1 2 3 4 5]) => [(1 2) (3 4 5)]\n */\nexport function splitAt(n, coll) {\n  if (!Number.isInteger(n) || n < 0) {\n    throw new TypeError(\"splitAt: n must be non-negative integer, got \" + n);\n  }\n  return [doall(take(n, coll)), doall(drop(n, coll))];\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 20: REDUCTION VARIANTS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * reductions - Returns lazy seq of intermediate reduce values\n * Clojure: (reductions + [1 2 3 4]) => (1 3 6 10)\n * Clojure: (reductions + 0 [1 2 3]) => (0 1 3 6)\n */\nexport function reductions(f, initOrColl, maybeColl) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"reductions: reducer must be a function, got \" + typeof f);\n  }\n\n  // 2-arity: (reductions f coll) - use first element as init\n  if (maybeColl === undefined) {\n    const coll = initOrColl;\n    return lazySeq(() => {\n      const s = seq(coll);\n      if (s != null) {\n        return reductionsWithInit(f, first(s), rest(s)).seq();\n      }\n      return null;\n    });\n  }\n\n  // 3-arity: (reductions f init coll)\n  // Use chunked path for large arrays or already-chunked seqs\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (shouldChunk(maybeColl)) {\n    return chunkedReductions(f, initOrColl, maybeColl);\n  }\n\n  return reductionsWithInit(f, initOrColl, maybeColl);\n}\n\n/** Helper: reductions with explicit init */\nfunction reductionsWithInit(f, init, coll) {\n  return cons(init, lazySeq(() => {\n    const s = seq(coll);\n    if (s != null) {\n      const newAcc = f(init, first(s));\n      return reductionsWithInit(f, newAcc, rest(s)).seq();\n    }\n    return null;\n  }));\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 21: SEQUENCE COMBINATORS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * interleave - Interleaves multiple sequences (lazy)\n * Stops when shortest sequence is exhausted.\n * Clojure: (interleave [1 2 3] [:a :b :c]) => (1 :a 2 :b 3 :c)\n */\nexport function interleave(...colls) {\n  if (colls.length === 0) return lazySeq(() => null);\n  if (colls.length === 1) return lazySeq(() => seq(colls[0]));\n\n  // Use chunked path if any collection is large or already-chunked\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (colls.some(shouldChunk)) {\n    return chunkedInterleave(...colls);\n  }\n\n  return lazySeq(() => {\n    // Get seqs of all collections\n    const seqs = colls.map(c => seq(c));\n\n    // If any seq is null, stop\n    if (seqs.some(s => s == null)) {\n      return null;\n    }\n\n    // Yield first from each, then recur with rests\n    const firsts = seqs.map(s => first(s));\n    const rests = seqs.map(s => rest(s));\n\n    // Build result: first elements, then interleave of rests\n    let result = interleave(...rests);\n    for (let i = firsts.length - 1; i >= 0; i--) {\n      result = cons(firsts[i], result);\n    }\n    return result.seq();\n  });\n}\n\n/**\n * interpose - Inserts separator between elements (lazy)\n * Clojure: (interpose :x [1 2 3]) => (1 :x 2 :x 3)\n */\nexport function interpose(sep, coll) {\n  // Use chunked path for large arrays or already-chunked seqs\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (shouldChunk(coll)) {\n    return chunkedInterpose(sep, coll);\n  }\n\n  return lazySeq(() => {\n    const s = seq(coll);\n    if (s == null) return null;\n\n    const f = first(s);\n    const r = rest(s);\n\n    // First element, then [sep, elem] for each remaining\n    return cons(f, interposeRest(sep, r));\n  });\n}\n\n/** Helper: interpose for remaining elements */\nfunction interposeRest(sep, coll) {\n  return lazySeq(() => {\n    const s = seq(coll);\n    if (s == null) return null;\n    return cons(sep, cons(first(s), interposeRest(sep, rest(s))));\n  });\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 22: PARTITION FAMILY\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * partition - Partitions collection into groups of n (lazy)\n * Drops incomplete trailing groups.\n *\n * 2-arity: (partition n coll) - step defaults to n\n * 3-arity: (partition n step coll) - explicit step\n *\n * Clojure: (partition 3 [1 2 3 4 5 6 7]) => ((1 2 3) (4 5 6))\n * Clojure: (partition 3 1 [1 2 3 4 5]) => ((1 2 3) (2 3 4) (3 4 5))\n */\nexport function partition(n, stepOrColl, maybeColl) {\n  if (typeof n !== \"number\" || n < 1) {\n    throw new TypeError(\"partition: n must be a positive number\");\n  }\n\n  // Determine arity\n  let step, coll;\n  if (maybeColl === undefined) {\n    // 2-arity: partition(n, coll)\n    step = n;\n    coll = stepOrColl;\n  } else {\n    // 3-arity: partition(n, step, coll)\n    step = stepOrColl;\n    coll = maybeColl;\n  }\n\n  if (typeof step !== \"number\" || step < 1) {\n    throw new TypeError(\"partition: step must be a positive number\");\n  }\n\n  // Use chunked path for simple case (step = n) with large arrays or already-chunked seqs\n  // Note: Don't check instanceof LazySeq to preserve laziness for generator-based seqs\n  if (step === n && (shouldChunk(coll))) {\n    return chunkedPartition(n, coll);\n  }\n\n  return lazySeq(() => {\n    const s = seq(coll);\n    if (s == null) return null;\n\n    // Take n elements\n    const p = doall(take(n, s));\n\n    // Only include if we got exactly n elements\n    if (count(p) === n) {\n      return cons(p, partition(n, step, drop(step, s)));\n    }\n    return null;\n  });\n}\n\n/**\n * partitionAll - Like partition, but includes incomplete trailing groups (lazy)\n *\n * 2-arity: (partition-all n coll) - step defaults to n\n * 3-arity: (partition-all n step coll) - explicit step\n *\n * Clojure: (partition-all 3 [1 2 3 4 5 6 7]) => ((1 2 3) (4 5 6) (7))\n */\nexport function partitionAll(n, stepOrColl, maybeColl) {\n  if (typeof n !== \"number\" || n < 1) {\n    throw new TypeError(\"partitionAll: n must be a positive number\");\n  }\n\n  // Determine arity\n  let step, coll;\n  if (maybeColl === undefined) {\n    // 2-arity: partitionAll(n, coll)\n    step = n;\n    coll = stepOrColl;\n  } else {\n    // 3-arity: partitionAll(n, step, coll)\n    step = stepOrColl;\n    coll = maybeColl;\n  }\n\n  if (typeof step !== \"number\" || step < 1) {\n    throw new TypeError(\"partitionAll: step must be a positive number\");\n  }\n\n  return lazySeq(() => {\n    const s = seq(coll);\n    if (s == null) return null;\n\n    // Take n elements (or whatever's left)\n    const p = doall(take(n, s));\n\n    // Include even if incomplete\n    return cons(p, partitionAll(n, step, drop(step, s)));\n  });\n}\n\n/**\n * partitionBy - Partitions when function result changes (lazy)\n *\n * Clojure: (partition-by odd? [1 1 2 2 3]) => ((1 1) (2 2) (3))\n */\nexport function partitionBy(f, coll) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"partitionBy: f must be a function\");\n  }\n\n  return lazySeq(() => {\n    const s = seq(coll);\n    if (s == null) return null;\n\n    const fst = first(s);\n    const fv = f(fst);\n\n    // Take all elements with same f result\n    const run = doall(cons(fst, takeWhile((x) => {\n      const xv = f(x);\n      // Use === for Clojure's = semantics (strict equality)\n      return fv === xv;\n    }, rest(s))));\n\n    const runCount = count(run);\n    return cons(run, partitionBy(f, drop(runCount, s)));\n  });\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 23: TRANSDUCERS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * mapT - Returns a mapping transducer.\n * When used with transduce, transforms each element by f.\n *\n * Clojure: (transduce (map inc) + [1 2 3]) => 9\n */\nexport function mapT(f) {\n  if (typeof f !== \"function\") {\n    throw new TypeError(\"mapT: f must be a function\");\n  }\n  return (rf) => ({\n    [TRANSDUCER_INIT]: () => rf[TRANSDUCER_INIT](),\n    [TRANSDUCER_STEP]: (result, input) => rf[TRANSDUCER_STEP](result, f(input)),\n    [TRANSDUCER_RESULT]: (result) => rf[TRANSDUCER_RESULT](result),\n  });\n}\n\n/**\n * filterT - Returns a filtering transducer.\n * When used with transduce, only passes elements where pred returns truthy.\n *\n * Clojure: (transduce (filter even?) conj [] [1 2 3 4]) => [2 4]\n */\nexport function filterT(pred) {\n  if (typeof pred !== \"function\") {\n    throw new TypeError(\"filterT: pred must be a function\");\n  }\n  return (rf) => ({\n    [TRANSDUCER_INIT]: () => rf[TRANSDUCER_INIT](),\n    [TRANSDUCER_STEP]: (result, input) =>\n      pred(input) ? rf[TRANSDUCER_STEP](result, input) : result,\n    [TRANSDUCER_RESULT]: (result) => rf[TRANSDUCER_RESULT](result),\n  });\n}\n\n/**\n * takeT - Returns a take transducer.\n * When used with transduce, takes at most n elements.\n *\n * Clojure: (transduce (take 3) conj [] [1 2 3 4 5]) => [1 2 3]\n */\nexport function takeT(n) {\n  if (typeof n !== \"number\" || n < 0) {\n    throw new TypeError(\"takeT: n must be a non-negative number\");\n  }\n  return (rf) => {\n    let taken = 0;\n    return {\n      [TRANSDUCER_INIT]: () => rf[TRANSDUCER_INIT](),\n      [TRANSDUCER_STEP]: (result, input) => {\n        if (taken < n) {\n          taken++;\n          const r = rf[TRANSDUCER_STEP](result, input);\n          // If we've taken enough, signal early termination\n          return taken >= n ? ensureReduced(r) : r;\n        }\n        return ensureReduced(result);\n      },\n      [TRANSDUCER_RESULT]: (result) => rf[TRANSDUCER_RESULT](result),\n    };\n  };\n}\n\n/**\n * dropT - Returns a drop transducer.\n * When used with transduce, drops first n elements.\n *\n * Clojure: (transduce (drop 2) conj [] [1 2 3 4 5]) => [3 4 5]\n */\nexport function dropT(n) {\n  if (typeof n !== \"number\" || n < 0) {\n    throw new TypeError(\"dropT: n must be a non-negative number\");\n  }\n  return (rf) => {\n    let dropped = 0;\n    return {\n      [TRANSDUCER_INIT]: () => rf[TRANSDUCER_INIT](),\n      [TRANSDUCER_STEP]: (result, input) => {\n        if (dropped < n) {\n          dropped++;\n          return result;\n        }\n        return rf[TRANSDUCER_STEP](result, input);\n      },\n      [TRANSDUCER_RESULT]: (result) => rf[TRANSDUCER_RESULT](result),\n    };\n  };\n}\n\n/**\n * takeWhileT - Returns a take-while transducer.\n * Takes elements while pred returns truthy, then stops.\n *\n * Clojure: (transduce (take-while pos?) conj [] [1 2 -1 3]) => [1 2]\n */\nexport function takeWhileT(pred) {\n  if (typeof pred !== \"function\") {\n    throw new TypeError(\"takeWhileT: pred must be a function\");\n  }\n  return (rf) => ({\n    [TRANSDUCER_INIT]: () => rf[TRANSDUCER_INIT](),\n    [TRANSDUCER_STEP]: (result, input) =>\n      pred(input) ? rf[TRANSDUCER_STEP](result, input) : reduced(result),\n    [TRANSDUCER_RESULT]: (result) => rf[TRANSDUCER_RESULT](result),\n  });\n}\n\n/**\n * dropWhileT - Returns a drop-while transducer.\n * Drops elements while pred returns truthy, then takes the rest.\n *\n * Clojure: (transduce (drop-while neg?) conj [] [-1 -2 3 4]) => [3 4]\n */\nexport function dropWhileT(pred) {\n  if (typeof pred !== \"function\") {\n    throw new TypeError(\"dropWhileT: pred must be a function\");\n  }\n  return (rf) => {\n    let dropping = true;\n    return {\n      [TRANSDUCER_INIT]: () => rf[TRANSDUCER_INIT](),\n      [TRANSDUCER_STEP]: (result, input) => {\n        if (dropping) {\n          if (pred(input)) {\n            return result;\n          }\n          dropping = false;\n        }\n        return rf[TRANSDUCER_STEP](result, input);\n      },\n      [TRANSDUCER_RESULT]: (result) => rf[TRANSDUCER_RESULT](result),\n    };\n  };\n}\n\n/**\n * distinctT - Returns a distinct transducer.\n * Removes duplicate elements.\n *\n * Clojure: (transduce (distinct) conj [] [1 2 1 3 2]) => [1 2 3]\n */\nexport function distinctT() {\n  return (rf) => {\n    const seen = new Set();\n    return {\n      [TRANSDUCER_INIT]: () => rf[TRANSDUCER_INIT](),\n      [TRANSDUCER_STEP]: (result, input) => {\n        if (seen.has(input)) {\n          return result;\n        }\n        seen.add(input);\n        return rf[TRANSDUCER_STEP](result, input);\n      },\n      [TRANSDUCER_RESULT]: (result) => rf[TRANSDUCER_RESULT](result),\n    };\n  };\n}\n\n/**\n * partitionAllT - Returns a partition-all transducer.\n * Partitions input into groups of n, including incomplete final group.\n *\n * Clojure: (transduce (partition-all 2) conj [] [1 2 3 4 5]) => [[1 2] [3 4] [5]]\n */\nexport function partitionAllT(n) {\n  if (typeof n !== \"number\" || n < 1) {\n    throw new TypeError(\"partitionAllT: n must be a positive number\");\n  }\n  return (rf) => {\n    let buffer = [];\n    return {\n      [TRANSDUCER_INIT]: () => rf[TRANSDUCER_INIT](),\n      [TRANSDUCER_STEP]: (result, input) => {\n        buffer.push(input);\n        if (buffer.length === n) {\n          const chunk = buffer;\n          buffer = [];\n          return rf[TRANSDUCER_STEP](result, chunk);\n        }\n        return result;\n      },\n      [TRANSDUCER_RESULT]: (result) => {\n        // Flush any remaining elements\n        if (buffer.length > 0) {\n          result = rf[TRANSDUCER_STEP](result, buffer);\n          buffer = [];\n        }\n        return rf[TRANSDUCER_RESULT](isReduced(result) ? result._val : result);\n      },\n    };\n  };\n}\n\n/**\n * composeTransducers - Compose multiple transducers left-to-right.\n * This is the opposite of function composition since transducers\n * are applied in reverse order when composed with rf.\n *\n * Usage: composeTransducers(mapT(inc), filterT(even?))\n * Equivalent to: (comp (map inc) (filter even?)) in Clojure\n */\nexport function composeTransducers(...xforms) {\n  if (xforms.length === 0) return (rf) => rf;\n  if (xforms.length === 1) return xforms[0];\n\n  // Compose right-to-left to get left-to-right application\n  return (rf) => {\n    let composed = rf;\n    for (let i = xforms.length - 1; i >= 0; i--) {\n      composed = xforms[i](composed);\n    }\n    return composed;\n  };\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PHASE 24: FUNCTION UTILITIES\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** identity - Returns its argument unchanged */\nexport function identity(x) {\n  return x;\n}\n\n/** constantly - Returns a function that always returns x, ignoring any arguments */\nexport function constantly(x) {\n  return function(..._args) {\n    return x;\n  };\n}\n\n/** vals - Get values from an object/map */\nexport function vals(m) {\n  if (m == null) return [];\n  if (m instanceof Map) return Array.from(m.values());\n  return Object.values(m);\n}\n\n/**\n * juxt - Juxtaposition: returns a fn that calls all fns on same args\n * Returns a vector of results.\n * Clojure: ((juxt inc dec) 5) => [6 4]\n */\nexport function juxt(...fns) {\n  for (let i = 0; i < fns.length; i++) {\n    if (typeof fns[i] !== \"function\") {\n      throw new TypeError(`juxt: argument ${i + 1} must be a function`);\n    }\n  }\n  return function(...args) {\n    return fns.map(f => f(...args));\n  };\n}\n\n/**\n * zipmap - Create map from keys and values\n * Clojure: (zipmap [:a :b :c] [1 2 3]) => {:a 1, :b 2, :c 3}\n */\nexport function zipmap(ks, vs) {\n  const result = {};\n  const keys = ks == null ? [] : Array.from(ks);\n  const values = vs == null ? [] : Array.from(vs);\n  const len = Math.min(keys.length, values.length);\n  for (let i = 0; i < len; i++) {\n    result[keys[i]] = values[i];\n  }\n  return result;\n}\n",
  "@hql/lib/stdlib/js/internal/validators.js": "// internal/validators.js - Validation helpers\n// Internal implementation detail, not part of public API\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// VALIDATION HELPERS\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Validate that a value is a finite number (can be negative)\n */\nexport function validateFiniteNumber(n, functionName, paramName) {\n  if (typeof n !== \"number\" || !Number.isFinite(n)) {\n    throw new TypeError(\n      `${functionName}: ${paramName} must be a finite number, got ${typeof n}`,\n    );\n  }\n}\n\n/**\n * Validate that a value is a non-zero finite number\n */\nexport function validateNonZeroNumber(n, functionName, paramName) {\n  if (typeof n !== \"number\" || n === 0 || !Number.isFinite(n)) {\n    throw new TypeError(\n      `${functionName}: ${paramName} must be a non-zero finite number, got ${\n        typeof n === \"number\" ? n : typeof n\n      }`,\n    );\n  }\n}\n\n/**\n * Safely serialize a value for error messages (handles circular refs)\n */\nfunction safeStringify(value, maxLength = 50) {\n  try {\n    const str = JSON.stringify(value);\n    return str.length > maxLength ? str.slice(0, maxLength) + \"...\" : str;\n  } catch {\n    // Handle circular references, non-serializable values, etc.\n    return Object.prototype.toString.call(value);\n  }\n}\n\n/**\n * Validate that a value is a function\n */\nexport function validateFunction(\n  f,\n  functionName,\n  paramName = \"first argument\",\n) {\n  if (typeof f !== \"function\") {\n    // Show value preview for better debugging (only on error path, no perf cost)\n    const valuePreview = typeof f === \"object\" && f !== null\n      ? safeStringify(f)\n      : String(f);\n    throw new TypeError(\n      `${functionName}: ${paramName} must be a function, got ${typeof f} (value: ${valuePreview})`,\n    );\n  }\n}\n",
  "@hql/lib/stdlib/js/internal/range-core.js": "// range-core.js\n// Shared core implementation of range used by both stdlib and transpiler helpers\n\nimport { NumericRange, lazySeq, cons } from \"./seq-protocol.js\";\n\n/**\n * Core range implementation (shared by stdlib.range and __hql_range)\n *\n * Generates a sequence of numbers from start to end with given step.\n *\n * OPTIMIZATION: Uses NumericRange for finite ranges (O(1) count/nth),\n * uses Cons-chain LazySeq for infinite ranges (O(1) rest).\n *\n * @param {number} start - Starting number\n * @param {number|undefined} end - Ending number (exclusive), or undefined for infinite sequence\n * @param {number} step - Step size\n * @returns {NumericRange|LazySeq} Sequence of numbers\n */\nexport function rangeCore(start, end, step) {\n  // Infinite sequence case (no end specified or Infinity)\n  if (end === undefined || end === Infinity || end === -Infinity) {\n    // Use Cons-chain LazySeq (O(1) rest, Clojure-aligned)\n    const makeRange = (n) => lazySeq(() => cons(n, makeRange(n + step)));\n    return makeRange(start);\n  }\n\n  // Finite range: Use NumericRange for O(1) count/nth\n  return new NumericRange(start, end, step);\n}\n",
  "@hql/lib/stdlib/js/internal/seq-protocol.js": "// seq-protocol.js - Clojure-aligned Seq Protocol (Optimized)\n//\n// Design principles:\n// - KISS: Minimal code, maximum clarity\n// - DRY: No redundancy\n// - Clojure-inspired: ISeq, Counted, Indexed protocols\n// - JS-idiomatic: ESM exports, Symbol protocols, iterators\n//\n// Time complexity guarantees:\n// - first/rest/seq: O(1) for all seq types\n// - count: O(1) for Counted types, O(n) fallback\n// - nth: O(1) for Indexed types, O(n) fallback\n// - Trampolining: O(1) stack depth for any nesting level\n//\n// Reference: clojure/lang/{LazySeq,Cons,ArraySeq,RT}.java\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PROTOCOLS (like Clojure's interfaces)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** ISeq protocol: first(), rest(), seq() */\nexport const SEQ = Symbol.for(\"hql.seq\");\n\n/** Counted protocol: count() returns O(1) */\nexport const COUNTED = Symbol.for(\"hql.counted\");\n\n/** Indexed protocol: nth(i) returns O(1) */\nexport const INDEXED = Symbol.for(\"hql.indexed\");\n\n/** Internal sentinel for distinguishing \"not found\" from undefined values */\nconst NOT_FOUND = Symbol(\"not-found\");\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// EMPTY: Singleton empty sequence\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Singleton empty sequence (like Clojure's PersistentList.EMPTY).\n * Implements all protocols with O(1) operations.\n */\nexport const EMPTY = Object.freeze({\n  [SEQ]: true,\n  [COUNTED]: true,\n  [INDEXED]: true,\n  first() { return undefined; },\n  rest() { return this; },\n  seq() { return null; },\n  count() { return 0; },\n  nth() { return NOT_FOUND; },  // Always out of bounds\n  *[Symbol.iterator]() {},\n  toString() { return \"()\"; },\n  [Symbol.for(\"Deno.customInspect\")]() { return \"EMPTY\"; },\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() { return \"EMPTY\"; },\n});\n\n/** Check if a sequence is at its end (null or EMPTY). DRY helper. */\nexport function isSeqEnd(x) {\n  return x == null || x === EMPTY;\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// CONS: Immutable pair (like Clojure's Cons)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Cons - Immutable pair of (first, rest).\n *\n * Time complexity:\n * - first(): O(1)\n * - rest(): O(1)\n * - seq(): O(1)\n * - Iteration: O(n) with O(1) stack via trampolining\n */\nexport class Cons {\n  constructor(first, rest) {\n    this._first = first;\n    this._rest = rest;\n  }\n\n  first() { return this._first; }\n  rest() { return this._rest ?? EMPTY; }\n  seq() { return this; } // Cons is never empty\n\n  *[Symbol.iterator]() {\n    let s = this;\n    while (!isSeqEnd(s)) {\n      // Trampoline: unwrap LazySeq iteratively (O(1) stack)\n      while (s instanceof LazySeq) s = s._realize();\n      if (isSeqEnd(s)) break;\n\n      // Yield from SEQ types\n      if (s[SEQ]) {\n        yield s.first();\n        s = s.rest();\n      } else {\n        // Delegate to other iterables (arrays, etc.)\n        yield* s;\n        break;\n      }\n    }\n  }\n\n  toArray() { return [...this]; }\n\n  toString() {\n    const items = [];\n    let i = 0;\n    for (const x of this) {\n      if (i++ > 20) { items.push(\"...\"); break; }\n      items.push(String(x));\n    }\n    return `(${items.join(\" \")})`;\n  }\n\n  [Symbol.for(\"Deno.customInspect\")]() { return this.toString(); }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() { return this.toString(); }\n}\nCons.prototype[SEQ] = true;\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// LAZYSEQ: Deferred computation (like Clojure's LazySeq)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Convert an iterator/generator to a Cons chain.\n * Used for backwards compatibility with generator-based LazySeq\n * and for converting any iterable to a seq.\n * DRY: Single definition used by both LazySeq._realize() and toSeq().\n */\nfunction iteratorSeq(iter) {\n  const { value, done } = iter.next();\n  if (done) return null;\n  return new Cons(value, new LazySeq(() => iteratorSeq(iter)));\n}\n\n/**\n * LazySeq - Deferred sequence computation with memoization.\n *\n * Key features:\n * - Thunk called once, result cached (memoization)\n * - Trampolining: nested LazySeqs unwrapped iteratively (O(1) stack)\n * - Realizes to Cons or null, never array\n *\n * Time complexity:\n * - first()/rest()/seq(): O(1) after realization\n * - _realize(): O(k) where k = nesting depth, but O(1) stack\n */\nexport class LazySeq {\n  constructor(thunk, isChunkedSource = false) {\n    this._thunk = thunk;\n    this._realized = null;\n    this._isRealized = false;\n    this._isChunkedSource = isChunkedSource;  // Flag for chunk propagation\n  }\n\n  /**\n   * Realize with trampolining (like Clojure's sval + unwrap).\n   * Unwraps nested LazySeqs iteratively to prevent stack overflow.\n   * Also handles generator functions for backwards compatibility.\n   */\n  _realize() {\n    if (this._isRealized) return this._realized;\n\n    let result = this._thunk;\n    this._thunk = null; // GC: release closure\n\n    // Call thunk (or generator function)\n    if (typeof result === \"function\") result = result();\n\n    // BACKWARDS COMPAT: Handle generators (convert to Cons chain)\n    if (result && typeof result[Symbol.iterator] === \"function\" && typeof result.next === \"function\") {\n      // It's a generator/iterator - convert to Cons chain\n      result = iteratorSeq(result);\n    }\n\n    // TRAMPOLINE: unwrap nested LazySeqs iteratively\n    while (result instanceof LazySeq && !result._isRealized) {\n      const nested = result._thunk;\n      result._thunk = null; // GC\n      result = typeof nested === \"function\" ? nested() : nested;\n      // Handle generators in nested thunks too\n      if (result && typeof result[Symbol.iterator] === \"function\" && typeof result.next === \"function\") {\n        result = iteratorSeq(result);\n      }\n    }\n\n    // Get cached value from realized LazySeq\n    if (result instanceof LazySeq) result = result._realized;\n\n    this._realized = result;\n    this._isRealized = true;\n    return result;\n  }\n\n  first() { const s = this._realize(); return s ? s.first() : undefined; }\n  rest() { const s = this._realize(); return s ? s.rest() : EMPTY; }\n  seq() { const s = this._realize(); return s ? s.seq() : null; }\n\n  *[Symbol.iterator]() {\n    const s = this._realize();\n    if (s) yield* s;\n  }\n\n  toString() { const s = this._realize(); return s ? s.toString() : \"()\"; }\n  [Symbol.for(\"Deno.customInspect\")]() { return `LazySeq(${this._isRealized ? this.toString() : \"...\"})`; }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() { return `LazySeq(${this._isRealized ? this.toString() : \"...\"})`; }\n}\nLazySeq.prototype[SEQ] = true;\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// ARRAYSEQ: Efficient array sequence (like Clojure's ArraySeq)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * ArraySeq - View into array with offset (like Clojure's ArraySeq).\n *\n * Design:\n * - Holds reference to original array + index\n * - O(1) first, rest, count, nth\n * - No object creation until rest() called\n *\n * Time complexity:\n * - first(): O(1)\n * - rest(): O(1) - creates new ArraySeq with index+1\n * - count(): O(1)\n * - nth(): O(1)\n */\nexport class ArraySeq {\n  constructor(arr, index = 0) {\n    this._arr = arr;\n    this._i = index;\n  }\n\n  first() { return this._arr[this._i]; }\n\n  rest() {\n    return this._i + 1 < this._arr.length\n      ? new ArraySeq(this._arr, this._i + 1)\n      : EMPTY;\n  }\n\n  seq() { return this; } // ArraySeq is never empty (created only for non-empty)\n\n  count() { return this._arr.length - this._i; }\n\n  nth(n) {\n    const idx = this._i + n;\n    if (idx >= 0 && idx < this._arr.length) return this._arr[idx];\n    return NOT_FOUND;\n  }\n\n  *[Symbol.iterator]() {\n    for (let i = this._i; i < this._arr.length; i++) {\n      yield this._arr[i];\n    }\n  }\n\n  toArray() { return this._arr.slice(this._i); }\n\n  toString() {\n    const items = this._arr.slice(this._i, this._i + 21);\n    const str = items.map(String).join(\" \");\n    return this._arr.length - this._i > 20 ? `(${str} ...)` : `(${str})`;\n  }\n\n  [Symbol.for(\"Deno.customInspect\")]() { return this.toString(); }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() { return this.toString(); }\n}\nArraySeq.prototype[SEQ] = true;\nArraySeq.prototype[COUNTED] = true;\nArraySeq.prototype[INDEXED] = true;\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// NUMERICRANGE: O(1) operations for numeric ranges\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * NumericRange - O(1) count/nth for numeric sequences.\n *\n * JS-native optimization: No chunking, just math.\n * Unlike Clojure's Range which chunks, this provides O(1) random access.\n *\n * Time complexity:\n * - count(): O(1)\n * - nth(): O(1)\n * - first(): O(1)\n * - rest(): O(1)\n */\nexport class NumericRange {\n  constructor(start, end, step) {\n    this._start = start;\n    this._end = end;\n    this._step = step;\n    // Precompute length for O(1) count\n    this._length = end === Infinity\n      ? Infinity\n      : Math.max(0, Math.ceil((end - start) / step));\n  }\n\n  // O(1) - Clojure's Range needs realization to count\n  count() { return this._length; }\n\n  // O(1) - Random access without realization\n  nth(n) {\n    if (n < 0 || n >= this._length) return NOT_FOUND;\n    return this._start + n * this._step;\n  }\n\n  first() {\n    return this._length > 0 ? this._start : undefined;\n  }\n\n  rest() {\n    if (this._length <= 1) return EMPTY;\n    return new NumericRange(this._start + this._step, this._end, this._step);\n  }\n\n  seq() {\n    return this._length > 0 ? this : null;\n  }\n\n  // JS-native iteration\n  *[Symbol.iterator]() {\n    const { _start, _end, _step } = this;\n    if (_step > 0) {\n      for (let i = _start; i < _end; i += _step) yield i;\n    } else {\n      for (let i = _start; i > _end; i += _step) yield i;\n    }\n  }\n\n  toArray() { return [...this]; }\n\n  toString() {\n    if (this._length === 0) return \"()\";\n    if (this._length === Infinity) {\n      const items = [];\n      for (let i = 0; i < 10; i++) {\n        items.push(this.nth(i));\n      }\n      return `(${items.join(\" \")} ...)`;\n    }\n    const items = [];\n    const max = Math.min(21, this._length);\n    for (let i = 0; i < max; i++) {\n      items.push(this.nth(i));\n    }\n    return this._length > 20 ? `(${items.join(\" \")} ...)` : `(${items.join(\" \")})`;\n  }\n\n  [Symbol.for(\"Deno.customInspect\")]() { return this.toString(); }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() { return this.toString(); }\n}\nNumericRange.prototype[SEQ] = true;\nNumericRange.prototype[COUNTED] = true;\nNumericRange.prototype[INDEXED] = true;\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// DELAY: Memoized thunk for explicit laziness\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Delay - Memoized thunk (simpler than Clojure: no synchronization needed).\n *\n * Use for explicit lazy evaluation when you don't need a sequence,\n * just a deferred value that's computed once.\n *\n * JS is single-threaded, so no locking needed unlike Clojure.\n */\nexport class Delay {\n  constructor(thunk) {\n    this._thunk = thunk;\n    this._value = undefined;\n    this._realized = false;\n  }\n\n  deref() {\n    if (!this._realized) {\n      this._value = this._thunk();\n      this._thunk = null; // GC\n      this._realized = true;\n    }\n    return this._value;\n  }\n\n  isRealized() { return this._realized; }\n\n  toString() {\n    return this._realized\n      ? `#<Delay: ${this._value}>`\n      : \"#<Delay: pending>\";\n  }\n\n  [Symbol.for(\"Deno.customInspect\")]() { return this.toString(); }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() { return this.toString(); }\n}\n\n/** Create a Delay from a thunk function. */\nexport function delay(thunk) {\n  return new Delay(thunk);\n}\n\n/** Force evaluation of a Delay, or return value unchanged if not a Delay. */\nexport function force(x) {\n  return x instanceof Delay ? x.deref() : x;\n}\n\n/** Check if value is a Delay. */\nexport function isDelay(x) {\n  return x instanceof Delay;\n}\n\n/** Check if a Delay has been realized. */\nexport function isRealized(x) {\n  return x instanceof Delay ? x._realized : true;\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// REDUCED: Early termination for transducers\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Reduced - Wrapper to signal early termination in transducers.\n *\n * When a reducing function returns a Reduced value, the transduction\n * process should stop immediately and unwrap the inner value.\n *\n * This is essential for:\n * - take(n) transducer\n * - takeWhile(pred) transducer\n * - Any early termination scenario\n */\nexport class Reduced {\n  constructor(val) {\n    this._val = val;\n  }\n\n  deref() { return this._val; }\n\n  toString() { return `#<Reduced: ${this._val}>`; }\n  [Symbol.for(\"Deno.customInspect\")]() { return this.toString(); }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() { return this.toString(); }\n}\n\n/** Wrap value as Reduced for early termination. */\nexport function reduced(x) {\n  return new Reduced(x);\n}\n\n/** Check if value is Reduced. */\nexport function isReduced(x) {\n  return x instanceof Reduced;\n}\n\n/** Unwrap Reduced to get inner value, or return unchanged if not Reduced. */\nexport function unreduced(x) {\n  return isReduced(x) ? x._val : x;\n}\n\n/** Ensure value is Reduced. Returns x if already Reduced, otherwise wraps it. */\nexport function ensureReduced(x) {\n  return isReduced(x) ? x : reduced(x);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// TRANSDUCER PROTOCOL\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Standard transducer protocol keys (JS ecosystem compatible).\n *\n * A transducer is a function that takes a reducing function (rf) and\n * returns a new reducing function. The reducing function has 3 arities:\n *\n * - @@transducer/init: () => initial accumulator\n * - @@transducer/step: (acc, input) => new accumulator (or Reduced)\n * - @@transducer/result: (acc) => final result\n */\nexport const TRANSDUCER_INIT = \"@@transducer/init\";\nexport const TRANSDUCER_STEP = \"@@transducer/step\";\nexport const TRANSDUCER_RESULT = \"@@transducer/result\";\n\n/**\n * Convert a 2-arity function to a transformer object.\n * Used to wrap simple functions like `conj` for use with transducers.\n */\nexport function toTransformer(f) {\n  if (typeof f[TRANSDUCER_STEP] === \"function\") {\n    // Already a transformer\n    return f;\n  }\n  return {\n    [TRANSDUCER_INIT]: () => { throw new Error(\"No init function provided\"); },\n    [TRANSDUCER_STEP]: (acc, x) => f(acc, x),\n    [TRANSDUCER_RESULT]: (acc) => acc,\n  };\n}\n\n/**\n * Create a completing transformer from a base transformer.\n * Wraps the result function with a completion function.\n */\nexport function completing(f, cf) {\n  const transform = toTransformer(f);\n  return {\n    [TRANSDUCER_INIT]: () => transform[TRANSDUCER_INIT](),\n    [TRANSDUCER_STEP]: (acc, x) => transform[TRANSDUCER_STEP](acc, x),\n    [TRANSDUCER_RESULT]: cf || ((acc) => acc),\n  };\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// CHUNKED SEQUENCES (32-element buffers like Clojure)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/** Chunk size - matches Clojure's chunk size exactly */\nexport const CHUNK_SIZE = 32;\n\n/** IChunkedSeq protocol: chunked iteration */\nexport const CHUNKED = Symbol.for(\"hql.chunked\");\n\n/**\n * ArrayChunk - Fixed-size immutable buffer (like Clojure's ArrayChunk).\n *\n * Holds up to 32 elements for amortized iteration.\n * Immutable: slicing returns new ArrayChunk.\n *\n * Time complexity:\n * - count(): O(1)\n * - nth(): O(1)\n * - reduce(): O(n) where n = chunk size\n */\nexport class ArrayChunk {\n  constructor(arr, off = 0, end = arr.length) {\n    this._arr = arr;\n    this._off = off;\n    this._end = end;\n  }\n\n  // IChunk interface\n  count() { return this._end - this._off; }\n  nth(i) {\n    const idx = this._off + i;\n    if (idx >= this._off && idx < this._end) return this._arr[idx];\n    return NOT_FOUND;\n  }\n  first() { return this._arr[this._off]; }\n\n  dropFirst() {\n    if (this._off + 1 >= this._end) return null;\n    return new ArrayChunk(this._arr, this._off + 1, this._end);\n  }\n\n  reduce(f, init) {\n    let acc = init;\n    for (let i = this._off; i < this._end; i++) {\n      acc = f(acc, this._arr[i]);\n      if (isReduced(acc)) return acc;\n    }\n    return acc;\n  }\n\n  *[Symbol.iterator]() {\n    for (let i = this._off; i < this._end; i++) {\n      yield this._arr[i];\n    }\n  }\n\n  toArray() { return this._arr.slice(this._off, this._end); }\n\n  toString() {\n    return `ArrayChunk(${this.count()})`;\n  }\n  [Symbol.for(\"Deno.customInspect\")]() { return this.toString(); }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() { return this.toString(); }\n}\nArrayChunk.prototype[COUNTED] = true;\nArrayChunk.prototype[INDEXED] = true;\n\n/**\n * ChunkBuffer - Mutable buffer for building chunks.\n *\n * Used internally when creating chunked sequences.\n * Call chunk() when full to get immutable ArrayChunk.\n */\nexport class ChunkBuffer {\n  constructor(capacity = CHUNK_SIZE) {\n    this._arr = new Array(capacity);\n    this._end = 0;\n  }\n\n  add(val) {\n    this._arr[this._end++] = val;\n    return this;\n  }\n\n  count() { return this._end; }\n  isFull() { return this._end >= this._arr.length; }\n\n  chunk() {\n    const c = new ArrayChunk(this._arr, 0, this._end);\n    this._arr = null; // Prevent further modification\n    return c;\n  }\n}\n\n/**\n * ChunkedCons - Chunked sequence cell (like Clojure's ChunkedCons).\n *\n * Holds a chunk (ArrayChunk) and a lazy rest.\n * Enables batch processing for better performance.\n *\n * Time complexity:\n * - chunkFirst(): O(1)\n * - chunkRest(): O(1)\n * - first(): O(1)\n * - rest(): O(1) amortized\n */\nexport class ChunkedCons {\n  constructor(chunk, rest) {\n    this._chunk = chunk;\n    this._rest = rest; // LazySeq or null\n  }\n\n  // IChunkedSeq interface\n  chunkFirst() { return this._chunk; }\n  chunkRest() { return this._rest ?? EMPTY; }\n\n  // ISeq interface (unwraps chunk for element access)\n  first() { return this._chunk.first(); }\n\n  rest() {\n    const dropped = this._chunk.dropFirst();\n    if (dropped) {\n      return new ChunkedCons(dropped, this._rest);\n    }\n    // Chunk exhausted, return rest (the next chunk or sequence)\n    const r = this._rest;\n    if (isSeqEnd(r)) return EMPTY;\n    // Realize LazySeq to get the next ChunkedCons (don't skip with .rest()!)\n    if (r instanceof LazySeq) {\n      const realized = r._realize?.() ?? r.seq?.();\n      return realized ?? EMPTY;\n    }\n    return r;\n  }\n\n  seq() { return this._chunk.count() > 0 ? this : null; }\n\n  *[Symbol.iterator]() {\n    // Yield all elements from chunk\n    yield* this._chunk;\n    // Then iterate rest\n    const r = this._rest;\n    if (!isSeqEnd(r)) yield* r;\n  }\n\n  toArray() { return [...this]; }\n\n  toString() {\n    const items = [];\n    let i = 0;\n    for (const x of this) {\n      if (i++ > 20) { items.push(\"...\"); break; }\n      items.push(String(x));\n    }\n    return `(${items.join(\" \")})`;\n  }\n\n  [Symbol.for(\"Deno.customInspect\")]() { return this.toString(); }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() { return this.toString(); }\n}\nChunkedCons.prototype[SEQ] = true;\nChunkedCons.prototype[CHUNKED] = true;\n\n/** Create ChunkedCons from chunk and rest. */\nexport function chunkCons(chunk, rest) {\n  return new ChunkedCons(chunk, rest);\n}\n\n/** Create ArrayChunk from array. */\nexport function arrayChunk(arr, off = 0, end = arr.length) {\n  return new ArrayChunk(arr, off, end);\n}\n\n/** Check if value supports chunked iteration. */\nexport function isChunked(x) {\n  if (x == null) return false;\n  if (x[CHUNKED] === true) return true;\n  // Check if LazySeq is from a chunked operation (enables chunk propagation)\n  if (x instanceof LazySeq && x._isChunkedSource === true) return true;\n  return false;\n}\n\n/** Check if a collection should use chunked operations. DRY helper. */\nexport function shouldChunk(coll) {\n  return (Array.isArray(coll) && coll.length >= CHUNK_SIZE) || isChunked(coll);\n}\n\n/**\n * Check if seq is active (has elements to iterate).\n * DRY helper for: !isSeqEnd(x) && x.seq?.()\n * Returns truthy (the seq itself) if active, falsy if exhausted.\n */\nexport function isActiveSeq(x) {\n  return !isSeqEnd(x) && x.seq?.();\n}\n\n/** Get first chunk from chunked seq. */\nexport function chunkFirst(s) {\n  if (isChunked(s)) return s.chunkFirst();\n  // Non-chunked: wrap single element as chunk\n  const f = s.first?.();\n  return f !== undefined ? new ArrayChunk([f], 0, 1) : null;\n}\n\n/** Get rest after first chunk. */\nexport function chunkRest(s) {\n  if (isChunked(s)) return s.chunkRest();\n  // Non-chunked: rest of seq\n  return s.rest?.() ?? EMPTY;\n}\n\n/**\n * Convert collection to chunked sequence if beneficial.\n *\n * Arrays are chunked (efficient for map/filter).\n * LazySeq is realized to check if it contains chunked content.\n * Other seqs pass through unchanged.\n */\nexport function toChunkedSeq(coll) {\n  if (coll == null) return null;\n\n  // LazySeq: always realize first, even if marked as chunked source\n  // We need the underlying ChunkedCons, not the LazySeq wrapper\n  if (coll instanceof LazySeq) {\n    const realized = coll._realize?.();\n    if (realized == null) return null;\n    // Return the realized content (ChunkedCons or Cons or other)\n    return realized;\n  }\n\n  // Already a ChunkedCons - return directly\n  if (isChunked(coll)) return coll;\n\n  // Arrays benefit from chunking\n  if (Array.isArray(coll) && coll.length > 0) {\n    return arrayToChunkedSeq(coll, 0);\n  }\n\n  // NumericRange: already O(1), but could chunk for map/filter\n  if (coll instanceof NumericRange) {\n    return rangeToChunkedSeq(coll);\n  }\n\n  // Other seqs: return as-is\n  return toSeq(coll);\n}\n\n/** Convert array to chunked sequence. */\nfunction arrayToChunkedSeq(arr, offset) {\n  if (offset >= arr.length) return null;\n  const end = Math.min(offset + CHUNK_SIZE, arr.length);\n  const chunk = new ArrayChunk(arr, offset, end);\n  return new ChunkedCons(\n    chunk,\n    new LazySeq(() => arrayToChunkedSeq(arr, end))\n  );\n}\n\n/** Convert NumericRange to chunked sequence. */\nfunction rangeToChunkedSeq(range) {\n  if (range._length === 0) return null;\n\n  const start = range._start;\n  const end = range._end;\n  const step = range._step;\n\n  function makeChunk(from) {\n    const chunkEnd = step > 0\n      ? Math.min(from + CHUNK_SIZE * step, end)\n      : Math.max(from + CHUNK_SIZE * step, end);\n\n    const arr = [];\n    if (step > 0) {\n      for (let i = from; i < chunkEnd && arr.length < CHUNK_SIZE; i += step) {\n        arr.push(i);\n      }\n    } else {\n      for (let i = from; i > chunkEnd && arr.length < CHUNK_SIZE; i += step) {\n        arr.push(i);\n      }\n    }\n\n    if (arr.length === 0) return null;\n\n    const chunk = new ArrayChunk(arr, 0, arr.length);\n    const nextFrom = from + arr.length * step;\n    const hasMore = step > 0 ? nextFrom < end : nextFrom > end;\n\n    if (hasMore) {\n      return new ChunkedCons(chunk, new LazySeq(() => makeChunk(nextFrom)));\n    }\n    return new ChunkedCons(chunk, null);\n  }\n\n  return makeChunk(start);\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PUBLIC API\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * Create seq from iterator. Exported for core.js to reuse.\n * Returns Cons with lazy rest, or null if exhausted.\n */\nexport { iteratorSeq };\n\n/** Create lazy sequence from thunk. Thunk should return Cons or null. */\nexport function lazySeq(thunk) {\n  return new LazySeq(thunk);\n}\n\n/**\n * Create a LazySeq marked as containing chunked content.\n * Used by chunkedMap, chunkedFilter, etc. to enable chunk propagation.\n */\nexport function chunkedLazySeq(thunk) {\n  return new LazySeq(thunk, true);\n}\n\n/** Create Cons cell. */\nexport function cons(first, rest) {\n  return new Cons(first, rest);\n}\n\n/** Convert collection to seq. Returns null for empty (nil-punning). */\nexport function toSeq(coll) {\n  if (coll == null) return null;\n  if (coll[SEQ]) return coll.seq();\n  if (Array.isArray(coll)) return coll.length > 0 ? new ArraySeq(coll, 0) : null;\n  const iter = coll[Symbol.iterator]?.();\n  return iter ? iteratorSeq(iter) : null;\n}\n\n/** Check if value implements SEQ protocol. */\nexport function isSeq(value) {\n  return value != null && value[SEQ] === true;\n}\n\n/** Check if value is Cons. */\nexport function isCons(value) {\n  return value instanceof Cons;\n}\n\n/** Check if value is LazySeq. */\nexport function isLazySeq(value) {\n  return value instanceof LazySeq;\n}\n\n/**\n * Realize a LazySeq if needed, otherwise return as-is.\n * DRY helper for the pattern: (x instanceof LazySeq) ? x._realize?.() ?? x : x\n */\nexport function maybeRealize(x) {\n  return (x instanceof LazySeq) ? (x._realize?.() ?? x) : x;\n}\n\n/** Check if value is ArraySeq. */\nexport function isArraySeq(value) {\n  return value instanceof ArraySeq;\n}\n\n/** Check if value implements Counted protocol. */\nexport function isCounted(value) {\n  return value != null && value[COUNTED] === true;\n}\n\n/** Check if value implements Indexed protocol. */\nexport function isIndexed(value) {\n  return value != null && value[INDEXED] === true;\n}\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// PROTOCOL-AWARE HELPERS (for use in HQL stdlib)\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n/**\n * O(1) count for Counted types, O(n) fallback.\n */\nexport function count(coll) {\n  if (coll == null) return 0;\n  if (coll[COUNTED]) return coll.count();\n  if (Array.isArray(coll)) return coll.length;\n  if (typeof coll === \"string\") return coll.length;\n  if (coll instanceof Set || coll instanceof Map) return coll.size;\n  // O(n) fallback\n  let n = 0;\n  for (const _ of coll) n++;\n  return n;\n}\n\n/**\n * O(1) nth for Indexed types, O(n) fallback.\n * Uses NOT_FOUND sentinel to correctly handle undefined values.\n */\nexport function nth(coll, index, notFound) {\n  const hasNotFound = arguments.length >= 3;\n\n  if (coll == null) {\n    if (hasNotFound) return notFound;\n    throw new RangeError(`Index ${index} out of bounds on null`);\n  }\n\n  // O(1) for Indexed (uses NOT_FOUND sentinel to distinguish undefined values)\n  if (coll[INDEXED]) {\n    const result = coll.nth(index);\n    if (result === NOT_FOUND) {\n      if (hasNotFound) return notFound;\n      throw new RangeError(`Index ${index} out of bounds`);\n    }\n    return result;\n  }\n\n  // O(1) for arrays\n  if (Array.isArray(coll)) {\n    if (index >= 0 && index < coll.length) return coll[index];\n    if (hasNotFound) return notFound;\n    throw new RangeError(`Index ${index} out of bounds`);\n  }\n\n  // O(1) for strings\n  if (typeof coll === \"string\") {\n    if (index >= 0 && index < coll.length) return coll[index];\n    if (hasNotFound) return notFound;\n    throw new RangeError(`Index ${index} out of bounds`);\n  }\n\n  // O(n) fallback for seqs (also handles negative indices)\n  if (index < 0) {\n    if (hasNotFound) return notFound;\n    throw new RangeError(`Index ${index} out of bounds`);\n  }\n  let s = coll[SEQ] ? coll : toSeq(coll);\n  for (let i = 0; i < index && !isSeqEnd(s); i++) {\n    s = s.rest();\n  }\n  if (isActiveSeq(s)) return s.first();\n  if (hasNotFound) return notFound;\n  throw new RangeError(`Index ${index} out of bounds`);\n}\n",
  "@hql/lib/stdlib/js/index.js": "// @ts-self-types=\"./index.d.ts\"\n// index.js - Public API exports for HQL stdlib\n// Auto-injected into HQL runtime\n\nimport * as Core from \"./core.js\";\nimport * as SelfHosted from \"./self-hosted.js\";\n\n// Export LazySeq, NumericRange, Delay, and Chunking primitives for advanced users\n// CONSOLIDATED: All lazy sequences use seq-protocol.js (thunk-based, O(1) rest)\nexport {\n  LazySeq,\n  NumericRange,\n  Delay,\n  isSeq,\n  // Chunking infrastructure (32-element batches like Clojure)\n  CHUNK_SIZE,\n  ArrayChunk,\n  ChunkBuffer,\n  ChunkedCons,\n} from \"./internal/seq-protocol.js\";\n\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// SELF-HOSTED FUNCTIONS (90% of stdlib)\n// Implemented in HQL (stdlib.hql), pre-transpiled to self-hosted.js\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nconst SELF_HOSTED_FUNCTIONS = new Set([\n  // Phase 1: Core Sequence Operations\n  \"take\", \"drop\", \"map\", \"filter\", \"reduce\", \"concat\", \"flatten\", \"distinct\",\n  // Phase 2: Indexed Operations\n  \"next\", \"nth\", \"second\", \"count\", \"last\",\n  // Phase 3: Map Operations\n  \"mapIndexed\", \"keepIndexed\", \"mapcat\", \"keep\",\n  // Phase 4: Predicates\n  \"isEmpty\", \"some\", \"every\", \"notAny\", \"notEvery\", \"isSome\",\n  // Phase 5: Type Predicates\n  \"isNil\", \"isEven\", \"isOdd\", \"isZero\", \"isPositive\", \"isNegative\",\n  \"isNumber\", \"isString\", \"isBoolean\", \"isFunction\", \"isArray\",\n  // Phase 6: Arithmetic\n  \"inc\", \"dec\",\n  // Phase 7: Comparison\n  \"eq\", \"neq\",\n  // Phase 8: Lazy Constructors\n  \"repeat\", \"repeatedly\", \"cycle\",\n  // Phase 9: Function Operations\n  \"iterate\",\n  // Phase 10: Utilities\n  \"keys\", \"reverse\",\n  // Phase 11: Function Operations\n  \"comp\", \"partial\", \"apply\",\n  // Phase 12: Comparison (variadic)\n  \"lt\", \"gt\", \"lte\", \"gte\",\n  // Phase 13: Arithmetic (variadic)\n  \"add\", \"sub\", \"mul\", \"div\", \"mod\",\n  // Phase 14: Symbol/Keyword\n  \"symbol\", \"keyword\", \"name\",\n  // Phase 15: Type Conversions\n  \"vec\", \"set\", \"doall\",\n  // Phase 16: Map Access\n  \"get\", \"getIn\",\n  // Phase 17: Map Mutations\n  \"assoc\", \"assocIn\", \"dissoc\", \"update\", \"updateIn\", \"merge\",\n  // Phase 18: Collection Protocols\n  \"empty\", \"conj\", \"into\",\n  // Phase 19: Conditional Lazy Functions\n  \"takeWhile\", \"dropWhile\", \"splitWith\", \"splitAt\",\n  // Phase 20: Reduction Variants\n  \"reductions\",\n  // Phase 21: Sequence Combinators\n  \"interleave\", \"interpose\",\n  // Phase 22: Partition Family\n  \"partition\", \"partitionAll\", \"partitionBy\",\n  // Phase 23: Transducers\n  \"mapT\", \"filterT\", \"takeT\", \"dropT\", \"takeWhileT\", \"dropWhileT\",\n  \"distinctT\", \"partitionAllT\", \"composeTransducers\",\n  // Phase 24: Function Utilities\n  \"identity\", \"constantly\", \"vals\", \"juxt\", \"zipmap\",\n]);\n\nexport const STDLIB_PUBLIC_API = Object.fromEntries(\n  Object.entries(Core).filter(([name, value]) =>\n    typeof value === \"function\" &&\n    !name.startsWith(\"__hql_\") &&\n    !SELF_HOSTED_FUNCTIONS.has(name)  // Exclude self-hosted functions\n  )\n);\n\n// Add self-hosted functions (pre-transpiled from HQL)\nfor (const [name, fn] of Object.entries(SelfHosted)) {\n  if (typeof fn === \"function\") {\n    STDLIB_PUBLIC_API[name] = fn;\n  }\n}\n\n// Backwards compatibility: rangeGenerator → range\nSTDLIB_PUBLIC_API.rangeGenerator = Core.range;\n\n// Re-export all functions for direct ES module imports\nexport * from \"./core.js\";\nexport * from \"./self-hosted.js\";\n\n// ES module alias for backwards compatibility\nexport const rangeGenerator = Core.range;\n",
  "@hql/lib/stdlib/js/stdlib.js": "// stdlib.js - Compatibility shim\n// Re-exports from the new modular structure\n// This file exists for backwards compatibility with code that imports from stdlib.js\n// CONSOLIDATED: All lazy sequences use seq-protocol.js (thunk-based, O(1) rest)\n\nexport * from \"./index.js\";\nexport { STDLIB_PUBLIC_API } from \"./index.js\";\n\n// Export seq-protocol for testing lazy sequences properly\nexport {\n  SEQ,\n  LazySeq,\n  lazySeq,\n  isSeq,\n  isLazySeq,\n} from \"./internal/seq-protocol.js\";\n",
  "@hql/lib/stdlib/stdlib.hql": ";; lib/stdlib/stdlib.hql - HQL stdlib with self-hosted functions\n;;\n;; SELF-HOSTED FUNCTIONS:\n;; Phase 1 - Core Sequence Operations:\n;; - take: Returns first n elements from a collection (lazy)\n;; - drop: Drops first n elements from a collection (lazy)\n;; - map: Maps function over collection (lazy)\n;; - filter: Filters collection by predicate (lazy)\n;; - reduce: Reduces collection with function and initial value (EAGER)\n;; - concat: Concatenates multiple collections (lazy)\n;; - flatten: Flattens nested collections (lazy)\n;; - distinct: Removes duplicate elements (lazy)\n;;\n;; Phase 2 - Indexed Operations:\n;; - next: Returns seq of rest, or nil if empty (same as (seq (rest coll)))\n;; - second: Returns second element (same as (nth coll 1 nil))\n;; - nth: Returns element at index with optional not-found\n;; - count: Returns count of elements (EAGER)\n;; - last: Returns last element (EAGER)\n;;\n;; Phase 3 - Map Operations:\n;; - mapIndexed: Maps (index, item) over collection (lazy)\n;; - keepIndexed: Like mapIndexed but filters nil results (lazy)\n;; - mapcat: Maps then flattens one level (lazy)\n;; - keep: Maps and filters nil results (lazy)\n;;\n;; The self-hosted approach:\n;; - Import primitive functions from JS (first, rest, cons, seq, lazy-seq)\n;; - Build higher-level functions in HQL using those primitives\n;; - This is TRUE self-hosting: HQL code that gets transpiled\n\n;; Import primitive functions from JavaScript (the foundation)\n(import [\n  ;; Sequence primitives (Lisp Trinity) - these are the foundation\n  first, rest, cons, seq,\n\n  ;; NOTE: nth, count, second, last, next are NOW SELF-HOSTED BELOW!\n\n  ;; Sequence predicates\n  isEmpty, some,\n\n  ;; Sequence operations (NOT take/drop/map/filter/reduce/concat/flatten/distinct - those are self-hosted below!)\n\n  ;; NOTE: mapIndexed, keepIndexed, mapcat, keep are NOW SELF-HOSTED BELOW!\n\n  ;; Collection protocols (Week 3)\n  seq, empty, conj, into,\n\n  ;; Lazy constructors (Week 4)\n  repeat, repeatedly, cycle,\n\n  ;; Sequence predicates (Week 5)\n  every, notAny, notEvery, isSome,\n\n  ;; Map/Object operations (Week 6)\n  get, getIn, assoc, assocIn, dissoc, update, updateIn, merge,\n\n  ;; Type conversions (Week 6)\n  vec, set,\n\n  ;; Sequence generators\n  rangeGenerator, iterate,\n\n  ;; Function operations\n  comp, partial, apply,\n\n  ;; Utilities\n  groupBy, keys, doall, realized, lazySeq,\n\n  ;; Delay/Force primitives (explicit laziness)\n  force, isDelay\n] from \"./js/stdlib.js\")\n\n;; Create alias for range to match runtime behavior\n(let range rangeGenerator)\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; SELF-HOSTED STDLIB FUNCTIONS\n;; These are implemented in HQL, not JavaScript!\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; take - Returns first n elements from a collection (lazy)\n;; This is TRUE self-hosted HQL code using lazy-seq foundation\n(fn take [n coll]\n  (lazy-seq\n    (when (> n 0)\n      (when-let [s (seq coll)]\n        (cons (first s) (take (- n 1) (rest s)))))))\n\n;; drop - Drops first n elements from a collection (lazy)\n;; Returns remaining elements after skipping n\n;; Note: Uses iterative skip + cons to ensure seq-protocol compatibility\n(fn drop [n coll]\n  (lazy-seq\n    (loop [s (seq coll) remaining n]\n      (if (and s (> remaining 0))\n        (recur (rest s) (- remaining 1))\n        (when s\n          (cons (first s) (drop 0 (rest s))))))))\n\n;; map - Maps function over collection (lazy)\n;; This is the heart of functional programming\n;; Pattern: (lazy-seq (when-let [s (seq coll)] (cons (f (first s)) (map f (rest s)))))\n(fn map [f coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (cons (f (first s)) (map f (rest s))))))\n\n;; filter - Filters collection by predicate (lazy)\n;; Only includes elements where (pred elem) is truthy\n;; Pattern: skip non-matching elements recursively until we find one\n(fn filter [pred coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [f (first s)]\n        (if (pred f)\n          (cons f (filter pred (rest s)))\n          (filter pred (rest s)))))))\n\n;; reduce - Reduces collection with function and initial value (EAGER)\n;; This is the foundation of many aggregate operations\n;; Unlike map/filter, reduce consumes the entire collection\n(fn reduce [f init coll]\n  (loop [acc init, s (seq coll)]\n    (if s\n      (recur (f acc (first s)) (rest s))\n      acc)))\n\n;; concat - Concatenates multiple collections (lazy)\n;; Variadic function: (concat [1 2] [3 4]) => (1 2 3 4)\n;; Processes collections one element at a time\n(fn concat [& colls]\n  (lazy-seq\n    (when-let [cs (seq colls)]\n      (if-let [s (seq (first cs))]\n        (cons (first s) (apply concat (cons (rest s) (rest cs))))\n        (apply concat (rest cs))))))\n\n;; flatten - Flattens nested collections (lazy)\n;; Recursively flattens all iterable items (except strings)\n;; Note: Uses JS interop for iterable checking in pre-transpiled version\n(fn flatten [coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [f (first s)]\n        (if (coll? f)  ;; coll? checks for collections (arrays, seqs) but not strings\n          (concat (flatten f) (flatten (rest s)))\n          (cons f (flatten (rest s))))))))\n\n;; distinct - Removes duplicate elements (lazy)\n;; Uses a Set to track seen elements efficiently\n;; Note: Pre-transpiled version uses JS Set for O(1) lookup\n(fn distinct [coll]\n  (let [step (fn [s seen]\n               (lazy-seq\n                 (when-let [xs (seq s)]\n                   (let [f (first xs)]\n                     (if (contains? seen f)\n                       (step (rest xs) seen)\n                       (cons f (step (rest xs) (conj seen f))))))))]\n    (step coll #{})))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 2: INDEXED OPERATIONS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; next - Returns (seq (rest coll)), nil if rest is empty\n;; This is the Clojure-style \"next\" that differs from \"rest\"\n;; next returns nil for empty, rest returns empty seq\n(fn next [coll]\n  (seq (rest coll)))\n\n;; nth - Returns element at index, with optional not-found value\n;; Uses loop to iterate to the index position\n;; Throws error if out of bounds and no not-found provided\n;; Note: Uses (seq args) instead of (count args) to avoid circular dependency\n(fn nth [coll index & args]\n  (let [not-found (first args)\n        has-not-found (seq args)]  ;; truthy if args is non-empty\n    (if (nil? coll)\n      (if has-not-found\n        not-found\n        (throw (js/Error (str \"nth: index \" index \" out of bounds for null collection\"))))\n      (loop [s (seq coll), i 0]\n        (if s\n          (if (=== i index)\n            (first s)\n            (recur (rest s) (+ i 1)))\n          (if has-not-found\n            not-found\n            (throw (js/Error (str \"nth: index \" index \" out of bounds\")))))))))\n\n;; second - Returns second element of collection\n;; Simply (nth coll 1 nil) - returns nil if less than 2 elements\n(fn second [coll]\n  (nth coll 1 nil))\n\n;; count - Returns count of elements (EAGER)\n;; Forces full realization of lazy sequences\n(fn count [coll]\n  (if (nil? coll)\n    0\n    (loop [s (seq coll), n 0]\n      (if s\n        (recur (rest s) (+ n 1))\n        n))))\n\n;; last - Returns last element (EAGER)\n;; Forces full realization to find the last element\n(fn last [coll]\n  (if (nil? coll)\n    nil\n    (loop [s (seq coll), result nil]\n      (if s\n        (recur (rest s) (first s))\n        result))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 3: MAP OPERATIONS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; mapIndexed - Maps function (index, item) over collection (lazy)\n;; Like map but the function receives (index, item) instead of just (item)\n(fn mapIndexed [f coll]\n  (let [step (fn [s idx]\n               (lazy-seq\n                 (when-let [xs (seq s)]\n                   (cons (f idx (first xs))\n                         (step (rest xs) (+ idx 1))))))]\n    (step coll 0)))\n\n;; keepIndexed - Like mapIndexed but filters nil results (lazy)\n;; Only keeps results where (f index item) is not nil/undefined\n(fn keepIndexed [f coll]\n  (let [step (fn [s idx]\n               (lazy-seq\n                 (when-let [xs (seq s)]\n                   (let [result (f idx (first xs))]\n                     (if (some? result)\n                       (cons result (step (rest xs) (+ idx 1)))\n                       (step (rest xs) (+ idx 1)))))))]\n    (step coll 0)))\n\n;; mapcat - Maps function then concatenates/flattens one level (lazy)\n;; Equivalent to (apply concat (map f coll))\n(fn mapcat [f coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (concat (f (first s)) (mapcat f (rest s))))))\n\n;; keep - Maps function and filters nil results (lazy)\n;; Only keeps results where (f item) is not nil/undefined\n(fn keep [f coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [result (f (first s))]\n        (if (some? result)\n          (cons result (keep f (rest s)))\n          (keep f (rest s)))))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 3B: CONDITIONAL LAZY FUNCTIONS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; takeWhile - Returns elements while predicate is true (lazy)\n;; Clojure: (take-while pos? [1 2 3 0 -1]) => (1 2 3)\n(fn takeWhile [pred coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [f (first s)]\n        (when (pred f)\n          (cons f (takeWhile pred (rest s))))))))\n\n;; dropWhile - Drops elements while predicate is true (lazy)\n;; Clojure: (drop-while pos? [1 2 3 0 -1 2]) => (0 -1 2)\n(fn dropWhile [pred coll]\n  (lazy-seq\n    (loop [s (seq coll)]\n      (if (and s (pred (first s)))\n        (recur (rest s))\n        (when s\n          (cons (first s) (rest s)))))))\n\n;; splitWith - Returns [(takeWhile pred coll) (dropWhile pred coll)]\n(fn splitWith [pred coll]\n  [(doall (takeWhile pred coll)) (doall (dropWhile pred coll))])\n\n;; splitAt - Returns [(take n coll) (drop n coll)]\n(fn splitAt [n coll]\n  [(doall (take n coll)) (doall (drop n coll))])\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 3C: REDUCTION VARIANTS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; reductions - Returns lazy seq of intermediate reduce values\n;; Clojure: (reductions + [1 2 3 4]) => (1 3 6 10)\n;; Clojure: (reductions + 0 [1 2 3]) => (0 1 3 6)\n(fn reductions [f & args]\n  (let [reductions-with-init\n        (fn reductions-with-init [f init coll]\n          (cons init\n                (lazy-seq\n                  (when-let [s (seq coll)]\n                    (reductions-with-init f (f init (first s)) (rest s))))))]\n    (if (=== (count args) 1)\n      ;; 2-arity: (reductions f coll)\n      (let [coll (first args)]\n        (lazy-seq\n          (when-let [s (seq coll)]\n            (reductions-with-init f (first s) (rest s)))))\n      ;; 3-arity: (reductions f init coll)\n      (reductions-with-init f (first args) (second args)))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 3D: SEQUENCE COMBINATORS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; interpose - Inserts separator between elements (lazy)\n;; Clojure: (interpose :x [1 2 3]) => (1 :x 2 :x 3)\n(fn interpose [sep coll]\n  (let [interpose-rest\n        (fn interpose-rest [sep coll]\n          (lazy-seq\n            (when-let [s (seq coll)]\n              (cons sep (cons (first s) (interpose-rest sep (rest s)))))))]\n    (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (first s) (interpose-rest sep (rest s)))))))\n\n;; interleave - Interleaves multiple sequences (lazy)\n;; Clojure: (interleave [1 2 3] [:a :b :c]) => (1 :a 2 :b 3 :c)\n(fn interleave [& colls]\n  (lazy-seq\n    (let [seqs (map seq colls)]\n      (when (every some? seqs)\n        (concat (map first seqs)\n                (apply interleave (map rest seqs)))))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 3E: PARTITION FAMILY\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; partition - Partitions into groups of n, drops incomplete (lazy)\n;; 2-arity: (partition n coll) - step defaults to n\n;; 3-arity: (partition n step coll) - explicit step\n;; Clojure: (partition 3 [1 2 3 4 5 6 7]) => ((1 2 3) (4 5 6))\n(fn partition [n & args]\n  (let [arg-count (count args)\n        step (if (=== arg-count 1) n (first args))\n        coll (if (=== arg-count 1) (first args) (second args))]\n    (lazy-seq\n      (when-let [s (seq coll)]\n        (let [p (doall (take n s))]\n          (when (=== (count p) n)\n            (cons p (partition n step (drop step s)))))))))\n\n;; partitionAll - Like partition but includes incomplete final group (lazy)\n;; Clojure: (partition-all 3 [1 2 3 4 5 6 7]) => ((1 2 3) (4 5 6) (7))\n(fn partitionAll [n & args]\n  (let [arg-count (count args)\n        step (if (=== arg-count 1) n (first args))\n        coll (if (=== arg-count 1) (first args) (second args))]\n    (lazy-seq\n      (when-let [s (seq coll)]\n        (let [p (doall (take n s))]\n          (cons p (partitionAll n step (drop step s))))))))\n\n;; partitionBy - Partitions when function result changes (lazy)\n;; Clojure: (partition-by odd? [1 1 2 2 3]) => ((1 1) (2 2) (3))\n(fn partitionBy [f coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [fst (first s)\n            fv (f fst)\n            run (doall (cons fst (takeWhile (fn [x] (=== (f x) fv)) (rest s))))]\n        (cons run (partitionBy f (drop (count run) s)))))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 4: PREDICATES\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; isEmpty - Tests if collection is empty\n;; Returns true if nil or empty, false otherwise\n(fn isEmpty [coll]\n  (nil? (seq coll)))\n\n;; some - Returns first item where predicate returns truthy, or nil\n;; Short-circuits on first match\n(fn some [pred coll]\n  (loop [s (seq coll)]\n    (if s\n      (if (pred (first s))\n        (first s)\n        (recur (rest s)))\n      nil)))\n\n;; every - Returns true if predicate returns truthy for all items\n;; Short-circuits on first falsy, empty collection returns true (vacuous truth)\n(fn every [pred coll]\n  (loop [s (seq coll)]\n    (if s\n      (if (pred (first s))\n        (recur (rest s))\n        false)\n      true)))\n\n;; notAny - Returns true if predicate returns false for all items\n;; Equivalent to (not (some pred coll))\n(fn notAny [pred coll]\n  (loop [s (seq coll)]\n    (if s\n      (if (pred (first s))\n        false\n        (recur (rest s)))\n      true)))\n\n;; notEvery - Returns true if predicate returns false for at least one item\n;; Equivalent to (not (every pred coll))\n(fn notEvery [pred coll]\n  (loop [s (seq coll)]\n    (if s\n      (if (pred (first s))\n        (recur (rest s))\n        true)\n      false)))\n\n;; isSome - Returns true if value is not nil (null or undefined)\n;; Note: This only checks for nil, not falsiness (0, false, \"\" return true)\n(fn isSome [x]\n  (not (nil? x)))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 5: TYPE PREDICATES\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n(fn isNil [x] (nil? x))\n(fn isEven [n] (== 0 (mod n 2)))\n(fn isOdd [n] (not (== 0 (mod n 2))))\n(fn isZero [n] (== n 0))\n(fn isPositive [n] (> n 0))\n(fn isNegative [n] (< n 0))\n(fn isNumber [x] (== \"number\" (typeof x)))\n(fn isString [x] (== \"string\" (typeof x)))\n(fn isBoolean [x] (== \"boolean\" (typeof x)))\n(fn isFunction [x] (== \"function\" (typeof x)))\n(fn isArray [x] (js-call Array.isArray x))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 6: ARITHMETIC\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n(fn inc [x] (+ x 1))\n(fn dec [x] (- x 1))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 7: COMPARISON\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n(fn eq [& vals]\n  (if (< (count vals) 2)\n    true\n    (let [fst (first vals)]\n      (loop [s (rest vals)]\n        (if (seq s)\n          (if (=== fst (first s))\n            (recur (rest s))\n            false)\n          true)))))\n\n(fn neq [a b] (not (=== a b)))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 8: LAZY CONSTRUCTORS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; repeat - Infinite sequence of the same value\n(fn repeat [x]\n  (lazy-seq (cons x (repeat x))))\n\n;; repeatedly - Infinite sequence calling f each time\n(fn repeatedly [f]\n  (lazy-seq (cons (f) (repeatedly f))))\n\n;; cycle - Infinite sequence cycling through collection\n(fn cycle [coll]\n  (let [xs (seq coll)]\n    (if xs\n      (let [step (fn [s]\n                   (lazy-seq\n                     (if (seq s)\n                       (cons (first s) (step (rest s)))\n                       (step xs))))]\n        (step xs))\n      nil)))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 9: FUNCTION OPERATIONS\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; iterate - Returns x, f(x), f(f(x)), ...\n(fn iterate [f x]\n  (lazy-seq (cons x (iterate f (f x)))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 10: UTILITIES\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; keys - Get keys from an object\n(fn keys [obj]\n  (if (nil? obj)\n    []\n    (js-call Object.keys obj)))\n\n;; reverse - Reverse a collection\n(fn reverse [coll]\n  (if (nil? coll)\n    []\n    (.. (js-call Array.from coll) (reverse))))\n\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n;; PHASE 11: FUNCTION UTILITIES\n;; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n;; identity - Returns its argument unchanged\n(fn identity [x] x)\n\n;; constantly - Returns a function that always returns x\n(fn constantly [x]\n  (fn [& _] x))\n\n;; vals - Get values from an object/map\n(fn vals [m]\n  (if (nil? m)\n    []\n    (js-call Object.values m)))\n\n;; juxt - Juxtaposition: returns fn that calls all fns on same args\n(fn juxt [& fns]\n  (fn [& args]\n    (map (fn [f] (apply f args)) fns)))\n\n;; zipmap - Create map from keys and values\n(fn zipmap [ks vs]\n  (loop [keys (seq ks) values (seq vs) result {}]\n    (if (and keys values)\n      (recur (next keys) (next values)\n             (assoc result (first keys) (first values)))\n      result)))\n\n;; Export all functions\n(export [\n  ;; Sequence primitives (Lisp Trinity)\n  first, rest, cons,\n\n  ;; Indexed access & counting (Phase 2 self-hosted)\n  next, nth, count, second, last,\n\n  ;; Sequence predicates\n  isEmpty, some,\n\n  ;; Sequence operations\n  take, map, filter, reduce, drop, concat, flatten, distinct,\n\n  ;; Map operations (Phase 3 self-hosted)\n  mapIndexed, keepIndexed, mapcat, keep,\n\n  ;; Conditional lazy functions (Phase 3B)\n  takeWhile, dropWhile, splitWith, splitAt,\n\n  ;; Reduction variants (Phase 3C)\n  reductions,\n\n  ;; Sequence combinators (Phase 3D)\n  interleave, interpose,\n\n  ;; Partition family (Phase 3E)\n  partition, partitionAll, partitionBy,\n\n  ;; Collection protocols (Week 3)\n  seq, empty, conj, into,\n\n  ;; Lazy constructors (Week 4)\n  repeat, repeatedly, cycle,\n\n  ;; Sequence predicates (Week 5)\n  every, notAny, notEvery, isSome,\n\n  ;; Map/Object operations (Week 6)\n  get, getIn, assoc, assocIn, dissoc, update, updateIn, merge,\n\n  ;; Type conversions (Week 6)\n  vec, set,\n\n  ;; Sequence generators\n  range, rangeGenerator, iterate,\n\n  ;; Function operations\n  comp, partial, apply,\n\n  ;; Utilities\n  groupBy, keys, doall, realized, lazySeq,\n\n  ;; Function utilities (Phase 11)\n  identity, constantly, vals, juxt, zipmap,\n\n  ;; Delay/Force (explicit laziness)\n  ;; Note: 'delay' is a special form, not a function\n  force, isDelay\n])",
  "@hql/test": "(fn assert [condition message]\n  (if (not condition)\n      (throw (or message \"Assertion failed\"))\n      true))\n\n(fn assert-eq [actual expected message]\n  (if (!== actual expected)\n      (throw (+ (or message \"Assertion failed\") \" - Expected: \" expected \", Actual: \" actual))\n      true))\n\n(fn assert-throws [fn message]\n  (try\n    (fn)\n    (throw (or message \"Expected function to throw an error, but it didn't\"))\n    (catch e true)))\n\n(export [assert, assert-eq, assert-throws])\n",
  "@hql/date": "(fn now [] (js-call js/Date \"now\"))\n(fn parse [s] (js-call js/Date \"parse\" s))\n(fn format [ts] (.toISOString (new js/Date ts)))\n(fn add [ts ms] (+ ts ms))\n(fn diff [t1 t2] (- t1 t2))\n(export [now, parse, format, add, diff])\n",
  "@hql/math": "(fn abs [n] (js/Math.abs n))\n(fn floor [n] (js/Math.floor n))\n(fn ceil [n] (js/Math.ceil n))\n(fn round [n] (js/Math.round n))\n(fn min [& args] (apply js/Math.min args))\n(fn max [& args] (apply js/Math.max args))\n(fn pow [base exp] (js/Math.pow base exp))\n(fn sqrt [n] (js/Math.sqrt n))\n(export [abs, floor, ceil, round, min, max, pow, sqrt])\n",
  "@hql/http": "(fn request [url options] (js/fetch url options))\n(fn get [url] (js/fetch url))\n(fn post [url body] (js/fetch url {\"method\": \"POST\", \"body\": body}))\n(export [request, get, post])\n",
  "@hql/ai": "; @hql/ai - AI-Native Functions for HQL\n; Usage: (import [ask] from \"@hql/ai\")\n;\n; FUNDAMENTAL DUAL-MODE API:\n; One function, two behaviors - determined by how YOU call it:\n;\n;   (ask \"hello\")           → STREAMING: Live token-by-token output\n;   (await (ask \"hello\"))   → COMPLETION: Returns full response as string\n;\n; This is a fundamental HQL language feature:\n; - Direct call returns async generator → REPL streams automatically\n; - await consumes the generator → returns concatenated result\n;\n; Works with ALL async generator functions, not just AI.\n\n; ============================================================================\n; Internal: Streaming generator using Ollama API\n; ============================================================================\n\n; Process stream and yield tokens - returns async generator\n(async fn* stream-tokens [response]\n  \"Yield tokens from a streaming response\"\n  (let body response.body)\n  (let reader (body.getReader))\n  (let decoder (new js/TextDecoder))\n  (var done false)\n\n  (while (not done)\n    (let chunk (await (reader.read)))\n    (if chunk.done\n      (= done true)\n      (do\n        (let text (decoder.decode chunk.value))\n        (let lines (text.split \"\\n\"))\n        ; Process each line using index\n        (var i 0)\n        (while (< i lines.length)\n          (let line (js-get lines i))\n          (when (> line.length 0)\n            (try\n              (let json (js/JSON.parse line))\n              (let token json.response)\n              (when token\n                (yield token))\n              (catch e nil)))\n          (= i (+ i 1)))))))\n\n; Process chat stream and yield tokens\n(async fn* stream-chat-tokens [response]\n  \"Yield tokens from a streaming chat response\"\n  (let body response.body)\n  (let reader (body.getReader))\n  (let decoder (new js/TextDecoder))\n  (var done false)\n\n  (while (not done)\n    (let chunk (await (reader.read)))\n    (if chunk.done\n      (= done true)\n      (do\n        (let text (decoder.decode chunk.value))\n        (let lines (text.split \"\\n\"))\n        ; Process each line using index\n        (var i 0)\n        (while (< i lines.length)\n          (let line (js-get lines i))\n          (when (> line.length 0)\n            (try\n              (let json (js/JSON.parse line))\n              (let msg json.message)\n              (when msg\n                (let token msg.content)\n                (when token\n                  (yield token)))\n              (catch e nil)))\n          (= i (+ i 1)))))))\n\n; Internal: Non-streaming API\n(async fn ollama-generate [prompt model]\n  (let response (await\n    (js/fetch \"http://127.0.0.1:11434/api/generate\"\n      {\"method\": \"POST\"\n       \"headers\": {\"Content-Type\": \"application/json\"}\n       \"body\": (js/JSON.stringify {\"model\": (or model \"gemma3:1b\")\n                                   \"prompt\": prompt\n                                   \"stream\": false})})))\n  (let data (await (response.json)))\n  data.response)\n\n(async fn ollama-chat-sync [messages model]\n  (let response (await\n    (js/fetch \"http://127.0.0.1:11434/api/chat\"\n      {\"method\": \"POST\"\n       \"headers\": {\"Content-Type\": \"application/json\"}\n       \"body\": (js/JSON.stringify {\"model\": (or model \"gemma3:1b\")\n                                   \"messages\": messages\n                                   \"stream\": false})})))\n  (let data (await (response.json)))\n  data.message.content)\n\n; ============================================================================\n; Public API - Streaming (async generators)\n; ============================================================================\n\n; (ask \"question\") - Returns async generator that yields tokens\n; REPL automatically streams the output\n(async fn* ask [prompt & options]\n  \"Stream AI response. Returns async generator - REPL streams automatically.\"\n  (let opts (first options))\n  (let model (when opts opts.model))\n  (let response (await\n    (js/fetch \"http://127.0.0.1:11434/api/generate\"\n      {\"method\": \"POST\"\n       \"headers\": {\"Content-Type\": \"application/json\"}\n       \"body\": (js/JSON.stringify {\"model\": (or model \"gemma3:1b\")\n                                   \"prompt\": prompt\n                                   \"stream\": true})})))\n  (yield* (stream-tokens response)))\n\n; (generate \"description\") - Stream code generation\n(async fn* generate [description & options]\n  \"Stream code generation. Returns async generator.\"\n  (let opts (first options))\n  (let model (when opts opts.model))\n  (let full-prompt (str \"Generate code for: \" description \". Output ONLY code, no explanations.\"))\n  (let response (await\n    (js/fetch \"http://127.0.0.1:11434/api/generate\"\n      {\"method\": \"POST\"\n       \"headers\": {\"Content-Type\": \"application/json\"}\n       \"body\": (js/JSON.stringify {\"model\": (or model \"gemma3:1b\")\n                                   \"prompt\": full-prompt\n                                   \"stream\": true})})))\n  (yield* (stream-tokens response)))\n\n; (chat messages) - Stream chat response\n(async fn* chat [messages & options]\n  \"Stream chat response. Returns async generator.\"\n  (let opts (first options))\n  (let model (when opts opts.model))\n  (let response (await\n    (js/fetch \"http://127.0.0.1:11434/api/chat\"\n      {\"method\": \"POST\"\n       \"headers\": {\"Content-Type\": \"application/json\"}\n       \"body\": (js/JSON.stringify {\"model\": (or model \"gemma3:1b\")\n                                   \"messages\": messages\n                                   \"stream\": true})})))\n  (yield* (stream-chat-tokens response)))\n\n; (summarize text) - Stream summarization\n(async fn* summarize [text & options]\n  \"Stream summarization. Returns async generator.\"\n  (let opts (first options))\n  (let model (when opts opts.model))\n  (let full-prompt (str \"Summarize the following text concisely:\\n\\n\" text))\n  (let response (await\n    (js/fetch \"http://127.0.0.1:11434/api/generate\"\n      {\"method\": \"POST\"\n       \"headers\": {\"Content-Type\": \"application/json\"}\n       \"body\": (js/JSON.stringify {\"model\": (or model \"gemma3:1b\")\n                                   \"prompt\": full-prompt\n                                   \"stream\": true})})))\n  (yield* (stream-tokens response)))\n\n; ============================================================================\n; DEPRECATED: *-sync variants are no longer needed!\n; With HQL's enhanced await, just use (await (ask ...)) instead of (ask-sync ...)\n; ============================================================================\n\n(export [ask generate chat summarize])\n",
  "@hql/string": "(fn split [s sep] (.split s sep))\n(fn join [arr sep] (.join arr sep))\n(fn trim [s] (.trim s))\n(fn upper-case [s] (.toUpperCase s))\n(fn lower-case [s] (.toLowerCase s))\n(fn starts-with? [s search] (.startsWith s search))\n(fn ends-with? [s search] (.endsWith s search))\n(fn replace [s search replacement] (.replace s search replacement))\n(export [split, join, trim, upper-case, lower-case, starts-with?, ends-with?, replace])\n",
  "@hql/fs": "(fn read [path] (js/Deno.readTextFile path))\n(fn write [path content] (js/Deno.writeTextFile path content))\n(fn remove [path] (js/Deno.remove path))\n(fn exists? [path] \n  (try \n    (js/Deno.statSync path) \n    true \n    (catch e false)))\n(export [read, write, remove, exists?])\n"
};
