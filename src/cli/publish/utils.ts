import {
  exists,
  readTextFile,
  resolve,
  writeTextFile,
  join,
  readDir,
  runCmd,
  dirname,
} from "../../platform/platform.ts";
import { parse } from "../../transpiler/pipeline/parser.ts";
import { globalLogger as logger } from "../../logger.ts";
import { getErrorMessage } from "../../common/utils.ts";
import { buildJsModule } from "./build_js_module.ts";

/**
 * HQL Configuration interface
 */
export interface HqlConfig extends Record<string, unknown> { // Extend Record<string, unknown>
  name: string;
  version: string;
  exports?: string;
  description?: string;
  author?: string;
  license?: string;
  repository?: string;
  homepage?: string;
  dependencies?: Record<string, string>;
}

export type MetadataFileType = "package.json" | "deno.json" | "jsr.json";

/**
 * Metadata file types for JSR/NPM
 */
export interface MetadataStatus {
  npm: MetadataFileType | null;
  jsr: MetadataFileType | null;
}

export interface RunCommandOptions {
  cmd: string[];
  cwd: string;
  dryRun?: boolean;
  verbose?: boolean;
  extraFlags?: string[];
}

const buildCache = new Map<string, Promise<string>>();

/**
 * Read and parse JSON file
 */
export async function readJSONFile(path: string): Promise<Record<string, unknown>> {
  try {
    const content = await readTextFile(path);
    return JSON.parse(content);
  } catch (error) {
    throw new Error(
      `Failed to read JSON file ${path}: ${
        getErrorMessage(error)
      }`,
    );
  }
}

/**
 * Write object to JSON file
 */
export async function writeJSONFile(
  path: string,
  data: Record<string, unknown>,
): Promise<void> {
  try {
    const content = JSON.stringify(data, null, 2);
    await writeTextFile(path, content);
  } catch (error) {
    throw new Error(
      `Failed to write JSON file ${path}: ${
        getErrorMessage(error)
      }`,
    );
  }
}

/**
 * Verify that the entry file is a valid HQL module
 */
export async function verifyEntryFile(entryPath: string): Promise<boolean> {
  try {
    if (!(await exists(entryPath))) {
      console.error(`Entry file not found: ${entryPath}`);
      return false;
    }

    const content = await readTextFile(entryPath);
    try {
      // Try to parse to ensure valid HQL
      parse(content, entryPath);
      return true;
    } catch (error) {
      console.error(
        `Entry file contains syntax errors: ${
          getErrorMessage(error)
        }`,
      );
      return false;
    }
  } catch (error) {
    console.error(
      `Error verifying entry file: ${
        getErrorMessage(error)
      }`,
    );
    return false;
  }
}

/** Metadata file info */
interface MetadataFile {
  path: string;
  content: string;
}

/** Result of metadata generation */
interface PackageMetadata {
  npm: MetadataFile | null;
  jsr: MetadataFile | null;
}

/**
 * Generate package metadata files (package.json, deno.json, etc.)
 */
export function generatePackageMetadata(
  config: HqlConfig,
  outDir: string,
): PackageMetadata {
  // Generate package.json for NPM
  const packageJson = {
    name: config.name,
    version: config.version,
    description: config.description || `HQL module: ${config.name}`,
    main: "mod.js",
    types: "mod.d.ts",
    license: config.license || "MIT",
    author: config.author,
    repository: config.repository,
    homepage: config.homepage,
    dependencies: config.dependencies,
    scripts: {
      test: "echo \"Error: no test specified\" && exit 1",
    },
  };

  // Generate deno.json for JSR
  const denoJson = {
    name: config.name.startsWith("@") ? config.name : `@${config.author || "hql"}/${config.name}`,
    version: config.version,
    exports: "./mod.ts",
    tasks: {
      test: "deno test",
    },
    imports: config.dependencies,
  };

  return {
    npm: {
      path: resolve(outDir, "package.json"),
      content: JSON.stringify(packageJson, null, 2),
    },
    jsr: {
      path: resolve(outDir, "deno.json"),
      content: JSON.stringify(denoJson, null, 2),
    },
  };
}

/**
 * Create a README.md if it doesn't exist
 */
export async function ensureReadme(projectPath: string, config: HqlConfig): Promise<void> {
  const readmePath = resolve(projectPath, "README.md");
  
  if (await exists(readmePath)) {
    return;
  }

  const packageName = config.name;
  
  const template = `# ${packageName}

> **This is a template README automatically generated by [HQL Publish](https://github.com/boraseoksoon/hql-dev).**
> Please update this file with your own project details!

---

## üì¶ About

This is a module published with [HQL](https://github.com/boraseoksoon/hql-dev).
Describe your project here!

## üöÄ Getting Started

Install via your preferred registry:

- **JSR:**
  \`\`\`sh
  deno add ${packageName}
  \`\`\`
- **NPM:**
  \`\`\`sh
  npm install ${packageName}
  \`\`\`

## üõ† Publishing with HQL

To publish updates, run:

\`\`\`sh
hql publish <entry-file> [jsr|npm] [version] [--dry-run]
\`\`\`
See [HQL Publish Guide](https://github.com/boraseoksoon/hql-dev) for full details.

## üìÑ Customizing this README

Edit this file (\`README.md\`) to add your own project description, usage examples, API docs, contribution guidelines, and more.

## üìö Resources

- [HQL Documentation](https://github.com/boraseoksoon/hql-dev)
- [Report Issues](https://github.com/boraseoksoon/hql-dev/issues)

---

## üìù License

[MIT](./LICENSE) (or your preferred license)
`;

  try {
    await writeTextFile(readmePath, template);
    console.log("Created README.md template.");
  } catch (error) {
    logger.warn(`Failed to create README.md: ${getErrorMessage(error)}`);
  }
}

// Alias for backward compatibility
export const ensureReadmeExists = ensureReadme;

/**
 * Detect existing metadata files
 */
export async function detectMetadataFiles(
  dir: string,
): Promise<MetadataStatus> {
  const result: MetadataStatus = {
    npm: null,
    jsr: null,
  };

  const dirsToCheck = [dir, join(dir, "dist")];

  for (const checkDir of dirsToCheck) {
    if (!result.npm && await exists(join(checkDir, "package.json"))) {
      result.npm = "package.json";
      logger.debug && logger.debug(`Found package.json in ${checkDir}`);
    }

    if (!result.jsr && await exists(join(checkDir, "deno.json"))) {
      result.jsr = "deno.json";
      logger.debug && logger.debug(`Found deno.json in ${checkDir}`);
    } else if (!result.jsr && await exists(join(checkDir, "jsr.json"))) {
      result.jsr = "jsr.json";
      logger.debug && logger.debug(`Found jsr.json in ${checkDir}`);
    }
  }

  logger.debug &&
    logger.debug(`Detected metadata files: ${JSON.stringify(result)}`);

  return result;
}

/**
 * Execute a command and handle its output
 */
export async function executeCommand(
  options: RunCommandOptions,
): Promise<{ success: boolean; error?: string }> {
  const { cmd, cwd, extraFlags = [] } = options;

  try {
    const process = runCmd({
      cmd: [...cmd, ...extraFlags],
      cwd,
      stdin: "inherit",
      stdout: "inherit",
      stderr: "inherit",
    });

    const status = await process.status;

    if (status.success) {
      return { success: true };
    } else {
      return { success: false, error: "Command failed" };
    }
  } catch (error) {
    return {
      success: false,
      error: getErrorMessage(error),
    };
  }
}

export function promptUser(
  message: string,
  defaultValue = "",
): Promise<string> {
  const promptMessage = defaultValue
    ? `${message} (${defaultValue}):`
    : `${message}:`;

  console.log(promptMessage);

  const input = prompt("> ") ?? "";
  return Promise.resolve(input.trim() || defaultValue);
}

export function incrementPatchVersion(version: string): string {
  const parts = version.split(".");
  if (parts.length !== 3) {
    return "0.0.1";
  }

  try {
    const major = parseInt(parts[0], 10);
    const minor = parseInt(parts[1], 10);
    let patch = parseInt(parts[2], 10);
    patch++;

    return `${major}.${minor}.${patch}`;
  } catch {
    return "0.0.1";
  }
}

export function getCachedBuild(
  entryFile: string,
  options: { verbose?: boolean; dryRun?: boolean },
): Promise<string> {
  if (!buildCache.has(entryFile)) {
    logger.debug && logger.debug(`Creating new build for ${entryFile}`);
    const buildPromise = buildJsModule(entryFile, options);
    buildCache.set(entryFile, buildPromise);

    buildPromise.catch(() => {
      buildCache.delete(entryFile);
    });

    return buildPromise;
  }

  logger.debug && logger.debug(`Reusing cached build for ${entryFile}`);
  return buildCache.get(entryFile)!;
}

export function getPlatformsFromArgs(args: string[]): ("jsr" | "npm")[] {
  const allForms = new Set(["all", "-all", "--all", "-a"]);
  const npmForms = new Set(["npm", "-npm", "--npm"]);
  const jsrForms = new Set(["jsr", "-jsr", "--jsr"]);

  let isAll = false, isNpm = false, isJsr = false;

  for (const arg of args) {
    if (allForms.has(arg)) isAll = true;
    else if (npmForms.has(arg)) isNpm = true;
    else if (jsrForms.has(arg)) isJsr = true;
  }

  if (!isAll && !isNpm && !isJsr) {
    return ["jsr"];
  }

  if (isAll) {
    return ["jsr", "npm"];
  }

  const platforms: ("jsr" | "npm")[] = [];
  if (isJsr) platforms.push("jsr");
  if (isNpm) platforms.push("npm");

  return platforms;
}

export function compareVersions(a: string, b: string): number {
  const pa = a.split(".").map(Number);
  const pb = b.split(".").map(Number);
  for (let i = 0; i < 3; i++) {
    if ((pa[i] || 0) < (pb[i] || 0)) return -1;
    if ((pa[i] || 0) > (pb[i] || 0)) return 1;
  }
  return 0;
}

export async function resolveNextPublishVersion(
  remoteVersion: string | null,
  localVersion: string | null,
  promptUserFn: (msg: string, def: string) => Promise<string>,
  incrementPatchVersionFn: (v: string) => string,
  registryName: string,
): Promise<string> {
  if (remoteVersion && localVersion) {
    const comparison = compareVersions(remoteVersion, localVersion);

    if (comparison < 0) {
      const suggested = incrementPatchVersionFn(localVersion);
      console.warn(
        `  ‚Üí Warning: Remote ${registryName} version (${remoteVersion}) is lower than local version (${localVersion}).`,
      );
      return await promptUserFn(
        `Remote ${registryName} version (${remoteVersion}) is lower than your local metadata version (${localVersion}).\nPlease confirm the version to publish`,
        suggested,
      );
    }

    const baseVersion = comparison > 0 ? remoteVersion : localVersion;
    return incrementPatchVersionFn(baseVersion);
  }

  if (remoteVersion) {
    return incrementPatchVersionFn(remoteVersion);
  }

  if (localVersion) {
    return incrementPatchVersionFn(localVersion);
  }

  return "0.0.1";
}

export async function updateSourceMetadataFiles(
  distDir: string,
  metaFiles: string[],
  version: string,
): Promise<void> {
  const sourceDir = dirname(distDir);
  for (const metaFile of metaFiles) {
    const sourceMetaPath = join(sourceDir, metaFile);
    if (await exists(sourceMetaPath)) {
      try {
        const sourceConfig = await readJSONFile(sourceMetaPath);
        sourceConfig.version = version;
        await writeJSONFile(sourceMetaPath, sourceConfig);
        console.log(
          `  ‚Üí Updated source ${metaFile} file with version ${version}`,
        );
      } catch (e) {
        console.warn(`  ‚Üí Warning: Could not update source ${metaFile}: ${getErrorMessage(e)}`);
      }
    }
  }
}

async function collectDirectoryEntries(
  dir: string,
  entries: Array<{ path: string; isFile: boolean }>,
): Promise<void> {
  for await (const entry of readDir(dir)) {
    const entryPath = join(dir, entry.name);
    if (entry.isDirectory) {
      entries.push({ path: entryPath, isFile: false });
      await collectDirectoryEntries(entryPath, entries);
    } else if (entry.isFile) {
      entries.push({ path: entryPath, isFile: true });
    }
  }
}

// ANSI color codes for production-ready formatting
const colors = {
  reset: "\x1b[0m",
  bold: "\x1b[1m",
  blue: "\x1b[34m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  cyan: "\x1b[36m",
};

function colorize(text: string, color: keyof typeof colors) {
  return `${colors[color]}${text}${colors.reset}`;
}

export async function visualizeTree(
  distDir: string,
  highlightFiles: string[] = [],
): Promise<string> {
  if (!(await exists(distDir))) {
    return colorize(`(No build output at ${distDir})`, "yellow");
  }
  const treeLines: string[] = [];
  const base = distDir.endsWith("/") ? distDir.slice(0, -1) : distDir;
  const baseLen = base.length + 1;

  // Gather all files/dirs
  const entries: { path: string; isFile: boolean }[] = [];
  await collectDirectoryEntries(distDir, entries);

  // Sort by directory depth then alphabetically
  entries.sort((a, b) => a.path.localeCompare(b.path));

  // Build tree
  for (let i = 0; i < entries.length; ++i) {
    const { path, isFile } = entries[i];
    const relPath = path.slice(baseLen);
    const parts = relPath.split("/");
    let prefix = "";
    for (let j = 0; j < parts.length - 1; ++j) {
      prefix += (j === 0 ? "" : "  ") + "‚îÇ ";
    }
    const isLast = i === entries.length - 1 ||
      (entries[i + 1].path.slice(0, path.length + 1) !== path + "/");
    const branch = isLast ? "‚îî‚îÄ" : "‚îú‚îÄ";
    let display = `${prefix}${branch} ${parts[parts.length - 1]}`;
    if (highlightFiles.some((hf) => relPath.endsWith(hf))) {
      display = colorize(display, "green") + colorize(" ‚Üê bundled", "cyan");
    } else if (!isFile) {
      display = colorize(display, "blue") + "/";
    }
    treeLines.push(display);
  }
  return colorize(`\nFiles to be published from ${distDir}:\n`, "bold") +
    treeLines.join("\n");
}
